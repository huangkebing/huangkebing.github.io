<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法题专项突破[位运算]</title>
    <url>/2023/08/14/algorithm/%E4%B8%93%E9%A1%B9/%E7%AE%97%E6%B3%95%E9%A2%98%E4%B8%93%E9%A1%B9_%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>首先来明确一下Java中有哪些位运算符，以及各自的运算规则</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>规则</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>两者均为1时，结果为1。如1101&amp;1011&#x3D;1001</td>
</tr>
<tr>
<td>&#96;</td>
<td>&#96;</td>
</tr>
<tr>
<td><code>~</code></td>
<td>取反，如~1101&#x3D;0010</td>
</tr>
<tr>
<td><code>^</code></td>
<td>异或，两者相同时为1，不同为1。如1101^1011&#x3D;0110</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移运算，将二进制串整体左移，低位补0</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移运算，将二进制串整体右移，高位补符号位(即正数补0，负数补1)</td>
</tr>
<tr>
<td><code>&gt;&gt;&gt;</code></td>
<td>无符号右移运算，将二进制串整体右移，高位补0</td>
</tr>
</tbody></table>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>明确了位运算符后，还需要积累应用场景，因为算法题中不会说让你求a&amp;b，更多的是抽象过的要求，这就考验我们能否将问题和位运算关联起来</p>
<p>下面记录一下，在算法基础提升阶段遇到的位运算应用场景</p>
<h3 id="判断尾位是否为1"><a href="#判断尾位是否为1" class="headerlink" title="判断尾位是否为1"></a>判断尾位是否为1</h3><p>利于<code>&amp;</code>符号的特性，n&amp;1如果为1，说明n的尾位是1</p>
<p>同样的，如果n&amp;1&#x3D;0，说明n的尾位是0</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>专项突破</category>
      </categories>
  </entry>
  <entry>
    <title>算法题专项突破[排序]</title>
    <url>/2023/06/13/algorithm/%E4%B8%93%E9%A1%B9/%E7%AE%97%E6%B3%95%E9%A2%98%E4%B8%93%E9%A1%B9_%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇是算法题第二系列算法专项突破的第一篇，本系列主要针对每类算法做一个专项提高、总结各类题型。针对总结过的每类算法，可以做到融会贯通。</p>
<p>::: tip</p>
<p>关于排序算法的概念、原理，已经有很多整理的非常好的博文了。没必要自己再整理一遍</p>
<p>排序算法：<a class="link"   href="https://www.cnblogs.com/onepixel/articles/7674659.html" >十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>这篇内容主要涉及:</p>
<ul>
<li>实现一下各类排序算法(当你能用代码实现时，自然就理解这些算法了)，另外方便起见就不考虑数组长度为0等特殊场景</li>
<li>分析各个算法的区别</li>
<li>分析各个算法的时间空间复杂度</li>
<li>随时补充一些衍生场景</li>
</ul>
<p>:::</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序的核心就是两两比较，不断移动极值</p>
<p>实现上也比较简单，主要注意循环的临界值，不要数组越界、多比较或者少比较了</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bubble</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 外层循环每执行一次，排序好的元素数量便+1，i=已排序元素数量-1</span></span><br><span class="line"><span class="comment">         * 此处i从1开始，因为执行length-1轮时，未排序数量=length - (length - 1 - 1) = 2</span></span><br><span class="line"><span class="comment">         * 所以length-1轮就是最后一轮</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 内层循环每执行一次，就比较相邻两个元素的大小关系</span></span><br><span class="line"><span class="comment">             * array[j] &gt; array[j + 1]是实现升序的逻辑，改成小于号则为降序</span></span><br><span class="line"><span class="comment">             * 此处循环上限是length-i，因为要使用j+1为了避免越界，需要在已排序元素数量上多减1</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>衍生1、提前终止冒泡排序</p>
</blockquote>
<p>如果有如下输入：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure></div>

<p>我们按照冒泡排序的思路来做，发现第一轮冒泡元素<code>8</code>移动到了数组尾部后，数组已经排序完成了！</p>
<p>但程序依旧还要继续执行6轮冒泡，属于无效比较，说明我们的冒泡排序还有优化空间</p>
<p>加入一个boolean值标记记录是否触发交换，当一轮比较完成，没有元素的交换，说明排序已经完成，提前终止 </p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bubble</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 外层循环每执行一次，排序好的元素数量便+1，i=已排序元素数量-1</span></span><br><span class="line"><span class="comment">         * 此处i从1开始，因为执行length-1轮时，未排序数量=length - (length - 1 - 1) = 2</span></span><br><span class="line"><span class="comment">         * 所以length-1轮就是最后一轮</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 内层循环每执行一次，就比较相邻两个元素的大小关系</span></span><br><span class="line"><span class="comment">             * array[j] &gt; array[j + 1]是实现升序的逻辑，改成小于号则为降序</span></span><br><span class="line"><span class="comment">             * 此处循环上限是length-i，因为要使用j+1为了避免越界，需要在已排序元素数量上多减1</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">swap</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                    swap = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 当一轮比较完成，没有元素的交换，说明排序已经完成，提前终止 </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(!swap)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>复杂度分析</p>
</blockquote>
<p>空间上 使用了swap、temp两个变量，因此空间复杂度为O(1)</p>
<p>时间上 如果数组本身就有序，那么时间复杂度可以达到O(n)，但绝大多少情况时间复杂度还是O(n^2^)</p>
<blockquote>
<p>归纳</p>
</blockquote>
<p>冒泡排序虽然简单，但效率属实不行，除非是要求使用冒泡排序，否则一般不使用</p>
<p>那么冒泡排序的考察点就很有限了，因为本身很简单，大概只有冒泡排序的优化</p>
<ol>
<li>已经有序时直接跳出循环(衍生1)</li>
<li>不要再去遍历已经有序的部分(内层循环的<code>j &lt; array.length - i;</code>)</li>
</ol>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Selection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 外层排序只需执行length-1次</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 取剩下元素中的极值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; array[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移动到剩下元素的首部</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[minIndex];</span><br><span class="line">            array[minIndex] = array[i];</span><br><span class="line">            array[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>复杂度分析</p>
</blockquote>
<p>空间上 使用了minIndex、temp两个变量，因此空间复杂度为O(1)</p>
<p>时间上 始终是O(n^2^)</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Insertion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] insertionSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 从1开始循环，因为第一个元素可以认为是默认排序的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> array[i];</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 从已排序的末尾开始往前遍历，找到位置插入</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> lastIndex; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; curr) &#123;</span><br><span class="line">                    array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    array[j + <span class="number">1</span>] = curr;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>复杂度分析</p>
</blockquote>
<p>只使用了lastIndex，curr两个变量，空间复杂度为O(1)</p>
<p>时间上，如果数组有序那么每次内循环比较一次就能结束复杂度为O(n)，但一般情况下复杂度还是O(n^2^)</p>
<h2 id="冒泡选择插入归纳"><a href="#冒泡选择插入归纳" class="headerlink" title="冒泡选择插入归纳"></a>冒泡选择插入归纳</h2><p>3个排序算法的平均时间复杂度均是O(n^2^)，所以在日常开发或者是算法题中一般不会使用(除非是算法题或者面试非得要求你用)</p>
<p>3者在实现上有以下区别：</p>
<ul>
<li>冒泡排序是相邻的两个元素两两比较</li>
<li>选择排序是找未排序元素的极值放到已排序元素的末尾</li>
<li>插入排序是将待排序元素依次插入到已排序元素中</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Quick</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] quickSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">        quick(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> partition(array, left, right);</span><br><span class="line">        quick(array, left, partition - <span class="number">1</span>);</span><br><span class="line">        quick(array, partition + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> array[start];</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; array[end] &gt;= key) &#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; array[start] &lt;= key) &#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(array, start, i);</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[n];</span><br><span class="line">        array[n] = array[m];</span><br><span class="line">        array[m] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<blockquote>
<p>衍生1、快速选择</p>
</blockquote>
<p>快速选择基于快速排序的实现，可以用于高效的解决最大&#x2F;小的K个数问题</p>
<p><a class="link"   href="https://www.huangkebing.com/2023/05/30/algorithm/offer/%E5%89%91%E6%8C%87Offer_Part2/#40%E3%80%81%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0" >剑指Offer_Part.2 - technology-inn (huangkebing.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Merge</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            mergeSort(arr, start, mid);</span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, end);</span><br><span class="line">            merge(arr, start, mid, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> mid, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                temp[k++] = arr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= end) &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(temp, <span class="number">0</span>, arr, start, temp.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>先递归分解数组，拆分到1个元素后开始比较值进行合并，从而保证最后的有序</p>
<blockquote>
<p>复杂度分析</p>
</blockquote>
<p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>专项突破</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解Java虚拟机_概览</title>
    <url>/2023/05/26/book/JVM/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA_P1/</url>
    <content><![CDATA[<h2 id="Ⅰ、前言"><a href="#Ⅰ、前言" class="headerlink" title="Ⅰ、前言"></a>Ⅰ、前言</h2><p>读周志明老师的《深入理解Java虚拟机：JVM高级特性与实践（第3版）》读书笔记，会参杂一些自己的心路历程和理解</p>
<h2 id="Ⅱ、概览图"><a href="#Ⅱ、概览图" class="headerlink" title="Ⅱ、概览图"></a>Ⅱ、概览图</h2><p>ProcessOn上的老哥绘制的，看了觉得很详细就买了一份</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/JVM_overview.png"
                      alt="JVM_overview"
                ></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Effective Java_第2章</title>
    <url>/2023/05/27/book/EffectiveJava/Effective_Java_P2/</url>
    <content><![CDATA[<h2 id="Ⅰ、前言"><a href="#Ⅰ、前言" class="headerlink" title="Ⅰ、前言"></a>Ⅰ、前言</h2><p>读Joshua Bloch的《Effective Java（第3版）》读书笔记</p>
<p>针对书中提及的一些规则以及优缺点的解释，如果是能理解的场景那么就写上自己的理解，如果暂时不理解那么先不做解释，后续回顾再做补充</p>
<h2 id="第1条、用静态工厂方法代替构造器"><a href="#第1条、用静态工厂方法代替构造器" class="headerlink" title="第1条、用静态工厂方法代替构造器"></a>第1条、用静态工厂方法代替构造器</h2><p>静态工厂方法是指在一个类中定义一个静态方法，用于创建该类的实例对象，并返回该实例对象。静态工厂方法通常被用于隐藏对象的创建细节，提供更简洁的对象创建方式。静态工厂方法还可以控制对象的创建（例如缓存对象、限制数量等），并且可以返回该类的子类的实例对象，使用静态方法名称和参数组合可以创建多种不同的实例对象。常见的静态工厂方法是<code>valueOf()</code>方法，例如<code>Integer.valueOf()</code>、<code>Boolean.valueOf()</code>等。</p>
<p>静态工厂方法相比构造器，有以下优点：</p>
<ol>
<li><p>静态工厂方法与构造器不同的第一大优势在于，它们有名称</p>
<p>可以跟据方法名来表明创建对象的作用或者含义，无需通过分析入参来明确。例如，可能会使用构造器<code>BigInteger(int,int,Random)</code>来创建素数，但如果使用静态方法<code>BigInteger.probablePrime()</code> 的来表示，调用方代码会更明确</p>
</li>
<li><p>静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象</p>
<p>Java new对象是一个比较耗性能的操作，能复用就复用。例如，<code>Integer.valueOf()</code>当值在[-128,127]区间内时，会直接返回缓存池中的实例，而这在构造器中是无法实现的</p>
<p>::: danger</p>
<h3 id="问题1、Java-new对象为什么耗性能"><a href="#问题1、Java-new对象为什么耗性能" class="headerlink" title="问题1、Java new对象为什么耗性能"></a>问题1、Java new对象为什么耗性能</h3><blockquote>
<p>Q：为什么Java中，new对象比较耗性能？</p>
</blockquote>
<p>具体涉及到JVM，先写一个笼统的答案</p>
<p>创建对象的过程需要调用构造函数，这个过程包括分配内存和初始化对象，会消耗一定的时间和内存</p>
<p>另外，Java的垃圾回收机制也会影响创建对象的性能。当创建大量对象时，垃圾回收器需要花费更多的时间来回收不再被使用的对象</p>
<p>:::</p>
</li>
<li><p>静态工厂方法与构造器不同的第三大优势在子，它们可以返回原返回类型的任何子类型的对象</p>
</li>
<li><p>静态工厂的第四大优势在于，所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值</p>
</li>
<li><p>静态工厂的第五大优势在于，方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>静态工厂方法的主要缺点在子类如果不含公有的或者受保护的构造器，就不能被子类化</p>
</li>
<li><p>静态工厂方法的第二个缺点在于，程序员很难发现它们</p>
<p>因为构造器和其他方法是属于两类方法，而静态工厂方法很难和其他方法区分开来。如在idea中调构造器只需要XXX.new，但静态工厂方法则需要在一堆方法中找</p>
<p>因此必须有明显的方法名以及注释来标明，其中明显的方法名，如：<code>of</code>，<code>valueOf</code>，<code>newInstance</code>，<code>createInstance</code>等等</p>
</li>
</ol>
<h2 id="第2条、遇到多个构造器参数时要考虑使用构建器"><a href="#第2条、遇到多个构造器参数时要考虑使用构建器" class="headerlink" title="第2条、遇到多个构造器参数时要考虑使用构建器"></a>第2条、遇到多个构造器参数时要考虑使用构建器</h2><p>静态工厂和构造器有个共同的局限性：它们都不能很好扩展到大量的可选参数，这时构建器就可以很好的适应这类情况。</p>
<p>因为构建器非常常见，且自己也经常用到，就不列举书中的内容了。</p>
<p>::: tip</p>
<p>如ChatGPT的Java包，需要构建一个<code>ChatCompletionRequest</code>，提供了非常多的参数，但通常不会全部用到</p>
<p>这时候如果要使用构造器来覆盖所有情况，是不现实的</p>
<p>这时候，使用构建器就可以完美解决，使用者只需要跟据自己的需要提供部分参数即可(和构造器使用类似)，但实现起来构建器则轻松得多</p>
<p>:::</p>
<p><font color="#16b777">注意Builder手动实现非常麻烦，代码量很大且逻辑很简单，通常使用idea插件或者Lombok的@Builder来实现</font></p>
<h2 id="第3条、用私有构造器或者枚举类型强化Singleton属性"><a href="#第3条、用私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="第3条、用私有构造器或者枚举类型强化Singleton属性"></a>第3条、用私有构造器或者枚举类型强化Singleton属性</h2>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Java IO_系列一</title>
    <url>/2023/06/27/JDK8/io/Java_IO_4%E7%B1%BB%E6%B5%81/</url>
    <content><![CDATA[<h2 id="IO系列目录"><a href="#IO系列目录" class="headerlink" title="IO系列目录"></a>IO系列目录</h2><h2 id="Ⅰ、目前现状"><a href="#Ⅰ、目前现状" class="headerlink" title="Ⅰ、目前现状"></a>Ⅰ、目前现状</h2><p>在日常业务开发中，很少会用到IO，因为像数据库操作、读文件等IO操作，都已经有封装了，日常使用只需要直接使用。</p>
<p>这也导致了我对IO这块了解非常少，而且现在很多框架使用NIO，然而我连IO这部分都不甚了解，遇到问题就是啥也不知道，要自己实现一个读文件甚至还需要去搜！</p>
<p>因此决定先花一些时间，从源码入手，学习IO</p>
<h2 id="一、IO概览"><a href="#一、IO概览" class="headerlink" title="一、IO概览"></a>一、IO概览</h2><p>位于java.io包，通过类名，可以发现这些类的后缀基本都是以InputStream、OutputStream、Reader、Writer结尾</p>
<p>而这4个就是4类IO流</p>
<table>
<thead>
<tr>
<th></th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody></table>
<p>直接从源码的角度看看这4个有什么区别</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>IO</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式_概述</title>
    <url>/2023/05/29/design_pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ol>
<li><a class="link"   href="https://www.huangkebing.com/blogs/design_pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E6%A6%82%E8%BF%B0.html" >设计模式概述 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<p>梳理了一下设计模式的目标和原则，但是很多地方都理解不透，很难和实际开发联系起来，开发经验还是不足</p>
<h2 id="设计模式的目标"><a href="#设计模式的目标" class="headerlink" title="设计模式的目标"></a>设计模式的目标</h2><p>设计模式是为了提高代码重用性、可读性、可扩展性、可靠性，使得程序呈现出高内聚、低耦合的特性</p>
<ul>
<li><p>代码重用性</p>
<p>代码重用性是指在开发过程中，将可重用的代码抽象出来，形成一个可以多次使用的独立程序模块或函数，以提高开发效率的能力。这可以节省时间和开发资源，并降低代码的维护成本。重复使用代码还可以提高程序的稳定性和可靠性，减少错误和缺陷。</p>
<p><font color="#dd0000">这里并不是简单的提取方法，我在业务代码上就遇到过其他人抽的工具方法，但他的方法里还有一些特殊处理，但是我本次要实现的业务不需要这部分处理！但我又不敢动这个方法，因为影响的地方很多，只能另写。所以说在做方法封装，尤其是基本方法时，最好是一个方法只做一件事情！</font></p>
</li>
<li><p>可读性</p>
<p>代码可读性指的是源代码易于被其他人阅读、理解和维护的程度。可读性良好的代码应该易于阅读，表达清晰，遵循一致的命名规则和代码风格，包含适当的注释和文档，结构清晰，没有过于复杂的逻辑，以及易于调试和修改。</p>
<p><font color="#16b777">跟据我的经验，做到可读性，需要做到这些：</font></p>
<ul>
<li><font color="#16b777">命名：通过变量名、方法名可以知晓作用，而不用跟据代码去推断</font></li>
<li><font color="#16b777">注释：注释详尽，尤其是特殊处理、核心逻辑的注释</font></li>
<li><font color="#16b777">结构：一个类不要写很多方法，一个方法也不要写很多if，注意代码复杂度</font></li>
</ul>
<p>一些老的业务代码，命名用的拼音缩写还没有注释，你熟悉这些业务时跟猜谜游戏一样。还有所有逻辑都放在一个类里，非常臃肿，找逻辑非常费劲，读起来经常读着读着就不知道到哪了</p>
</li>
<li><p>可扩展性</p>
<p>代码可扩展性是指代码的设计和实现方式，使得在现有的系统结构上能够简便地添加新的功能或扩展现有的功能，同时保持代码的可靠性、可读性、可维护性、可重用性和性能表现。代码可扩展性是在软件开发中非常重要的一种软件特性，因为随着业务发展和软件需求的不断变化，软件系统需要不断地进行功能扩展和改进。如果代码不具备可扩展性，就会面临极高的成本和复杂度，甚至需要彻底重构系统来适应新的需求</p>
<p>可扩展性是最难去做的，往往日常开发中，遇到问题都是加个if，或者加个方法处理。这样长久必然出现可读性的问题。而可扩展性，难在需要在前期就将需求整理清晰，并做好代码结构的规划，还需要对未来不可预知的内容留足空间。而这的基本要求就是要熟练掌握设计模式</p>
<p><font color="#16b777">举个简单的例子：处理流程非常多的，可以用责任链模式改造，将每个步骤封装到链路节点中，将来要加新的处理逻辑时，只需要新建一个节点，可以有效避免代码堆砌</font></p>
</li>
<li><p>可靠性</p>
<p>代码可靠性是指代码在运行过程中能够提供准确出错信息，并能够避免出现系统崩溃或不可预期的错误情况。代码可靠性的提高需要从多个方面入手，包括代码设计、编程实现、代码测试、缺陷修复等多个环节。代码可靠性的提高可以增加系统的稳定性和可用性，降低运维成本和故障数量</p>
<p>这部分主要是通过日志的设计来获得准确信息，以及测试的工作。<font color="#dd0000">但要注意，日志不要滥写，try-catch也不要到处都是最好是统一管理</font></p>
</li>
<li><p>高内聚、低耦合</p>
<p>高内聚低耦合是一种软件设计原则，其中“高内聚”指模块内部紧密地相关，且单一模块的职责明确，而“低耦合”指不同模块之间尽可能地减少相互依赖，从而提高系统的可维护性、可重用性和可扩展性</p>
</li>
</ul>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>单一职责原则(Single Responsibility Principle)，英文缩写为SRP</p>
<p>是指一个类或者模块（函数、方法）只负责完成一个职责或功能，不应该去承担其他的职责或功能。换句话说，一个类或者模块应该只有一个引起它变化的原因</p>
<p>但事实上，单一是一个非常主观的概念：</p>
<p>比如说有一个类，专门负责计算某项数据，输入为原始数据，输出为计算后的数据。那么这个类从宏观上就是单一的，因为他只做了这件事情。</p>
<p>但如果这个类有3000行，包含60个方法呢？</p>
<p>因此我的理解，不光光说是认为单一就足够了，还需要结合实际情况和业务场景</p>
<ul>
<li>类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性</li>
<li>类依赖的其他类过多,或者依赖类的其他类过多,不符合高内聚、低耦合的设计思想</li>
<li>私有方法过多,我们就要考虑能否将私有方法独立到新的类中,设置为public方法,供更多的类使用</li>
<li>比较难给类起一个合适名字,很难用一个业务名词概括,或者只能用一些笼统的Manager、 Context之类的词语来命名,这就说明类的职责定义得可能不够清晰</li>
</ul>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>里氏替换原则（Liskov Substitution Principle，LSP）是面向对象程序设计中的一个原则，由Barbara Liskov和Jeannette Wing于1987年提出。该原则表明，子类应该能够替换他们的基类，而程序仍然不会出错。换句话说，子类应该完全继承其父类的行为，同时还能够扩展新的功能，而不会导致任何不符合预期的结果。</p>
<p>我的理解。当父类是可实例化的类(排除接口和抽象类)，父类与子类的约定。里氏替换原则要求子类在进行设计的时候要遵守父类的一些行为约定。</p>
<ul>
<li>子类中可以增加自己特有的方法</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li>
<li>当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的的输出&#x2F;返回值）要比父类的方法更严格或相等</li>
<li>子类重载方法，不能抛出父类中没有约定的异常</li>
</ul>
<p>如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>依赖倒置原则(Dependence Inversion Principle)是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p>
<p>依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则：</p>
<ul>
<li>每个类尽量提供接口或抽象类，或者两者都具备</li>
<li>变量的声明类型尽量是接口或者是抽象类</li>
<li>任何类都不应该从具体类派生</li>
<li>使用继承时尽量遵循里氏替换原则</li>
</ul>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>客户端不应该依赖它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。</p>
<ul>
<li>建立单一接口，不要建立庞大臃肿的接口</li>
<li>尽量细化接口，接口中的方法尽量少</li>
</ul>
<p>注意：注意适度原则，一定要适度，过大的话会增加耦合性，而过小的话会增加复杂性和开发成本</p>
<p>优点：符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性</p>
<p>这是针对接口设计的原则，即一个类实现接口，会不会有我用不到的方法需要我去实现，如果有那么这个接口是不符合接口隔离原则的</p>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>迪米特法则（Law of Demeter）又称最少知识原则（Principle of Least Knowledge），是一种软件设计原则，其主要目的是减少对象间的耦合度，使得模块化的程序更加灵活、可维护、易于扩展。</p>
<p>迪米特法则的基本原则是：一个对象应该对其他对象保持最少的了解，即一个对象不应该直接与其他对象交互，而应该通过中间对象进行交互，从而避免对象之间的耦合。这样可以减少对象之间的依赖关系，降低系统的复杂度，提高代码的可读性和可维护性。</p>
<p>迪米特法则的另一种表述：只与你的直接朋友通信，不与陌生人通信。直接朋友包括以下几种：当前对象本身、被当作方法参数传递进来的对象、当前对象的实例变量直接引用的对象以及当前对象的任何一个方法中创建的对象。</p>
<p>这个地方朋友、陌生人在代码中分别指代哪些东西，实在是没看懂</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>开闭原则（Open Closed Principle）是编程中最基础、最重要设计原则</p>
<p>一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节。</p>
<p>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式_结构型</title>
    <url>/2023/06/05/design_pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E7%BB%93%E6%9E%84%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ol>
<li><a class="link"   href="https://www.huangkebing.com/blogs/design_pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E6%A6%82%E8%BF%B0.html" >设计模式概述 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.huangkebing.com/blogs/design_pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E7%BB%93%E6%9E%84%E5%9E%8B.html" >设计模式结构型 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<p>结构型设计模式是一组用于解决对象之间组合关系的设计模式，用于简化系统的设计，提高系统的可维护性和可扩展性。</p>
<p>结构型设计模式包括以下几种：</p>
<ol>
<li>适配器模式（Adapter Pattern）：将一个类的接口转换成客户端所期望的另一种接口，解决不兼容问题</li>
<li>桥接模式（Bridge Pattern）：将抽象部分与它的实现部分分离，使它们可以独立地变化</li>
<li>组合模式（Composite Pattern）：将对象组合成树形结构，以表示”部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性</li>
<li>装饰器模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责，就象给一个人穿上不同的衣服一样</li>
<li>外观模式（Facade Pattern）：为子系统中的一组接口提供一个一致的界面，使得子系统更加容易使用</li>
<li>享元模式（Flyweight Pattern）：运用共享技术有效地支持大量细粒度的对象，节省内存</li>
<li>代理模式（Proxy Pattern）：为其他对象提供一个代理以控制对这个对象访问的方式</li>
</ol>
<p>先争取将每个设计模式的定义、简单的代码示例写清楚。后续记录一些问题以及读源码时遇到的设计模式</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。<br>在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。</p>
<p><font color="#16b777">直白的说，如程序中已有一个类A，现在有一个新业务，其逻辑和A一致，但入参、返回值不一样</font></p>
<p>适配器模式可以分为类适配器、对象适配器和接口适配器</p>
<h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Effective Java_第3章</title>
    <url>/2023/06/01/book/EffectiveJava/Effective_Java_P3/</url>
    <content><![CDATA[<h2 id="第10条、覆盖equals时请遵守通用约定"><a href="#第10条、覆盖equals时请遵守通用约定" class="headerlink" title="第10条、覆盖equals时请遵守通用约定"></a>第10条、覆盖equals时请遵守通用约定</h2><p>覆盖 equals 方法看起来似乎很简单，但是有许多覆盖方式会导致错误，并且后果非常严重</p>
<p>最容易避免这类问题的办法就是不覆盖 equals 方法，在这种情况下，类的每个实例都只与自身相等</p>
<p>如果满足了以下任何一个条件，则无需覆盖equals方法：</p>
<ul>
<li><p>类的每个实例都是唯一的</p>
<p>因为Object提供的equals方法就是比较二者是否为同一个对象，既然每个实例都是唯一的，那么如果不是同一个对象也必然是不相等的</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>类没有必要提供equals方法，从Object继承得到的equals足够使用</p>
</li>
<li><p>父类已经覆盖了equals，子类也能使用父类的equals</p>
<p>如ArrayList直接使用了AbstractList中覆盖的equals方法</p>
</li>
<li><p>类是私有的，或者是包级私有的，即 equals 方法永远不会被调用</p>
<p>但反射是可以实例化私有类的，因此想要彻底保护，可以重写equals方法并在方法中抛出异常</p>
</li>
</ul>
<p>而当对象需要比较字段值，而父类又没有覆盖equals时，就需要覆盖equals。如String、Integer等</p>
<p>在覆盖 equals 方法的时候，必须要遵守它的通用约定：</p>
<ul>
<li>自反性(reflexive)：对于任何非 null 的引用值 x，<code>x.equals(x)</code> 必须返回true </li>
<li>对称性(symmetric)：对于任何非 null 的引用值 x 和 y，当且仅当 <code>y.equals(x)</code> 返回 true 时，<code> x.equals(y)</code> 也必须返回 true </li>
<li>传递性(transitive)：对于任何非 null 的引用值 x、y和z，如果<code> x.equals(y)</code> 返回 true ，并且 <code>y.equals(z)</code> 也返回 true ，那么 <code>x.equals(z)</code> 也必须返回 true </li>
<li>一致性(consistent)：对于任何非 null 引用值 x 和 y，只要 equals 的比较操作在对象中所用的信息没有被修改，多次调用 <code>x.equals(y)</code> 就会一致地返回true, 或者一致地返回 false </li>
<li>对于任何非 null 的引用值 x , <code>x.equals (null)</code> 必须返回 false</li>
</ul>
<p>基于这些约定，有一些优秀的实践，在很多源码中都能找到这些实践：</p>
<ol>
<li><p>使用 &#x3D;&#x3D; 操作符检查“参数是否为这个对象的引用”。如果是，则返回 true</p>
<p>因为同一个对象的两个引用，肯定是相等的。如果比较操作代价较大，可以作为一种性能优化</p>
</li>
<li><p>使用 instanceof 操作符检查“参数是否为正确的类型” 如果不是，则返回 false</p>
</li>
<li><p>把参数转换成正确的类型</p>
</li>
<li><p>对于该类中的每个“关键”（ significant ）域，检查参数中的域是否与该对象中对应的域相匹配</p>
<p>对于基本数据类型的关键域，使用 &#x3D;&#x3D; 比较，对于引用数据类型，使用其 equals 比较</p>
</li>
</ol>
<p><font color="#16b777">使用IDEA，可以Ctrl+O，选择要比较的字段，快速实现equals方法，比较便利</font></p>
<h2 id="第11条、覆盖equals时总要覆盖hashCode"><a href="#第11条、覆盖equals时总要覆盖hashCode" class="headerlink" title="第11条、覆盖equals时总要覆盖hashCode"></a>第11条、覆盖equals时总要覆盖hashCode</h2><p>在每个覆盖了 equals 方法的类中，都必须覆盖 hashCode 方法。如果不这样做的话，就会违反 hashCode 的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，如HashMap、HashSet等</p>
<p>下面是 hashCode 约定的内容，摘自 Object 规范：</p>
<ul>
<li>在应用程序的执行期间，只要对象的 equals 方法的比较操作所用到的信息没有被修改，那么对同一个对象的多次调用， hashCode 方法都必须始终返回<strong>同一个值</strong>。在一个应用程序与另一个程序的执行过程中，执行 hashCode 方法所返回的值可以不一致</li>
<li>如果两个对象根据 equals(Object) 方法比较结果是相等的，那么调用这两个对象中的 hashCode 方法都必须产生同样的整数结果</li>
<li>如果两个对象根据 equals(Object) 方法比较是不相等的，那么调用这两个对象中的 hashCode 方法，则不一定要求 hashCode 方法必须产生不同的结果。但是，给不相等的对象产生截然不同的整数结果，有可能提高散列表（ hash table ）的性能</li>
</ul>
<p>而覆盖equals没有覆盖hashCode，违背了第二条规范，在使用如HashMap时，可能就会出问题：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个类，重写equals不重写hashcode</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name.equals(person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个字段值相同的对象，其实map中存放了2个，没有覆盖</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Person, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;J&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;J&quot;</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// &#123;Person&#123;name=&#x27;J&#x27;&#125;=2, Person&#123;name=&#x27;J&#x27;&#125;=1&#125;</span></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>至于如果重写hashCode方法，现在的工具非常多，不需要我们自己再去花心思实现。</p>
<p><font color="#16b777">使用IDEA，可以Ctrl+O，选择要比较的字段，快速实现equals方法。此外lombok的@Data注解也会自动生成hashCode方法</font></p>
<h2 id="第12条、始终要覆盖toString"><a href="#第12条、始终要覆盖toString" class="headerlink" title="第12条、始终要覆盖toString"></a>第12条、始终要覆盖toString</h2><p>还是用上面Person的例子，对比一下覆盖与不覆盖toString的区别：</p>
<div class="highlight-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">不覆盖：</span><br><span class="line">&#123;Person@7f31245a=2, Person@14ae5a5=1&#125;</span><br><span class="line">覆盖</span><br><span class="line">&#123;Person&#123;name=&#x27;J&#x27;&#125;=2, Person&#123;name=&#x27;J&#x27;&#125;=1&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以发现，如果不覆盖toString，哪怕日志中将该对象打印出来，也看不出任何信息跟没打印没有区别！</p>
<p>覆盖toString后就可以获取到信息，从而帮助我们快速定位问题。但也要注意量，最好只输出有必要的字段。</p>
<p>IDEA中，同样的Ctrl+O可以快速实现toString；Lombok的@Data注解也会自动生成toString方法</p>
<h2 id="第13条、谨慎地覆盖clone"><a href="#第13条、谨慎地覆盖clone" class="headerlink" title="第13条、谨慎地覆盖clone"></a>第13条、谨慎地覆盖clone</h2><p>覆盖clone方法，还需要实现cloneable接口，否则在调用clone时会抛异常</p>
<p>clone 方法的通用约定是非常弱的，下面是来自 Object 规范中的约定内容： </p>
<p>创建和返回该对象的一个拷贝，这个“拷贝”的精确含义取决于该对象的类。一般的含义是，对于任何对象 ，表达式 <code>x.clone() != x</code>  将会返回结果 true ，并且表达式 <code>x.clone().getClass() == x.getClass()</code>  将会返回结果 true</p>
<p>但这些都不是绝对的要求。虽然通常情况下，表达式 <code>x.clone() .equals(x)</code>  将会返回结果 true ，但是，这也不是个绝对的要求按照约定</p>
<p>这个方法返回的对象应该通过调用 super.clone 获得 如果类及其 超类（Object 除外）遵守这 约定，那么： x.clone() .getClass() &#x3D;&#x3D; x.getClass() . </p>
<p><font color="#16b777">书中提到，clone方法的约定非常弱。通常我们定义的业务类很少会覆盖clone方法，如果要提供拷贝，更多是选择拷贝构造器或拷贝工厂</font></p>
<h2 id="第14条、考虑实现Comparable接口"><a href="#第14条、考虑实现Comparable接口" class="headerlink" title="第14条、考虑实现Comparable接口"></a>第14条、考虑实现Comparable接口</h2><p>类实现了 Comparable 接口，就表明它的实例具有 内在的排序关系 (natural ordering)，一旦类实现了 Comparable 接口，它就可 以跟许多泛型算法（ generic algorithm ）以及 依赖于该接口的集合实现（ collection implementation ）进行协作。</p>
<p>如果我们定义的类有明确的大小关系，那么可以考虑实现Comparable接口</p>
<p>compareTo 方法的通用约定与 equals 方法的约定相似：</p>
<p>将这个对象与指定的对象进行比较，当该对象小于、等于或大于指定对象的时候， 分别返回一个负整数、零或者正整数。如果由于指定对象的类型而无法与该对象进行比较，则抛出 ClassCastException 异常。</p>
<ul>
<li>实现者必须确保所有的 都满足 sgn(x.compareTo(y)) &#x3D;&#x3D; -sgn(y.compareTo(x)) （这也暗示着，当且仅当y.compareTo (x) 抛出异常时，x.compareTo(y) 才必须抛出异常</li>
<li>实现者还必须确保这个比较关系是可传递的 x.compareTo(y) &gt; 0 &amp;&amp; y. compareTo(z) &gt; 0 暗示着 x.compareTo(z) &gt; 0</li>
<li>最后，实现者必须确保 x.compareTo(y) &#x3D;&#x3D; 0，暗示着所有的 z 都满足 sgn(x.compareTo(z)) &#x3D;&#x3D; sgn(y.compareTo(z))</li>
<li>强烈建议 (x.compareTo (y) &#x3D;&#x3D; 0) &#x3D;&#x3D; (x.equals(y))，但这并非绝对必要。一般说来，任何实现了 Comparable 接口的类，若违反了这个条件，都应该明确予以说明。推荐使用这样的说法：“注意：该类具有内在的排序功能，但是与 equals 不一致”<ul>
<li>即如果x、y相等，那么compareTo方法最好返回0</li>
</ul>
</li>
</ul>
<p>总而言之，每当实现一个对排序敏感的类时，都应该让这个类实现 Comparable 接口，以便其实例可以轻松地被分类、搜索，以及用在基于比较的集合中。每当在 compareTo 方法的实现中比较域值时，都要避免使用 &lt; 和 &gt; 操作符，而应该在装箱基本类型的类中使用静态的 compare 方法，或者在 Comparator 接口中使用比较器构造方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 装箱基本类型的compareTo方法，其实也是使用静态的 compare 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Integer anotherInteger)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> compare(<span class="built_in">this</span>.value, anotherInteger.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>初识Spring Cloud</title>
    <url>/2023/08/18/frame/springcloud/%E5%88%9D%E8%AF%86SpringCloud/</url>
    <content><![CDATA[<p>因为Spring Cloud <code>2022.0.4</code>版本需要依赖Spring Boot<code>3.0.9</code>，而目前更多使用的是Spring Boot 2.x版本</p>
<p>所以这里Spring Cloud版本选用<code>2021.0.8</code>，相对应的跟据官方文档，Spring Boot版本选用<code>2.6.15</code>，</p>
<div class="note success"><p>这里Spring Cloud版本号有个命名变更，之前是使用A-Z的伦敦地铁站命名如：<code>Hoxton.SR1</code>，而从2020年开始命名改为日期格式如：<code>2020.0.0-M1</code></p>
</div>

<h2 id="一、概念理解"><a href="#一、概念理解" class="headerlink" title="一、概念理解"></a>一、概念理解</h2><p>接触一个新东西就得先理解他的相关概念，然后才能找到门道</p>
<h3 id="1-1-什么是Spring-Cloud"><a href="#1-1-什么是Spring-Cloud" class="headerlink" title="1.1 什么是Spring Cloud"></a>1.1 什么是Spring Cloud</h3><p>首先通过Spring文档，可以看到Spring Cloud有很多子模块。如：Spring Cloud Alibaba、Spring Cloud Config、Spring Cloud Netflix等等。这些到底是什么？和Spring Cloud又有什么关系？</p>
<p>通过百度百科了解到：</p>
<p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>
<p>也就是说，这些子模块其实就是将优秀的开源框架结构Spring Boot形成的，这些子模块功能各异，并不是说要全部都用上</p>
<p>了解到这么多模块中Spring Cloud Netflix是最常见的一套，因此先从这个模块入手</p>
<h3 id="1-2-什么是Spring-Cloud-Netflix"><a href="#1-2-什么是Spring-Cloud-Netflix" class="headerlink" title="1.2 什么是Spring Cloud Netflix"></a>1.2 什么是Spring Cloud Netflix</h3><p>官方文档中描述到：</p>
<p>该项目通过自动配置和绑定到Spring环境和其他Spring编程模型习惯用法，为Spring Boot应用程序提供Netflix的OSS集成。通过一些简单的注释，您可以快速启用和配置应用程序中的常见模式，并使用久经考验的Netflix组件构建大型分布式系统。</p>
<p>在博客<a class="link"   href="https://blog.csdn.net/qq_44112474/article/details/109050543" >5.Spring Cloud快速入门-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中了解到：</p>
<p>Netflix：微服务大规模的应用，在技术上毫无保留的把一整套微服务架构核心技术栈开源了出来，叫做Netflix OSS</p>
<ul>
<li>Eureka：注册中心</li>
<li>Zuul：服务网关</li>
<li>Ribbon：负载均衡</li>
<li>Feign：服务调用</li>
<li>Hystix：熔断</li>
</ul>
<h3 id="1-3-踩坑了"><a href="#1-3-踩坑了" class="headerlink" title="1.3 踩坑了"></a>1.3 踩坑了</h3><p>最初的想法是通过官方文档来学习，但因为不了解cloud的结构和设计，看起来觉得很乱很吃力，然后就想着通过一些博客来先入门，结果第一步就踩到坑了。</p>
<p>就是文章的时效性，加上很多转载文</p>
<p>当feign开启熔断器时，博客上统一都是<code>feign.hystix.enabled=true</code>，结果开启后并没有用</p>
<p>查了才知道Spring Cloud2020后feign的jar中移除了hystix，需要额外引入，且开启配置也有变化</p>
<h2 id="二、eureka"><a href="#二、eureka" class="headerlink" title="二、eureka"></a>二、eureka</h2><p>eureka是一个注册中心，基于心跳机制动态维护一个可用服务列表，比如一个查询服务有哪些实例可用他的ip、端口是多少</p>
<p>eureka分为server和client，server就是记录注册信息的地方，而client就是注册者</p>
<h3 id="2-1-server"><a href="#2-1-server" class="headerlink" title="2.1 server"></a>2.1 server</h3><p>server使用起来很简单，只需要导入一个jar包：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>然后在Application.Java中添加注解<code>@EnableEurekaServer</code></p>
<h3 id="2-2-client"><a href="#2-2-client" class="headerlink" title="2.2 client"></a>2.2 client</h3><p>client同样简单，也只需要一个jar包</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>在client中随便写一个简单接口用作模拟服务提供者，在云服务器和本地分别启动一个实例来模拟集群，再去eureka控制台查看：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/eureka-client.jpg"
                      alt="eureka-client"
                ></p>
<p>可以看到服务已经注册到了eureka中，且有启动的两个实例</p>
<h3 id="2-3-配置"><a href="#2-3-配置" class="headerlink" title="2.3 配置"></a>2.3 配置</h3><p>eureka使用的重点在配置文件上，Spring Cloud Eureka为分布式系统外部化配置提供了服务器端和客户端的支持，它包括Eureka Server和Eureka Client两部分，因此Spring Cloud Eureka 配置项比较多。</p>
<p>通过application.yml配置，分为四大部分配置，但通常很多配置使用默认配置即可：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">	<span class="attr">instance:</span></span><br><span class="line">	<span class="attr">client:</span></span><br><span class="line">	<span class="attr">server:</span></span><br><span class="line">	<span class="attr">dashboard:</span></span><br></pre></td></tr></table></figure></div>

<p>具体可以参考：<a class="link"   href="https://blog.csdn.net/songjianlong/article/details/131315595" >Eureka配置文件详解-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="三、ribbon"><a href="#三、ribbon" class="headerlink" title="三、ribbon"></a>三、ribbon</h2><p>ribbon用作负载均衡，比如某个服务有3个实例，那么通过负载均衡可以将请求通过一定的策略分布到3个实例上。</p>
<p>负载均衡分为服务端和客户端：</p>
<pre class="mermaid">---
title: 客户端负载均衡
---
flowchart LR
    C1(["调用方(ribbon)"])
    E[eureka]
    subgraph S[服务方]
        S1[服务方1]
        S2[服务方2]
        S3[服务方3]
    end
    C1-->|1.访问|E
    E-->|2.返回服务列表|C1
    C1-->|3.负载策略选择一个服务|S</pre>

<pre class="mermaid">---
title: 服务端负载均衡
---
flowchart LR
    C1(["调用方1"])
    C2(["调用方2"])
    C3(["调用方3"])
    N[nginx]
    S1[服务方1]
    S2[服务方2]
    S3[服务方3]
    C1 & C2 & C3 --> N
    N --> S1 & S2 & S3</pre>

<p>其中ribbon就是客户端负载均衡，即由调用方处理负载均衡(和nginx的区别：<a class="link"   href="https://www.jianshu.com/p/49b3a22dbec9" >Ribbon与Nginx的区别 - 简书 (jianshu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)</p>
<p>优点是快速上手、成本较小，且相比于服务端统一的负载均衡也更灵活</p>
<p>缺点也很明显业务和负载这些运维属性都在程序中，不容易管理</p>
<h3 id="3-1-使用ribbon"><a href="#3-1-使用ribbon" class="headerlink" title="3.1 使用ribbon"></a>3.1 使用ribbon</h3><p>eureka-client包中已经包含了ribbon，因此如果使用了eureka就无需再导入jar包</p>
<p>这里使用<code>RestTemplate</code>来发起请求，只需要使用<code>@LoadBalanced</code>注解即可开启负载均衡</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-2-负载策略和配置"><a href="#3-2-负载策略和配置" class="headerlink" title="3.2 负载策略和配置"></a>3.2 负载策略和配置</h3><div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">springcloud-nacos-provider:</span> <span class="comment"># nacos中的服务id</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RoundRobinRule</span> <span class="comment">#设置负载均衡</span></span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>策略</th>
<th>说明</th>
<th>配置</th>
</tr>
</thead>
<tbody><tr>
<td>轮询策略</td>
<td>按照一定的顺序依次调用服务实例，如实例1、2、3</td>
<td><code>com.netflix.loadbalancer.RoundRobinRule</code></td>
</tr>
<tr>
<td>权重策略</td>
<td>根据每个服务提供者的响应时间分配一个权重，响应时间越长，权重越小，被选中的可能性也就越低</td>
<td><code>com.netflix.loadbalancer.WeightedResponseTimeRule</code></td>
</tr>
<tr>
<td>随机策略</td>
<td>从服务提供者的列表中随机选择一个服务实例</td>
<td><code>com.netflix.loadbalancer.RandomRule</code></td>
</tr>
<tr>
<td>最小连接数策略</td>
<td>选取连接数最小的⼀个服务实例。如果有相同的最小连接数，那么会调用轮询策略进行选取</td>
<td><code>com.netflix.loadbalancer.BestAvailableRule</code></td>
</tr>
<tr>
<td>重试策略</td>
<td>按照轮询策略来获取服务，如果获取的服务实例为 null 或已经失效，则在指定的时间之内不断地进行重试来获取服务，如果超过指定时间依然没获取到服务实例则返回 null</td>
<td><code>com.netflix.loadbalancer.RetryRule</code></td>
</tr>
<tr>
<td>可用性敏感策略</td>
<td>先过滤掉非健康的服务实例，然后再选择连接数较小的服务实例</td>
<td><code>com.netflix.loadbalancer.AvailabilityFilteringRule</code></td>
</tr>
<tr>
<td>区域敏感策略</td>
<td>根据服务所在区域(zone)的性能和服务的可用性来选择服务实例，在没有区域的环境下，该策略和轮询策略类似</td>
<td><code>com.netflix.loadbalancer.ZoneAvoidanceRule</code></td>
</tr>
</tbody></table>
<p>其中重试策略需要额外配置超时时间：</p>
<div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">2000</span> <span class="comment"># 请求连接的超时时间</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span> <span class="comment"># 请求处理的超时时间</span></span><br></pre></td></tr></table></figure></div>

<h2 id="四、feign"><a href="#四、feign" class="headerlink" title="四、feign"></a>四、feign</h2><p>Feign是Netflix开发的声明式、模板化的HTTP客户端，其灵感来自Retrofit、JAXRS-2.0以及WebSocket。Feign可帮助我们更加快捷、优雅地调用HTTP API</p>
<p>相比之前使用的restTemplate，其host、uri、param都是分开的，因此可读性更佳、也更容易维护</p>
<h3 id="4-1-使用feign"><a href="#4-1-使用feign" class="headerlink" title="4.1 使用feign"></a>4.1 使用feign</h3><p>首先需要引入jar包</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>然后编写一个feignclient接口</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处name就是eureka中的服务名，也就相当于是ip：port</span></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;user-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RecordFeignClient</span> &#123;</span><br><span class="line">    <span class="comment">// 此处是指服务方的uri，方法入参就是http请求的参数</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/record/&#123;rid&#125;&quot;)</span></span><br><span class="line">    Record <span class="title function_">getRecord</span><span class="params">(<span class="meta">@PathVariable(&quot;rid&quot;)</span> String rid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后将controller中的restTemplate替换成定义的feignClient，最后还需要在启动类中加上<code>@EnableFeignClients</code>注解</p>
<p>启动程序验证，调用正常，还集成了ribbon负载均衡</p>
<h3 id="4-2-配置"><a href="#4-2-配置" class="headerlink" title="4.2 配置"></a>4.2 配置</h3><p>feign的配置和其他配置类似，有Java Bean和yml配置文件两种形式。因为只是了解一下，并不是要使用feign，就不过多去看配置了</p>
<p>具体可以看：<a class="link"   href="https://blog.csdn.net/qi341500/article/details/129300783" >SpringCloud：Feign的使用及配置_feignclient配置_Poetry-Distance的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="五、Hystrix"><a href="#五、Hystrix" class="headerlink" title="五、Hystrix"></a>五、Hystrix</h2><p>Hystrix是一个实现了超时机制和断路器模式的工具类库，用于隔离访问远程系统、服务或者第三方库，防止级联失败，从而提升系统的可用性与容错性</p>
<p>也就是针对服务调用的一个断路器，当依赖服务出现问题时，切断链路减少本服务受到的影响。可以结合feign使用，也可以单独使用</p>
<p>结合feign使用或者单独使用都很简单，具体使用可以参考：<a class="link"   href="https://blog.csdn.net/qq_44112474/article/details/109094254" >Hystrix入门实战(完整版)_hystrix教程-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>注意新版本和文中有些出入</p>
<h2 id="六、Zuul"><a href="#六、Zuul" class="headerlink" title="六、Zuul"></a>六、Zuul</h2><p><a class="link"   href="https://blog.csdn.net/qq_44112474/article/details/109094775" >Zuul入门实战(完整版)-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="七、感受"><a href="#七、感受" class="headerlink" title="七、感受"></a>七、感受</h2><p>Spring Cloud Netflix算是一套比较完整的微服务框架，搭建也很快、成本很低，适合小型企业快速启动</p>
<p>至于性能上，没有能够验证的环境与流量，无法验证他和其他框架的差别，但至少使用上来说还算便捷</p>
]]></content>
      <categories>
        <category>spring</category>
        <category>spring cloud</category>
      </categories>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2023/03/09/JDK8/util/HashMap/</url>
    <content><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="一、字段"><a href="#一、字段" class="headerlink" title="一、字段"></a>一、字段</h2><h2 id="二、构造器"><a href="#二、构造器" class="headerlink" title="二、构造器"></a>二、构造器</h2><p>HashMap提供了4个构造器：</p>
<h3 id="2-1-无参构造"><a href="#2-1-无参构造" class="headerlink" title="2.1 无参构造"></a>2.1 无参构造</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以默认容量(16)和默认因子(0.75)创建一个空的&lt;tt&gt;HashMap&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-2-初始容量构造"><a href="#2-2-初始容量构造" class="headerlink" title="2.2 初始容量构造"></a>2.2 初始容量构造</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以指定容量(&#123;<span class="doctag">@code</span> initialCapacity&#125;)和默认因子(0.75)创建一个空的&lt;tt&gt;HashMap&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * 复用了指定初始容量和加载因子的构造</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity 指定容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果指定容量为负数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-初始容量和加载因子构造"><a href="#2-3-初始容量和加载因子构造" class="headerlink" title="2.3 初始容量和加载因子构造"></a>2.3 初始容量和加载因子构造</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以指定容量(&#123;<span class="doctag">@code</span> initialCapacity&#125;)和指定加载因子(&#123;<span class="doctag">@code</span> loadFactor&#125;)创建一个空的&lt;tt&gt;HashMap&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor		加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 初始容量为负数或者加载因子为非正数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 将给定的初始容量改为大于且最接近的2的幂次</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="问题1-2的幂次"><a href="#问题1-2的幂次" class="headerlink" title="&#x3D;&#x3D;问题1 2的幂次&#x3D;&#x3D;"></a>&#x3D;&#x3D;问题1 2的幂次&#x3D;&#x3D;</h4><blockquote>
<p><strong>Q：为什么HashMap的容量要设置为2的幂次？</strong></p>
</blockquote>
<h3 id="2-4-map构造"><a href="#2-4-map构造" class="headerlink" title="2.4 map构造"></a>2.4 map构造</h3><h2 id="三、内部类"><a href="#三、内部类" class="headerlink" title="三、内部类"></a>三、内部类</h2><h3 id="3-1-Map-Entry"><a href="#3-1-Map-Entry" class="headerlink" title="3.1 Map.Entry"></a>3.1 Map.Entry</h3><p>定义在Map接口中，是所有Map节点类的父接口，其中定义了一些行为方法，以及Java 1.8新增了一些<u><strong>使用函数式接口的排序方法</strong></u></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个map的实体(键值对)。&lt;tt&gt;Map.entrySet&lt;tt&gt;方法返回映射的集合视图，其元素属于此类。</span></span><br><span class="line"><span class="comment"> * 获取映射项引用的唯一方法是从这个集合视图的迭代器。</span></span><br><span class="line"><span class="comment"> * 这些&lt;tt&gt;Map.Entry&lt;/tt&gt;对象在迭代期间仅&lt;i&gt;有效；更正式地说，如果在迭代器返回条目之后修改了后备映射，则映射条目的行为是未定义的，</span></span><br><span class="line"><span class="comment"> * 除非通过对映射条目的&lt;tt&gt;setValue&lt;tt&gt;操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Map#entrySet()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Entry</span>&lt;K,V&gt; &#123;</span><br><span class="line">    K <span class="title function_">getKey</span><span class="params">()</span>;</span><br><span class="line">    V <span class="title function_">getValue</span><span class="params">()</span>;</span><br><span class="line">    V <span class="title function_">setValue</span><span class="params">(V value)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个按key升序排序的比较器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;返回的比较器是可序列化的且当比较到一个为null的key时抛出&#123;<span class="doctag">@link</span> NullPointerException&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  &lt;K&gt; map的继承了&#123;<span class="doctag">@link</span> Comparable&#125;key类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  &lt;V&gt; map的value类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个按key升序排序的比较器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Comparable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> K&gt;, V&gt; Comparator&lt;Entry&lt;K,V&gt;&gt; <span class="title function_">comparingByKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//Comparator&lt;Entry&lt;K, V&gt;&gt; &amp; Serializable表示同时强转类型成多个接口，多用于 lambda 表达式</span></span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">            (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个按value升序排序的比较器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;返回的比较器是可序列化的且当比较到一个为null的value时抛出&#123;<span class="doctag">@link</span> NullPointerException&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt; map的key类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; map的继承了&#123;<span class="doctag">@link</span> Comparable&#125;value类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个按value升序排序的比较器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Comparable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> V&gt;&gt; Comparator&lt;Entry&lt;K,V&gt;&gt; <span class="title function_">comparingByValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">            (c1, c2) -&gt; c1.getValue().compareTo(c2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个按key，以给定的&#123;<span class="doctag">@link</span> Comparator&#125;排序的比较器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;如果给定的比较器是可序列化的，则返回的比较器也是可序列化的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  &lt;K&gt; map的key类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  &lt;V&gt; map的value类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  cmp key的比较器&#123;<span class="doctag">@link</span> Comparator&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> key的比较器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Comparator&lt;Entry&lt;K, V&gt;&gt; <span class="title function_">comparingByKey</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; cmp)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(cmp);</span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">            (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个按value，以给定的&#123;<span class="doctag">@link</span> Comparator&#125;排序的比较器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;如果给定的比较器是可序列化的，则返回的比较器也是可序列化的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  &lt;K&gt; map的key类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  &lt;V&gt; map的value类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  cmp value的比较器&#123;<span class="doctag">@link</span> Comparator&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> value的比较器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Comparator&lt;Entry&lt;K, V&gt;&gt; <span class="title function_">comparingByValue</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> V&gt; cmp)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(cmp);</span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;Entry&lt;K, V&gt;&gt; &amp; Serializable)</span><br><span class="line">            (c1, c2) -&gt; cmp.compare(c1.getValue(), c2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="测试代码1-Map-Entry排序器"><a href="#测试代码1-Map-Entry排序器" class="headerlink" title="&#x3D;&#x3D;测试代码1 Map.Entry排序器&#x3D;&#x3D;"></a>&#x3D;&#x3D;测试代码1 Map.Entry排序器&#x3D;&#x3D;</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nodeTest</span><span class="params">()</span>&#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;8&quot;</span>,<span class="number">1</span>);map.put(<span class="string">&quot;4&quot;</span>,<span class="number">2</span>);map.put(<span class="string">&quot;7&quot;</span>,<span class="number">3</span>);map.put(<span class="string">&quot;5&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// [4=2, 5=4, 7=3, 8=1]</span></span><br><span class="line">    System.out.println(map.entrySet().stream().sorted(Map.Entry.comparingByKey()).collect(Collectors.toList()));</span><br><span class="line">    <span class="comment">// [8=1, 4=2, 7=3, 5=4]</span></span><br><span class="line">    System.out.println(map.entrySet().stream().sorted(Map.Entry.comparingByValue()).collect(Collectors.toList()));</span><br><span class="line">    <span class="comment">// [8=1, 7=3, 5=4, 4=2]</span></span><br><span class="line">    System.out.println(map.entrySet().stream().sorted(Map.Entry.comparingByKey((k1, k2) -&gt; -k1.compareTo(k2))).collect(Collectors.toList()));</span><br><span class="line">    <span class="comment">// [5=4, 7=3, 4=2, 8=1]</span></span><br><span class="line">    System.out.println(map.entrySet().stream().sorted(Map.Entry.comparingByValue((v1, v2) -&gt; -v1.compareTo(v2))).collect(Collectors.toList()));</span><br><span class="line">    map.put(<span class="string">&quot;9&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// java.lang.NullPointerException</span></span><br><span class="line">    System.out.println(map.entrySet().stream().sorted(Map.Entry.comparingByValue()).collect(Collectors.toList()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="备注1-强转"><a href="#备注1-强转" class="headerlink" title="&#x3D;&#x3D;备注1 强转&amp;&#x3D;&#x3D;"></a>&#x3D;&#x3D;备注1 强转&amp;&#x3D;&#x3D;</h4><blockquote>
<p>Comparator&lt;Entry&lt;K, V&gt;&gt; &amp; Serializable表示同时强转类型成多个接口，相当于返回的类实现了Comparator和Serializable接口，多用于 lambda 表达式</p>
</blockquote>
<h3 id="3-2-HashMap-Node"><a href="#3-2-HashMap-Node" class="headerlink" title="3.2 HashMap.Node"></a>3.2 HashMap.Node</h3><p>是HashMap中最基本的节点类，无复杂的逻辑，注意其中的next字段，即<u><strong>hash冲突时构建链表使用</strong></u></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本的哈希节点，大多数情况下使用此类。其他节点类如：TreeNode、LinkedHashMap中Node的子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Entry</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key的hash值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个节点，hash冲突时使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跟据hashCode方法和equals方法，Node类执行equals方法判断相等的条件时同一个对象或者key和value相等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Entry&lt;?,?&gt; e = (Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3-HashMap-TreeNode"><a href="#3-3-HashMap-TreeNode" class="headerlink" title="3.3 HashMap.TreeNode"></a>3.3 HashMap.TreeNode</h3><p>当哈希冲突导致的链表长度增长到8时，由链表转化为红黑树，其节点也会由<code>Node</code>转化为<code>TreeNode</code></p>
<h4 id="备注2-红黑树"><a href="#备注2-红黑树" class="headerlink" title="&#x3D;&#x3D;备注2 红黑树&#x3D;&#x3D;"></a>&#x3D;&#x3D;备注2 红黑树&#x3D;&#x3D;</h4><blockquote>
<p><a class="link"   href="https://www.jianshu.com/p/e136ec79235c" >30张图带你彻底理解红黑树 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<h2 id="四、公共方法逻辑"><a href="#四、公共方法逻辑" class="headerlink" title="四、公共方法逻辑"></a>四、公共方法逻辑</h2><h3 id="4-1-get操作"><a href="#4-1-get操作" class="headerlink" title="4.1 get操作"></a>4.1 get操作</h3><p>给定key，返回key映射的value，有两个实现get和getOrDefault。**<u>两者的区别是get如果没映射到会返回null，而getOrDefault则会返回给定的默认值。</u>**</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回给定key所映射的value或者当没有key映射的value时返回null</span></span><br><span class="line"><span class="comment"> * 可以使用containsKey方法区分是映射的value为null还是没有key映射value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回给定key所映射的value或者当没有key映射的value时返回defaultValue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>两个方法获取value的逻辑均是调用getNode方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现Map.get以及其他相关方法，get操作的具体逻辑实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> key所在节点，如果没有则为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">// table为空，table长度小于等于0，key的hash映射的位置为空，说明不存在该key的映射，直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查首节点，如果hash值相等且key相同或者hash值相等且key不为null且key值相同，则找到映射，返回首节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 否则检查后续节点，后续节点的存储形式跟据长度分为链表和红黑树</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 红黑树时，执行getTreeNode</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 链表时，遍历链表，按首节点的规则判断</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当节点类型为红黑树时，执行<code>getTreeNode</code>方法。该方法分为2步，第一步先查找跟节点，第二步使用跟节点查找指定节点即执行<code>find</code>方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先查找root节点，然后再执行find查找指定节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">getTreeNode</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>).find(h, k, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="问题2-先找root节点"><a href="#问题2-先找root节点" class="headerlink" title="&#x3D;&#x3D;问题2 先找root节点&#x3D;&#x3D;"></a>&#x3D;&#x3D;问题2 先找root节点&#x3D;&#x3D;</h4><blockquote>
<p>Q: 为什么在查找指定节点前，先查找root节点，那数组中的节点是什么？</p>
<p>A: 数组中的节点未必是跟节点，因为旋转操作可能会改变跟节点，因此需要先找到跟节点再执行查找动作</p>
</blockquote>
<h4 id="备注3-todo-put总结"><a href="#备注3-todo-put总结" class="headerlink" title="&#x3D;&#x3D;备注3 todo put总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;备注3 todo put总结&#x3D;&#x3D;</h4><blockquote>
<p>待后续读完TreeNode后来总结put的逻辑</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>集合</category>
      </categories>
  </entry>
  <entry>
    <title>ArrayList</title>
    <url>/2023/05/20/JDK8/util/ArrayList/</url>
    <content><![CDATA[<p>ArrayList是一个基于数组实现的动态数组，是Java集合框架中的一部分。它可以自动扩容来适应元素的增加，也支持随机访问、插入、删除等操作。与普通的数组相比，ArrayList更加灵活，可以在任意位置插入或删除元素，同时还提供了很多高级功能，如排序、查找等。ArrayList还可以存储任意类型的对象，包括基本类型的值，因此它被广泛应用于各种应用程序中，如Web应用、桌面应用等。总之，ArrayList是Java集合框架中的一个重要组件，可以方便地处理大量数据和对象。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/ArrayList.png"
                      alt="ArrayList"
                ></p>
<p>ArrayList直接实现了4个接口，继承了AbstractList抽象类</p>
<ul>
<li>List</li>
<li>Cloneable</li>
<li>RadomAccess</li>
<li>Serializable</li>
</ul>
<p>其中有3个是标记接口，标记接口是一个空接口，没有任何方法或字段。它只是作为一个标记，表示它的实现类具有一定的属性或特点。实现了该接口的类将被赋予特定的语义意义。</p>
<h2 id="一、RandomAccess"><a href="#一、RandomAccess" class="headerlink" title="一、RandomAccess"></a>一、RandomAccess</h2><p>RandomAccess标记接口表示实现此接口的类可以使用随机访问优化算法来访问集合中的元素，即可以通过索引直接访问集合中的元素，而不需要按顺序遍历整个集合，这对于大型集合而言能够提高访问效率。</p>
<p>例如，实现RandomAccess接口的List实例可以使用get()方法进行随机访问，而不像非RandomAccess的List实例需要使用迭代器或for循环逐个遍历获取元素。</p>
<h2 id="二、Cloneable"><a href="#二、Cloneable" class="headerlink" title="二、Cloneable"></a>二、Cloneable</h2><p>Cloneable标记接口表示类的实例是可克隆的，以向Object.clone()方法表示该方法创建该类实例副本是合法的</p>
<p>::: danger</p>
<h3 id="问题1-不实现Cloneable接口会怎么样"><a href="#问题1-不实现Cloneable接口会怎么样" class="headerlink" title="问题1 不实现Cloneable接口会怎么样"></a>问题1 不实现Cloneable接口会怎么样</h3><blockquote>
<p>Q：上述提到，Cloneable是表示clone方法是合法的，那么不实现Cloneable直接调clone会发生什么？</p>
</blockquote>
<p>如果调用了一个未实现Cloneable类的实例的clone方法，会抛出CloneNotSupportedException异常</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CloneObject</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>尝试调用clone：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cloneTest</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="type">CloneObject</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneObject</span>();</span><br><span class="line">    <span class="comment">// java.lang.CloneNotSupportedException: com.hkb.CloneObject</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">clone</span> <span class="operator">=</span> object.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而实现Cloneable接口后，再次调用，正常执行</p>
<p>此处还有一个点，Object的clone方法是protected级别，因此需要<font color="orange">重写</font>后才能调用到</p>
<p>:::</p>
<h2 id="三、Serializable"><a href="#三、Serializable" class="headerlink" title="三、Serializable"></a>三、Serializable</h2><p>Serializable标记接口表示了一个类可以被序列化，即可以将其对象的状态转换为字节流以便于存储或传输。如果一个类需要被序列化，就必须将其实现Serializable接口。实现Serializable接口的类可以被序列化，但是需要注意的是，该类的所有非transient成员变量都需要是可序列化的，否则会发生异常。</p>
<p><font color="orange">目前来说，Java的序列化已经不常用了，更多是使用Json等更简洁、易读的方式</font></p>
<h2 id="四、构造器"><a href="#四、构造器" class="headerlink" title="四、构造器"></a>四、构造器</h2><p>依照Collection注释上写的规范，集合必须提供两个构造：</p>
<ul>
<li>无参构造</li>
<li>同元素类型E(或者? extends E)的集合构造</li>
</ul>
<p><code>ArrayList</code>除了上述两个构造之外，还提供了初始容量的构造</p>
<ol>
<li>无参构造</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造初始容量为10的空列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>::: danger</p>
<h3 id="问题2-初始容量为10"><a href="#问题2-初始容量为10" class="headerlink" title="问题2 初始容量为10"></a>问题2 初始容量为10</h3><blockquote>
<p>Q：注释上说的初始容量为10，但为啥给的确是空数组？</p>
</blockquote>
<p>在<code>ensureCapacityInternal</code>方法中，当空集合add第一个元素时，会执行扩容操作(减少内存浪费的时间)，扩容为10</p>
<p>:::</p>
<ol start="2">
<li>指定初始容量构造</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造具有指定初始容量的空列表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity list的初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果指定的初始容量为负</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>指定集合构造</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按照集合的迭代器返回的顺序构造包含指定集合的元素的列表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 要将其元素放入此列表中的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(java.util.Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>::: danger</p>
<h3 id="问题3-toArray不是Object"><a href="#问题3-toArray不是Object" class="headerlink" title="问题3 toArray不是Object"></a>问题3 toArray不是Object</h3><blockquote>
<p>Q：在ArrayList的集合构造中，有判断toArray方法返回的数组是否是Object[]，注释中提及可能会错误的返回非Object[]，那么具体是哪些场景？</p>
</blockquote>
<p>:::</p>
<h2 id="五、ArrayList字段解读"><a href="#五、ArrayList字段解读" class="headerlink" title="五、ArrayList字段解读"></a>五、ArrayList字段解读</h2><ol>
<li>和初始化相关的3个字段</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始容量10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共享的空数组实例，用于空实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共享的空数组实例，用于默认容量的空实例</span></span><br><span class="line"><span class="comment"> * 我们将其与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时要扩容多少</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>元素存储数组</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储数组列表元素的数组缓冲区，ArrayList的容量就是该数组的长度</span></span><br><span class="line"><span class="comment"> * 所有空且elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA的ArrayList，</span></span><br><span class="line"><span class="comment"> * 会在第一个元素插入时扩容成DEFAULT_CAPACITY</span></span><br><span class="line"><span class="comment"> * 非private，以简化近类访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>元素存储数量</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组列表的大小（它包含的元素数）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>最大数组容量，<a class="link"   href="https://www.huangkebing.com/blogs/JDK8/util/Collection&AbstractCollection.html#%E9%97%AE%E9%A2%982-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%81%E5%87%8F8" >Collection 问题2-为什么要减8 | technology-inn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的数组的最大大小，某些 VM 会在数组中保留一些标头字。尝试分配更大的阵列可能会导致OutOfMemoryError：请求的数组大小超过 VM 限制</span></span><br><span class="line"><span class="comment"> * Collection中有介绍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure></div>

<p>::: danger</p>
<h3 id="问题4-两个空数组"><a href="#问题4-两个空数组" class="headerlink" title="问题4 两个空数组"></a>问题4 两个空数组</h3><blockquote>
<p>Q：EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA，为什么要设计两个空数组？</p>
</blockquote>
<p>DEFAULTCAPACITY_EMPTY_ELEMENTDATA用于表示通过无参构造创建的容量为10的空集合</p>
<p>EMPTY_ELEMENTDATA用于表示容量为0的空集合</p>
<p>设计两个空数组用来区分两种不同情况的空集合</p>
<p>:::</p>
<h2 id="六、-元素数量方法"><a href="#六、-元素数量方法" class="headerlink" title="六、 元素数量方法"></a>六、 元素数量方法</h2><p>元素数量相关的<code>size</code>和<code>isEmpty</code></p>
<ol>
<li>size 获取元素数量，即size字段</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回size，即集合中的元素个数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>isEmpty 判断元素是否为空，即size是否为0</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果集合中不包含元素，即size为0，返回true</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true/false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="七、下标查询方法"><a href="#七、下标查询方法" class="headerlink" title="七、下标查询方法"></a>七、下标查询方法</h2><p>通过元素查询下标的方法<code>indexOf</code>和<code>lastIndexOf</code>以及基于indexOf实现的<code>contains</code></p>
<ol>
<li>indexOf 查询指定元素的第一次出现下标，基于遍历</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此列表中指定元素第一次出现的索引满足条件：(o==null ? get(i)==null : o.equals(get(i)))</span></span><br><span class="line"><span class="comment"> * 如果此列表中不包含该元素，则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>lastIndexOf 查询指定元素的最后一次出现下标，基于后序遍历</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此列表中指定元素最后一次出现的索引满足条件：(o==null ? get(i)==null : o.equals(get(i)))</span></span><br><span class="line"><span class="comment"> * 如果此列表中不包含该元素，则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>contains 查询元素是否在集合中，基于indexOf</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断集合中是否包含指定的元素o</span></span><br><span class="line"><span class="comment"> * 通过indexOf实现，如果indexOf的结果为-1则&gt;=0不满足为false。反之为true</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要测试其在此列表中是否存在的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true/false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="八、元素拷贝方法"><a href="#八、元素拷贝方法" class="headerlink" title="八、元素拷贝方法"></a>八、元素拷贝方法</h2><p><code>toArray</code>和<code>clone</code>，注意均是浅拷贝</p>
<ol>
<li>toArray，无参版本，返回Object[]</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个数组，该数组按正确的顺序（从第一个元素到最后一个元素）包含此列表中的所有元素</span></span><br><span class="line"><span class="comment"> * 返回的数组将是“安全的”，此方法必须分配一个新数组</span></span><br><span class="line"><span class="comment"> * 因此，调用方可以自由修改返回的数组(这里的修改如果指的是不可变对象的替换，如果修改了可变对象的值依旧会影响原集合)</span></span><br><span class="line"><span class="comment"> * 此方法充当基于数组和基于集合的 API 之间的桥梁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 以正确顺序包含此列表中所有元素的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>toArray，有参版本</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个数组，其中包含此列表中所有元素的正确顺序（从第一个到最后一个元素）;返回数组的运行时类型是指定数组的运行时类型。</span></span><br><span class="line"><span class="comment"> * 如果列表适合指定的数组，则在其中返回该列表。否则，将分配一个具有指定数组的运行时类型和此列表大小的新数组。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果列表适合指定的数组，并留出空间（即数组的元素比列表多），则紧跟在集合末尾之后的数组中的元素设置为null。</span></span><br><span class="line"><span class="comment"> * 仅当调用方知道列表不包含任何 null 元素时，这在确定列表的长度时才很有用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 要存储列表元素的数组（如果它足够大）;否则，将为此目的分配相同运行时类型的新数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含列表元素的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ArrayStoreException 如果指定数组的运行时类型不是此列表中每个元素的运行时类型的超类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的数组为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// 数量不足存放时，创建一个运行时类型的新数组</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    <span class="comment">// 数量足够时，直接使用原数组</span></span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="comment">// 有多的元素时，最后一个集合元素之后的元素置为null</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>clone</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此 ArrayList 实例的浅拷贝副本。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 此ArrayList的一个拷贝副本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>::: tip</p>
<h3 id="备注1-集合的拷贝注意点"><a href="#备注1-集合的拷贝注意点" class="headerlink" title="备注1 集合的拷贝注意点"></a>备注1 集合的拷贝注意点</h3><p>ArrayList中的clone、toArray，均是浅拷贝，即集合里的对象实例是同一个！</p>
<p><font color="#16b777">因此如果集合中存放的是String、Integer等不可变对象，那么是没问题的，</font></p>
<p><font color="#dd0000">但如果存放了可变对象并修改了可变对象中的字段，那么原集合、集合副本(clone)、集合元素数组(toArray)中的实例均会受影响；替换对象实例则只会影响替换的容器</font></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cloneAndToArrayTest</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Inner&gt; inners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    inners.add(<span class="keyword">new</span> <span class="title class_">Inner</span>(<span class="number">1</span>));</span><br><span class="line">    Object[] objects = inners.toArray();</span><br><span class="line">    <span class="comment">// 原先的内容:[Inner&#123;number=1&#125;]</span></span><br><span class="line">    <span class="comment">// 原先的内容:[Inner&#123;number=1&#125;]</span></span><br><span class="line">    System.out.println(<span class="string">&quot;原先的内容:&quot;</span> + inners);</span><br><span class="line">    System.out.println(<span class="string">&quot;原先的内容:&quot;</span> + Arrays.toString(objects));</span><br><span class="line">    ArrayList&lt;Inner&gt; clone = (ArrayList&lt;Inner&gt;) inners.clone();</span><br><span class="line">    <span class="comment">// 修改clone副本的中对象实例的字段</span></span><br><span class="line">    <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> clone.get(<span class="number">0</span>);</span><br><span class="line">    inner.setNumber(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 变更后内容:[Inner&#123;number=0&#125;]</span></span><br><span class="line">    <span class="comment">// 变更后内容:[Inner&#123;number=0&#125;]</span></span><br><span class="line">    System.out.println(<span class="string">&quot;变更后内容:&quot;</span> + inners);</span><br><span class="line">    System.out.println(<span class="string">&quot;变更后内容:&quot;</span> + Arrays.toString(objects));</span><br><span class="line">    <span class="comment">// 修改clone副本中的对象实例</span></span><br><span class="line">    clone.remove(inner);</span><br><span class="line">    clone.add(<span class="keyword">new</span> <span class="title class_">Inner</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 变更后内容:[Inner&#123;number=0&#125;]</span></span><br><span class="line">    <span class="comment">// 变更后内容:[Inner&#123;number=0&#125;]</span></span><br><span class="line">    System.out.println(<span class="string">&quot;变更后内容:&quot;</span> + inners);</span><br><span class="line">    System.out.println(<span class="string">&quot;变更后内容:&quot;</span> + Arrays.toString(objects));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>:::</p>
<h2 id="九、容量调整方法"><a href="#九、容量调整方法" class="headerlink" title="九、容量调整方法"></a>九、容量调整方法</h2><p>在源码中发现了两个冷门的方法，一个用于缩容<code>trimToSize</code>另一个用于扩容<code>ensureCapacity</code>。之所以冷门，是因为我们经常会用List去接收ArrayList实例，而这两个方法并没有在List中定义，所以我们使用方法时，idea的方法提示框不会有这两个方法！</p>
<ol>
<li>缩容方法trimToSize()，作用是把数组的容量缩小为实际数量size。实际业务中，为了避免频繁查询数据库，经常会把数据库中的数据缓存到内存中，通过调用此方法可以节约出一些内存，但我觉得意义不大</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将此ArrayList实例的容量修剪为列表的当前大小。应用程序可以使用此操作来最小化ArrayList 实例的存储。</span></span><br><span class="line"><span class="comment"> * 能想到的场景，存放一部分数据在List中用做应用缓存，可以在数据加载后执行一下trimToSize()节约部分内存</span></span><br><span class="line"><span class="comment"> * 如果是经常修改的List，则没有意义调用此方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>扩容方法ensureCapacity()，需要提供一个初始值，类似的可以通过指定初始容量的构造器实现，相比之下感觉构造器的方式更直白一些</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如有必要，增加此ArrayList实例的容量，以确保它至少可以容纳最小容量参数指定的元素数</span></span><br><span class="line"><span class="comment"> * 个人认为，指定初始容量的构造器可以实现类似的功能</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 所需的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是默认空表，则minExpand为10；否则为0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) ? <span class="number">0</span> : DEFAULT_CAPACITY;</span><br><span class="line">    <span class="comment">// 执行最小容量&gt;minExpand执行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="十、set-get方法"><a href="#十、set-get方法" class="headerlink" title="十、set&amp;get方法"></a>十、set&amp;get方法</h2><p><code>set</code>和<code>get</code>方法算是一对方法，set是修改指定下标的元素，get是获取指定下标的元素</p>
<ol>
<li>set 将指定下标index替换为指定元素element，并返回原值</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将此列表中指定位置的元素替换为指定的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要替换的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要存储在指定位置的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 先前位于指定位置的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 数组下标越界移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>rangeCheck()在设计上比较巧妙。因为数组通过下标访问时如果下标为负数，会抛出异常，所以无需判断下标为负的情况</p>
<p><font color="#16b777">在日常开发中，很多时间都在写if，但经常能看到很多没必要的if，或者换个思路就能简化的if，让代码更简洁</font></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查给定索引是否在范围内。如果不是，则引发相应的运行时异常</span></span><br><span class="line"><span class="comment"> * 需要校验和size的大小关系，因为数组的容量是大于size的，当index&gt;=size但小于数组长度时并不会抛出异常，但不符合预期</span></span><br><span class="line"><span class="comment"> * 不检查索引是否为负数：它总是在数组访问之前使用，如果索引为负数，则会抛出 ArrayIndexOutOfBoundsException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>get 获取指定下标的元素</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  index 要返回的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 此列表中指定位置的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 数组下标越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="十一、add方法"><a href="#十一、add方法" class="headerlink" title="十一、add方法"></a>十一、add方法</h2><p><code>add</code>有两个版本:</p>
<ul>
<li><p>一个是插入到数组末尾的，只需要关注是否需要扩容，插入直接通过下标插入到尾部</p>
</li>
<li><p>另一个是插入到指定位置，需要校验下标以及是否需要扩容，通过System.arraycopy这一native方法实现将数组元素往后移动一位</p>
</li>
</ul>
<p>两者虽然都是新增元素，但性能云泥之别。因为数组的特性，往数组中间加元素需要涉及数组位移。所以<font color="#dd0000">如果没有特殊需求都一律使用插到数组末尾的版本，如果一定要插到中间可以考虑用LinkedList</font></p>
<ol>
<li>add 追加元素到末尾版本</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的元素追加到此列表的末尾</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要附加到此列表的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true，如果添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查容量，不管是否触发扩容，都会影响modCount</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>add 插入到指定位置版本</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此列表中的指定位置插入指定的元素。将当前位于该位置的元素（如果有）和任何后续元素向右移动</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要在其中插入指定元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 数组下标越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 检查容量，不管是否触发扩容，都会影响modCount</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 入参的含义为：原数组、原数组的起始位置、目标数组、目标数组的起始位置、长度</span></span><br><span class="line">    <span class="comment">// 此处即将下标为[index,size-1]的元素往后移动一个位置</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>非常清晰的看到，插入到指定位置的版本多了一次<code>System.arraycopy</code>操作</p>
<p>然后看下add版的下标校验的方法<code>rangeCheckForAdd</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * add和addAll使用的 rangeCheck 版本</span></span><br><span class="line"><span class="comment"> * 此处条件是index&gt;size,因为涉及要新增，会在原集合上多一个元素</span></span><br><span class="line"><span class="comment"> * 需要校验负数是因为如果不校验，可能会引起不必要的扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>::: danger</p>
<h3 id="问题5-rangeCheck和rangeCheckForAdd"><a href="#问题5-rangeCheck和rangeCheckForAdd" class="headerlink" title="问题5 rangeCheck和rangeCheckForAdd"></a>问题5 rangeCheck和rangeCheckForAdd</h3><blockquote>
<p>Q：rangeCheck和rangeCheckForAdd有什么区别？为什么rangeCheckForAdd需要对负数做校验？为什么需要写两个版本的下标校验？</p>
</blockquote>
<p>rangraneckForAdd只用于add或者addAll方法，rangraneck用于除add和addAll外的其他方法</p>
<p>此外还有判断条件不同：</p>
<ul>
<li>rangeCheck是index&gt;&#x3D;size，只包含现有的元素且未对负数做校验</li>
<li>rangeCheckForAdd是index&gt;size，因为是add系列方法，多判断了一位，且有负数校验</li>
</ul>
<p>rangeCheckForAdd做负数校验，起初怀疑是因为要调用System.arraycopy()，负数会有问题，故写了测试代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    System.arraycopy(ints, -<span class="number">5</span>, ints, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>发现同样会抛出异常和elementData[-5]一样，所以不是该方法的问题。</p>
<p>后来发现，如果不做负数校验，那么通过rangeCheck后，add方法会执行扩容那会就会有一定概率发生扩容，随后执行System.arraycopy()报错，也就是说无效扩容了(按照空参构造的设计，存在一定时间内存的浪费)</p>
<p>至于为什么要写两个版本的校验，是应用场景不同的原因。add方法涉及到扩容，而其他的方法不会</p>
<p>:::</p>
<h2 id="十二、扩容机制"><a href="#十二、扩容机制" class="headerlink" title="十二、扩容机制"></a>十二、扩容机制</h2><p>我们都知道ArrayList会扩容成1.5倍，那么到底是如何实现的？</p>
<p>这里只介绍<code>add</code>方法导致的自动扩容，除add外第九节中提到的<code>ensureCapacity</code>方法会能触发扩容，但扩容方法是同一个</p>
<ol>
<li>ensureCapacityInternal</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// minCapacity为所需的最小容量，如目前size=9，通过add方法新增一个元素，那么minCapacity会给10</span></span><br><span class="line"><span class="comment">// 首先检查了数组是否是DEFAULTCAPACITY_EMPTY_ELEMENTDATA实例，即通过空参构造创建的，若是则minCapacity最小值为10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是空参构造创建的集合，minCapacity最小为10</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>ensureExplicitCapacity</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modCount自增，也就是说不管有没有执行扩容，均会影响modCount的值</span></span><br><span class="line"><span class="comment">// 如果minCapacity大于当前数组的长度，则执行扩容操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>grow</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加容量以确保它至少可以容纳最小容量参数指定的元素数</span></span><br><span class="line"><span class="comment"> * 扩容时，通常情况下新容量=旧容量的1.5倍；但当新容量小于minCapacity时会扩容为minCapacity；当新容量大于MAX_ARRAY_SIZE只扩容到最大值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 所需的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 新容量是老容量的1.5倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 新容量小于minCapacity，oldCapacity=0，或者minCapacity通过方法指定的一个较大值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 新容量大于MAX_ARRAY_SIZE，只扩容到最大值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 执行扩容</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>hugeCapacity</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩容后容量大于MAX_ARRAY_SIZE，执行容量上限兼容</span></span><br><span class="line"><span class="comment">// 关于ArrayList容量最大值，其实还是Integer.MAX_VALUE</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">// 如果minCapacity即最小需求容量大于MAX_ARRAY_SIZE，则扩容为Integer最大值，否则为Integer最大值-8</span></span><br><span class="line">    <span class="comment">// 为了兼容部分vm，但如果MAX_ARRAY_SIZE不满足了只能扩容到Integer最大值</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="十三、remove-clear方法"><a href="#十三、remove-clear方法" class="headerlink" title="十三、remove&amp;clear方法"></a>十三、remove&amp;clear方法</h2><p><code>remove</code>有两个版本，分别是移除指定下标的元素，和移除给定的元素；<code>clear</code>即清空集合</p>
<p>remove绝大部分情况会涉及数组位移，除非你总是移除最后一个。<font color="#16b777">所以如果使用ArrayList，尽可能少的执行remove，如果要remove多个元素，可以批量移除(removeAll或stream)</font></p>
<ol>
<li>remove 移除指定下标的元素</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除此列表中指定位置的元素。将任何后续元素向左移动（从其索引中减去一个）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要删除的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 从列表中删除的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 数组下标越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 排除等于0的情况，等于0即移除最后一个元素，无需移动数组</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    <span class="comment">// 最后一个元素置为null</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>remove 移除给定元素，先找到指定元素的下标，然后通过下标来移除</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从此列表中删除指定元素的第一个匹配项（如果存在）。如果列表不包含该元素，则它保持不变。</span></span><br><span class="line"><span class="comment"> * 更正式地说，删除索引为 i 最小的元素，使得(o==null?get(i)==null:o.equals(get(i)))（如果存在这样的元素）。</span></span><br><span class="line"><span class="comment"> * 如果此列表包含指定的元素（或者等效地，如果此列表由于调用而更改），则返回 true。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要从此列表中删除的元素（如果存在）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此列表包含指定的元素，则为 true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// 跟据null和非null分成两个查找逻辑，查找到目标元素的index，然后执行类似下标移除的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>移除逻辑和下标remove类似，有两个区别：没有下标检查因为下标是通过遍历产生的必定不会越界，不需要返回旧值</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳过边界检查且不返回已删除值的专用删除方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>clear 清空方法</li>
</ol>
<p>这个方法在Collection接口中就有定义，抽象实现类中是通过迭代器来实现的。但到了ArrayList，因为支持了随机访问，完全可以通过下标来实现</p>
<p>但是我们可以发现，clear之后，集合中的元素都变为null了，但<font color="#dd0000">内部数组的长度并没有发生变化</font>！</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从此列表中删除所有元素。此调用返回后，该列表将为空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="literal">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="十四、addAll方法"><a href="#十四、addAll方法" class="headerlink" title="十四、addAll方法"></a>十四、addAll方法</h2><p><code>addAll</code>也分为两个版本，插入到尾部和插入到指定位置，同样的尽量使用插入到尾部版本</p>
<ol>
<li>addAll 尾部追加版本</li>
</ol>
<p>先转成数组，然后扩容，最后将数组添加到尾部，修正size</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合中的所有元素追加到此列表的末尾，顺序与指定集合的迭代器返回这些元素的顺序相同</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 包含要添加到此列表的元素的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此列表因调用而更改，则为 true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(java.util.Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>::: danger</p>
<h3 id="问题6-为什么不判空"><a href="#问题6-为什么不判空" class="headerlink" title="问题6 为什么不判空"></a>问题6 为什么不判空</h3><blockquote>
<p>Q：为什么不对集合c先做判空呢？如果集合c为空，那么扩容判断、数组拷贝不是白执行了吗？</p>
</blockquote>
<p>如果集合c为空，扩容判断、数组拷贝确实是白执行了。而在JDK14中，这个方法有优化：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> (numNew &gt; (elementData = <span class="built_in">this</span>.elementData).length - (s = size))</span><br><span class="line">        elementData = grow(s + numNew);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, s, numNew);</span><br><span class="line">    size = s + numNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是我们是不会去随意升级JDK版本的，所以<font color="#dd0000">当我们执行addAll时，如果不能确保入参集合一定不为空的，最好加上空校验</font></p>
<p>:::</p>
<ol start="2">
<li>addAll 插入到指定位置版本</li>
</ol>
<p>多了下标校验和移动原数组两个步骤，从性能角度看<font color="#dd0000">能插入到尾部就不要插到指定位置</font></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从指定位置开始，将指定集合中的所有元素插入到此列表中</span></span><br><span class="line"><span class="comment"> * 将当前位于该位置的元素（如果有）和任何后续元素向右移动（增加其索引）</span></span><br><span class="line"><span class="comment"> * 新元素将按照指定集合的迭代器返回的顺序显示在列表中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 插入指定集合中的第一个元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 包含要添加到此列表的元素的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此列表因调用而更改，则为 true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 数组小标越界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, java.util.Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);</span><br><span class="line">    <span class="comment">// 先移动原数组，腾出位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew, numMoved);</span><br><span class="line">    <span class="comment">// 拷贝数据</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="十五、removeAll-retainAll方法"><a href="#十五、removeAll-retainAll方法" class="headerlink" title="十五、removeAll&amp;retainAll方法"></a>十五、removeAll&amp;retainAll方法</h2><p><code>removeAll</code>和<code>retainAll</code>，可以说是一对方法，实现逻辑一致，均是先判空，随后执行batchRemove，唯一区别是方法的第二个入参相反，因此两个方法逻辑也是相反的</p>
<ol>
<li>removeAll</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从此列表中删除指定集合中包含的所有元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 包含要从此列表中删除的元素的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表由于调用而更改</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException 如果此列表的元素的类与指定的集合不兼容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果此列表包含 null 元素，并且指定的集合不允许 null 元素，或者如果指定的集合为 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.util.Collection#contains(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(java.util.Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>retainAll</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 仅保留此列表中包含在指定集合中的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 包含要保留在此列表中的元素的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果此列表由于调用而更改</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException 如果此列表的元素的类与指定的集合不兼容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果此列表包含 null 元素，并且指定的集合不允许 null 元素，或者如果指定的集合为 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.util.Collection#contains(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(java.util.Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>直接来看batchRemove，注意到是循环调用集合c的contains方法，即双循环，因此<font color="#1e9fff">能不用就不用，如果非要用，建议集合c可以传Set</font></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">batchRemove</span><span class="params">(java.util.Collection&lt;?&gt; c, <span class="type">boolean</span> complement)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="comment">// r代表当前遍历到下标，w表示处理后数组当前的元素下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="comment">// 跟据传入条件判断是否保留，留下的元素从头开始保存</span></span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 保持与 AbstractCollection 的行为兼容性，即使 c.contains()抛出异常</span></span><br><span class="line">        <span class="comment">// 如果中途抛出异常了，则没有遍历完，将没有遍历的部分拷贝到处理后的元素后面，并修正w</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r, elementData, w, size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果w != size,说明有元素被去掉了，将空余位置置为null，修正modCount、size和变更标志</span></span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="literal">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="十六、Java8新增方法"><a href="#十六、Java8新增方法" class="headerlink" title="十六、Java8新增方法"></a>十六、Java8新增方法</h2><p>Java8新增的方法均与函数式接口有关，此外这些方法都对modCount做了校验</p>
<p>有<code>forEach</code>、<code>replaceAll</code>、<code>sort</code>和<code>removeIf</code></p>
<p>首先来看3个在实现上类似的，<code>forEach</code>、<code>replaceAll</code>和<code>sort</code></p>
<p>forEach的入参是Consumer，replaceAll的入参是UnaryOperator，sort的入参是Comparator，均是函数式接口</p>
<ol>
<li>forEach</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">final</span> E[] elementData = (E[]) <span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="built_in">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        action.accept(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>replaceAll</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(operator);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="built_in">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        elementData[i] = operator.apply((E) elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>sort</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里注意，forEach没有执行modCount++</p>
<p>因为forEach即不会导致集合顺序变化，也不会修改集合中的元素(指换一个元素，修改可变对象的字段依旧是可以的)</p>
<p>而replaceAll会修改集合中的元素，sort会修改集合元素的顺序。</p>
<p>最后是removeIf，分为两部分执行，先找要移除的元素然后统一移除，类似的stream.filter可以实现该功能</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    <span class="comment">// 确定要删除哪些元素 在此阶段从过滤器Predicate引发的任何异常将使集合保持不变</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">removeCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">BitSet</span> <span class="variable">removeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>(size);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="built_in">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> (E) elementData[i];</span><br><span class="line">        <span class="keyword">if</span> (filter.test(element)) &#123;</span><br><span class="line">            removeSet.set(i);</span><br><span class="line">            removeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将剩余元素移到已删除元素留下的空间上</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">anyToRemove</span> <span class="operator">=</span> removeCount &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (anyToRemove) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">newSize</span> <span class="operator">=</span> size - removeCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;</span><br><span class="line">            i = removeSet.nextClearBit(i);</span><br><span class="line">            elementData[j] = elementData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=newSize; k &lt; size; k++) &#123;</span><br><span class="line">            elementData[k] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.size = newSize;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> anyToRemove;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="十七、Itr"><a href="#十七、Itr" class="headerlink" title="十七、Itr"></a>十七、Itr</h2><p>ArrayList的Iterator</p>
<p>首先看定义的字段，相当于存了两个下标指针</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要返回的下一个元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> cursor;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回的最后一个元素的索引;-1为默认值，代表还没有元素返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建迭代器时的modCount快照</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Java</category>
        <category>集合</category>
      </categories>
  </entry>
  <entry>
    <title>Apache Commons Lang</title>
    <url>/2023/04/26/util/apache/commons-lang3/</url>
    <content><![CDATA[<h2 id="一、Apache-Commons简介"><a href="#一、Apache-Commons简介" class="headerlink" title="一、Apache Commons简介"></a>一、Apache Commons简介</h2><p>官方文档：<a class="link"   href="https://commons.apache.org/" >Apache Commons <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><code>Apache Commons</code>是Apache软件基金会的项目，Commons的目的是提供开源的、可重用的Java组件</p>
<p><code>Apache Commons</code>项目由三部分组成：</p>
<h3 id="1-1-The-Commons-Proper"><a href="#1-1-The-Commons-Proper" class="headerlink" title="1.1 The Commons Proper"></a>1.1 The Commons Proper</h3><p>The Commons Proper提供非常多可重用的、稳定的Java组件库。</p>
<p>其子项目如下：</p>
<table>
<thead>
<tr>
<th>包名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>BCEL</td>
<td>字节码工程库——分析、创建和操作 Java 类字节码工程库——分析、创建和操作 Java 类文文件BeanUtils围绕 Java 反射和内省 API 的易于使用的包装器</td>
</tr>
<tr>
<td>BeanUtils</td>
<td>围绕 Java 反射和内省 API 的易于使用的包装器</td>
</tr>
<tr>
<td>CLI</td>
<td>命令行参数解析器。Codec通用编码&#x2F;解码算法（例如语音、base64、URL）</td>
</tr>
<tr>
<td>Collections</td>
<td>扩展或增强 Java 集合框架</td>
</tr>
<tr>
<td>Compress</td>
<td>定义用于处理 tar、zip 和 bzip2 文件的 API</td>
</tr>
<tr>
<td>Configuration</td>
<td>读取各种格式的配置&#x2F;首选项文件</td>
</tr>
<tr>
<td>Crypto</td>
<td>使用 AES-NI 包装 Openssl 或 JCE  算法实现优化的加密库</td>
</tr>
<tr>
<td>CSV</td>
<td>用于读写逗号分隔值文件的组件</td>
</tr>
<tr>
<td>Daemon</td>
<td>unix-daemon-like java 代码的替代调用机制</td>
</tr>
<tr>
<td>DBCP</td>
<td>数据库连接池服务</td>
</tr>
<tr>
<td>DbUtils</td>
<td>JDBC 帮助程序库</td>
</tr>
<tr>
<td>Email</td>
<td>用于从 Java 发送电子邮件的库</td>
</tr>
<tr>
<td>Exec</td>
<td>用于处理 Java 中外部进程执行和环境管理的 API</td>
</tr>
<tr>
<td>FileUpload</td>
<td>servlet 和 Web 应用程序的文件上传功能</td>
</tr>
<tr>
<td>Geometry</td>
<td>空间和坐标</td>
</tr>
<tr>
<td>Imaging</td>
<td>纯 Java 图像库</td>
</tr>
<tr>
<td>IO</td>
<td>I&#x2F;O 实用程序的集合</td>
</tr>
<tr>
<td>JCI</td>
<td>Java 编译器接口JCSJava缓存系统Jelly基于 XML 的脚本和处理引擎</td>
</tr>
<tr>
<td>Jexl</td>
<td>表达式语言，它扩展了 JSTL 的表达式语言</td>
</tr>
<tr>
<td>Lang</td>
<td>为 java.lang 中的类提供额外的功能</td>
</tr>
<tr>
<td>Logging</td>
<td>包装各种日志 API 实现</td>
</tr>
<tr>
<td>Math</td>
<td>轻量级、自包含的数学和统计组件</td>
</tr>
<tr>
<td>Net</td>
<td>网络实用程序和协议实现的集合</td>
</tr>
<tr>
<td>Numbers</td>
<td>数字类型（复数、四元数、分数）和实用程序（数组、组合）</td>
</tr>
<tr>
<td>Pool</td>
<td>通用对象池组件</td>
</tr>
<tr>
<td>RDF</td>
<td>可由 JVM 上的系统实现的 RDF 1.1 的通用实现</td>
</tr>
<tr>
<td>RNG</td>
<td>随机数生成器的实现</td>
</tr>
<tr>
<td>Text</td>
<td>Apache Commons Text  是一个专注于处理字符串的算法的库</td>
</tr>
<tr>
<td>Validator</td>
<td>在 xml 文件中定义验证器和验证规则的框架</td>
</tr>
<tr>
<td>VFS</td>
<td>用于将文件、FTP、SMB、ZIP  等视为单个逻辑文件系统的虚拟文件系统组件</td>
</tr>
<tr>
<td>Weaver</td>
<td>提供一种简单的方法来增强（编织）已编译的字节码</td>
</tr>
</tbody></table>
<p>可以跟据需要去挑选对应的包，但需要注意鉴别</p>
<h3 id="1-2-The-Commons-Sandbox"><a href="#1-2-The-Commons-Sandbox" class="headerlink" title="1.2 The Commons Sandbox"></a>1.2 The Commons Sandbox</h3><p>The Commons Sandbox是一个临时的项目，其中包含社区成员正在探索和测试新的功能和实用程序。它为Apache Commons社区提供了一个试验新想法的地方，收集并评估新代码，并在尝试维护新代码时为项目管理人员提供时间。新的实用程序可能会在更大的Apache Commons项目中成为一个独立的单元，也可能会闲置</p>
<h3 id="1-3-The-Commons-Dormant"><a href="#1-3-The-Commons-Dormant" class="headerlink" title="1.3 The Commons Dormant"></a>1.3 The Commons Dormant</h3><p>The Commons Dormant的主要作用是维护那些不再活跃或已经过时的项目。这些项目可能已经失去了活跃的贡献者或用户，也可能已经与其他项目合并或重命名。The Commons Dormant通过提供必要的维护和文档资源，确保这些项目仍然能够持续保持可用和可维护。</p>
<h3 id="1-4-优缺点"><a href="#1-4-优缺点" class="headerlink" title="1.4 优缺点"></a>1.4 优缺点</h3><p>提供了丰富工具类，能够减少开发人员的工作量，避免重复造轮子</p>
<p>经过广泛的使用和测试，具有一定的可靠性</p>
<hr>
<p>工具包的质量参差不齐，引入工具包或工具方法前需要深入调研后才能使用，就这要求我们平时有一定的积累</p>
<p>如Apache commons的BeanUtils，虽然实现了对象的拷贝，但其中使用到了性能较差的反射，所以性能不佳：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../.vuepress/public/images/BeanUtils.png"
                      alt="BeanUtils"
                ></p>
<h2 id="二、主要内容-lang简介"><a href="#二、主要内容-lang简介" class="headerlink" title="二、主要内容 lang简介"></a>二、主要内容 lang简介</h2><p><code>Apache commons lang</code>为java.lang API提供了大量工具方法，例如：字符串操作、数组操作、随机数生成、反射、时间日期处理等等</p>
<p>注意点：Commons Lang 3.0（及后续版本）与之前的版本（org.apache.commons.lang）使用不同的包（org.apache.commons.lang3），且允许Commons Lang 3与Commons Lang 同时使用，但一般都是使用lang3</p>
<p>lang3中有非常多的工具类和工具方法，但并不是所有的内容都能在日常开发中使用，其包结构如下：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">├─org.apache.commons </span><br><span class="line">│  ├─lang3 // 提供很多静态工具方法，比较著名的如StringUtils、ArrayUtils</span><br><span class="line">│  │  ├─arch // 配合ArchUtils使用，可以获取处理器的体系结构和类型，并提供方法判断处理器是否是某个结构、某个类型</span><br><span class="line">│  │  ├─builder // 协助实现对象的toString()、hashCode()、equals()和compareTo()方法</span><br><span class="line">│  │  ├─compare // 封装了compareTo方法，提供Predicate实例</span><br><span class="line">│  │  ├─concurrent // 提供了一些并发的工具</span><br><span class="line">│  │  ├─event // 提供一些基于事件的工具</span><br><span class="line">│  │  ├─exception // 提供一些Exception相关的方法</span><br><span class="line">│  │  ├─function // 提供允许抛出异常的函数式接口，以补充java.lang.function和实用程序以与Java 8 Lambdas一起使用</span><br><span class="line">│  │  ├─math // 提供了分数类和一些数字工具方法</span><br><span class="line">│  │  ├─mutable // 为基本数据类型和不可变对象提供可变的包装类</span><br><span class="line">│  │  ├─reflect // 反射</span><br><span class="line">│  │  ├─stream // 补充java.util.stream</span><br><span class="line">│  │  ├─time // 提供使用日期和持续时间的类和方法</span><br><span class="line">│  │  ├─tuple // 元组类，提供了Pair和Triple</span><br></pre></td></tr></table></figure></div>

<h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><p>引入lang包：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>摘选了一些日常业务开发中可能会使用到的，或者是有一些启发意义的类</p>
<h3 id="3-1-NumberUtils"><a href="#3-1-NumberUtils" class="headerlink" title="3.1 NumberUtils"></a>3.1 NumberUtils</h3><p>提供数值操作的工具方法</p>
<h4 id="3-1-1-判断是否是数值"><a href="#3-1-1-判断是否是数值" class="headerlink" title="3.1.1 判断是否是数值"></a>3.1.1 判断是否是数值</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isNumberTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 是否为数字，不支持十六进制和科学计数法(常用)</span></span><br><span class="line">    System.out.println(NumberUtils.isParsable(<span class="string">&quot;3.14&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(NumberUtils.isParsable(<span class="string">&quot;0X2F&quot;</span>));<span class="comment">//false</span></span><br><span class="line">    System.out.println(NumberUtils.isParsable(<span class="string">&quot;12345E-10&quot;</span>));<span class="comment">//false</span></span><br><span class="line">    <span class="comment">// 判断str的每一个是否都是数字，即正整数</span></span><br><span class="line">    System.out.println(NumberUtils.isDigits(<span class="string">&quot;3.14&quot;</span>));<span class="comment">//false</span></span><br><span class="line">    System.out.println(NumberUtils.isDigits(<span class="string">&quot;-3&quot;</span>));<span class="comment">//false</span></span><br><span class="line">    System.out.println(NumberUtils.isDigits(<span class="string">&quot;30&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    <span class="comment">// 是否为数字，支持十六进制和科学计数法</span></span><br><span class="line">    System.out.println(NumberUtils.isCreatable(<span class="string">&quot;3.14&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(NumberUtils.isCreatable(<span class="string">&quot;0X2F&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(NumberUtils.isCreatable(<span class="string">&quot;12345E-10&quot;</span>));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-1-2-max-min"><a href="#3-1-2-max-min" class="headerlink" title="3.1.2 max&#x2F;min"></a>3.1.2 max&#x2F;min</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以Integer为例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maxMinTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// JDK方法，只支持两个值比较</span></span><br><span class="line">    System.out.println(Integer.max(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">    <span class="comment">// NumberUtils，支持3个甚至是数组</span></span><br><span class="line">    System.out.println(NumberUtils.max(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    System.out.println(NumberUtils.min(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    System.out.println(NumberUtils.max(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">    <span class="type">int</span>[] ints = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    System.out.println(NumberUtils.max(ints));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-1-3-toNumber"><a href="#3-1-3-toNumber" class="headerlink" title="3.1.3 toNumber"></a>3.1.3 toNumber</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串转化为数值类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toNumberTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// createXXX，支持十六进制、八进制的数值转化;如Integer，即是在Integer.decode基础上加了一道判空</span></span><br><span class="line">    System.out.println(NumberUtils.createInteger(<span class="string">&quot;0X2F&quot;</span>));</span><br><span class="line">    System.out.println(NumberUtils.createInteger(<span class="string">&quot;0777&quot;</span>));</span><br><span class="line">    System.out.println(Integer.decode(<span class="string">&quot;0X2F&quot;</span>));</span><br><span class="line">    <span class="comment">// 比较实用，当字符串不为数值时，使用默认数值</span></span><br><span class="line">    System.out.println(NumberUtils.toInt(<span class="string">&quot;abc&quot;</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 和Java原生实现相比，代码更简洁，且效果相同</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        i = Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-2-ArrayUtils"><a href="#3-2-ArrayUtils" class="headerlink" title="3.2 ArrayUtils"></a>3.2 ArrayUtils</h3><p>目前的日常开发中数组使用的不多，如数据库查询、Json格式化得到的都是List等容器，基本上只有字符串的拆分操作(split)会产生数组。ArrayUtils提供了以下两类方法</p>
<ul>
<li>部分方法和Arrays提供的方法重复(如toString())(不讲述)</li>
<li>提供的一些方法，可以将数组像List那样使用</li>
</ul>
<h4 id="3-2-1-判空方法"><a href="#3-2-1-判空方法" class="headerlink" title="3.2.1 判空方法"></a>3.2.1 判空方法</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组判空，针对null或者空的情况，以及将null转化为空数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">emptyTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] array1 = &#123;&#125;;</span><br><span class="line">    System.out.println(ArrayUtils.isEmpty(array1));</span><br><span class="line">    System.out.println(array1 == <span class="literal">null</span> || array1.length == <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span>[] array2 = <span class="literal">null</span>;</span><br><span class="line">    System.out.println(ArrayUtils.isNotEmpty(array2));</span><br><span class="line">    System.out.println(Arrays.toString(ArrayUtils.nullToEmpty(array2)));</span><br><span class="line">    System.out.println(array2 != <span class="literal">null</span> &amp;&amp; array2.length != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-2-2-查找元素下标"><a href="#3-2-2-查找元素下标" class="headerlink" title="3.2.2 查找元素下标"></a>3.2.2 查找元素下标</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组元素查找下标</span></span><br><span class="line"><span class="comment"> * jdk中没有提供相关方法，如果想实现这些功能，需要自己使用循环遍历数组或者将数组转化为List</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">searchTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>,<span class="number">55</span>&#125;;</span><br><span class="line">    <span class="comment">// 寻找元素在数组中的下标，只取第一个</span></span><br><span class="line">    System.out.println(ArrayUtils.indexOf(array, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 从下标1(包括1)的元素开始查找，只取第一个</span></span><br><span class="line">    System.out.println(ArrayUtils.indexOf(array, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    System.out.println(ArrayUtils.indexesOf(array, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 寻找元素在数组中的下标，只取最后一个</span></span><br><span class="line">    System.out.println(ArrayUtils.lastIndexOf(array, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 判断数组中是否有该元素</span></span><br><span class="line">    System.out.println(ArrayUtils.contains(array, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-2-3-修改数组"><a href="#3-2-3-修改数组" class="headerlink" title="3.2.3 修改数组"></a>3.2.3 修改数组</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类似List的方式来操作数组，但要注意：</span></span><br><span class="line"><span class="comment"> * 例如add方法(向数组尾部加一个元素)，每次插入都是扩容一次且只扩容1个长度，因此如果频繁插入更推荐将数组转化为List来操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>,<span class="number">55</span>&#125;;</span><br><span class="line">    <span class="comment">//------------insert------------</span></span><br><span class="line">    <span class="comment">// 向数组尾部插入一个元素，会自动扩容，但和ArrayList不同，每次只会扩容1</span></span><br><span class="line">    System.out.println(Arrays.toString(ArrayUtils.add(array, <span class="number">89</span>)));</span><br><span class="line">    <span class="comment">// 向数组首部插入一个元素</span></span><br><span class="line">    System.out.println(Arrays.toString(ArrayUtils.addFirst(array, <span class="number">0</span>)));</span><br><span class="line">    <span class="comment">// 向指定位置插入任意数量的元素</span></span><br><span class="line">    System.out.println(Arrays.toString(ArrayUtils.insert(<span class="number">2</span>, array, <span class="number">10</span>, <span class="number">11</span>)));</span><br><span class="line">    <span class="comment">// 向数组尾部插入另一个数组</span></span><br><span class="line">    <span class="type">int</span>[] array2 = &#123;<span class="number">89</span>, <span class="number">144</span>, <span class="number">233</span>&#125;;</span><br><span class="line">    System.out.println(Arrays.toString(ArrayUtils.addAll(array, array2)));</span><br><span class="line">    <span class="comment">//-----------remove------------</span></span><br><span class="line">    <span class="comment">// 移除指定下标的元素</span></span><br><span class="line">    System.out.println(Arrays.toString(ArrayUtils.remove(array, <span class="number">0</span>)));</span><br><span class="line">    <span class="comment">// 移除多个指定下标的元素，也可以直接传数组</span></span><br><span class="line">    System.out.println(Arrays.toString(ArrayUtils.removeAll(array, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)));</span><br><span class="line">    <span class="comment">// 移除从头至尾，第一个出现的指定元素</span></span><br><span class="line">    System.out.println(Arrays.toString(ArrayUtils.removeElement(array, <span class="number">1</span>)));</span><br><span class="line">    <span class="comment">// 移除所有指定的元素</span></span><br><span class="line">    System.out.println(Arrays.toString(ArrayUtils.removeAllOccurrences(array, <span class="number">1</span>)));</span><br><span class="line">    <span class="comment">//------------sub---------------</span></span><br><span class="line">    <span class="comment">// 切子数组，如下即下标在区间[0,5)内的元素</span></span><br><span class="line">    System.out.println(Arrays.toString(ArrayUtils.subarray(array, <span class="number">0</span>, <span class="number">5</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-2-4-其他方法"><a href="#3-2-4-其他方法" class="headerlink" title="3.2.4 其他方法"></a>3.2.4 其他方法</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一些其他的方法，可以跟据具体场景来使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">otherTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>,<span class="number">55</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] array2 = &#123;<span class="number">55</span>,<span class="number">34</span>,<span class="number">21</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// 判断两个数组长度是否相等</span></span><br><span class="line">    System.out.println(ArrayUtils.isSameLength(array, array2));</span><br><span class="line">    <span class="comment">// 判断数组内元素是否是按大小顺序排列的，提供的基本数据类型方法只能判断升序</span></span><br><span class="line">    System.out.println(ArrayUtils.isSorted(array));</span><br><span class="line">    System.out.println(ArrayUtils.isSorted(array2));</span><br><span class="line">    <span class="comment">// 可以自己定义排序方法，但需要将数组转化为包装类数组</span></span><br><span class="line">    System.out.println(ArrayUtils.isSorted(ArrayUtils.toObject(array), (i1, i2) -&gt; i2 - i1));</span><br><span class="line">    System.out.println(ArrayUtils.isSorted(ArrayUtils.toObject(array2), (i1, i2) -&gt; i2 - i1));</span><br><span class="line">    <span class="comment">// 数组倒序</span></span><br><span class="line">    ArrayUtils.reverse(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">    <span class="comment">// 数组平移，offset为正数则向右平移，为负数则向左平移</span></span><br><span class="line">    ArrayUtils.shift(array, -<span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">    <span class="comment">// 交换数组指定下标元素位置</span></span><br><span class="line">    ArrayUtils.swap(array, <span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">    <span class="comment">// 按每个数组元素生成随机数</span></span><br><span class="line">    ArrayUtils.shuffle(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3-StringUtils"><a href="#3-3-StringUtils" class="headerlink" title="3.3 StringUtils"></a>3.3 StringUtils</h3><p>使用非常多，且比较可靠，但坑也很多，使用前一定要先理解</p>
<h4 id="3-3-1-判空"><a href="#3-3-1-判空" class="headerlink" title="3.3.1 判空"></a>3.3.1 判空</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判空方法</span></span><br><span class="line"><span class="comment"> * 1. isEmpty只判断字符串是否为空字符串或者null</span></span><br><span class="line"><span class="comment"> * 2. isBlank除空字符串和null外，还会判断空格、tab、换行符甚至包含了unicode格式的空字符，基于Character.isWhitespace</span></span><br><span class="line"><span class="comment"> * 3. 还有isNotEmpty和isNotBlank分别和isEmpty和isBlank对应</span></span><br><span class="line"><span class="comment"> * 4. isAllEmpty、isAllBlank、isNoneEmpty、isNoneBlank，支持多个字符串判空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">emptyOrBlankTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">empty1</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">empty2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">empty3</span> <span class="operator">=</span> <span class="string">&quot; \n    \u2009&quot;</span>;</span><br><span class="line">    <span class="comment">// isEmpty</span></span><br><span class="line">    System.out.println(StringUtils.isEmpty(empty1));<span class="comment">//true</span></span><br><span class="line">    System.out.println(StringUtils.isEmpty(empty2));<span class="comment">//true</span></span><br><span class="line">    System.out.println(StringUtils.isEmpty(empty3));<span class="comment">//false</span></span><br><span class="line">    <span class="comment">// isBlank</span></span><br><span class="line">    System.out.println(StringUtils.isBlank(empty1));<span class="comment">//true</span></span><br><span class="line">    System.out.println(StringUtils.isBlank(empty2));<span class="comment">//true</span></span><br><span class="line">    System.out.println(StringUtils.isBlank(empty3));<span class="comment">//true</span></span><br><span class="line">    <span class="comment">// isNoneEmpty，比如有多个入参需要判断非空</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">notEmpty</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    System.out.println(StringUtils.isNoneEmpty(empty1, notEmpty));<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-3-2-contains"><a href="#3-3-2-contains" class="headerlink" title="3.3.2 contains"></a>3.3.2 contains</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * contains系列方法，StringUtils.contains()和jdk用法相同(多了一道null值校验)</span></span><br><span class="line"><span class="comment"> * 此外，还提供了一些contains的扩展方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">containsTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    System.out.println(StringUtils.contains(str, <span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">    <span class="comment">// 忽略大小写的contains</span></span><br><span class="line">    System.out.println(StringUtils.containsIgnoreCase(str, <span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    <span class="comment">// 判断是否包含空白字符，包括空格、tab、换行符等</span></span><br><span class="line">    System.out.println(StringUtils.containsWhitespace(str));</span><br><span class="line">    <span class="comment">// 判断字符串是否只包含给定的字符，也可以给字符串</span></span><br><span class="line">    System.out.println(StringUtils.containsOnly(str, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;!&#x27;</span>));</span><br><span class="line">    <span class="comment">// 判断字符串是否不包含给定的字符，也可以给字符串</span></span><br><span class="line">    System.out.println(StringUtils.containsNone(str, <span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    <span class="comment">// 给多个字符串，判断是否包含其中任意一个</span></span><br><span class="line">    System.out.println(StringUtils.containsAny(str, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">    <span class="comment">// 注意：如果containsAny只给一个字符串，那么会把字符串拆分成单个字符，只要一个字符在str中即返回true</span></span><br><span class="line">    System.out.println(StringUtils.containsAny(str, <span class="string">&quot;hello&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-3-3-startsWith"><a href="#3-3-3-startsWith" class="headerlink" title="3.3.3 startsWith"></a>3.3.3 startsWith</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * startsWith、endsWith系列方法,支持了忽略大小写和支持多个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startEndWithTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    System.out.println(StringUtils.startsWithIgnoreCase(str, <span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    System.out.println(StringUtils.startsWithAny(str, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    System.out.println(StringUtils.endsWithIgnoreCase(str, <span class="string">&quot;world!&quot;</span>));</span><br><span class="line">    System.out.println(StringUtils.endsWithAny(str, <span class="string">&quot;World!&quot;</span>, <span class="string">&quot;world!&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-3-4-处理首尾空白符"><a href="#3-3-4-处理首尾空白符" class="headerlink" title="3.3.4 处理首尾空白符"></a>3.3.4 处理首尾空白符</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 去除首尾的空白字符，trim和jdk中类似，strip提供了一些扩展</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeWhite</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot; Hello World!\u2009\u2009 &quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot; Hello World!\u2009\u2009 &quot;</span>;</span><br><span class="line">    <span class="comment">// trim，调用了String中的trim，去除首位字符，chars &lt;= 32</span></span><br><span class="line">    System.out.println(StringUtils.trim(str));</span><br><span class="line">    <span class="comment">// strip，使用Character.isWhitespace方法判断空字符，能够去掉unicode的空白字符</span></span><br><span class="line">    System.out.println(StringUtils.strip(str));</span><br><span class="line">    <span class="comment">// 去除空字符前为null，则返回null；去除后，若字符串为空，则返回null</span></span><br><span class="line">    System.out.println(StringUtils.stripToNull(str));</span><br><span class="line">    <span class="comment">// 去除空字符前为null，则返回空字符串；去除后，若字符串为空，则返回空字符串</span></span><br><span class="line">    System.out.println(StringUtils.stripToEmpty(str));</span><br><span class="line">    <span class="comment">// 支持去除首尾的指定字符串</span></span><br><span class="line">    System.out.println(StringUtils.strip(str, <span class="string">&quot; Hel&quot;</span>));</span><br><span class="line">    <span class="comment">// 去除首部的指定字符串</span></span><br><span class="line">    System.out.println(StringUtils.stripStart(str, <span class="string">&quot; &quot;</span>));</span><br><span class="line">    <span class="comment">// 去除尾部的指定字符串</span></span><br><span class="line">    System.out.println(StringUtils.stripEnd(str, <span class="string">&quot; &quot;</span>));</span><br><span class="line">    <span class="comment">// 批量去除，返回的是一个String数组</span></span><br><span class="line">    System.out.println(Arrays.toString(StringUtils.stripAll(str, str2)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-3-5-其他去除方法"><a href="#3-3-5-其他去除方法" class="headerlink" title="3.3.5 其他去除方法"></a>3.3.5 其他去除方法</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 其他的一些去除方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeOther</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// chomp,去除结尾的一处换行符，包括三种情况 \r、\n、\r\n</span></span><br><span class="line">    System.out.println(StringUtils.chomp(<span class="string">&quot;abc\r\n\r\n&quot;</span>));</span><br><span class="line">    <span class="comment">// 去除末尾的一个字符，\r\n会当成一个字符</span></span><br><span class="line">    System.out.println(StringUtils.chop(<span class="string">&quot;1,2,3,&quot;</span>));</span><br><span class="line">    <span class="comment">// 去除非数字字符</span></span><br><span class="line">    System.out.println(StringUtils.getDigits(<span class="string">&quot;1,2,3,&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-3-6-indexOf"><a href="#3-3-6-indexOf" class="headerlink" title="3.3.6 indexOf"></a>3.3.6 indexOf</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * indexOf系列方法，lastIndexOf也有相同的方法，以indexOf为例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">indexOfTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="comment">// 和jdk类似，查找字符在字符串中的位置</span></span><br><span class="line">    System.out.println(StringUtils.indexOf(str, <span class="string">&quot;o&quot;</span>));</span><br><span class="line">    System.out.println(StringUtils.indexOf(str, <span class="string">&quot;o&quot;</span>, <span class="number">6</span>));</span><br><span class="line">    <span class="comment">// 忽略大小写版的indexOf</span></span><br><span class="line">    System.out.println(StringUtils.indexOfIgnoreCase(str, <span class="string">&quot;h&quot;</span>));</span><br><span class="line">    <span class="comment">// 查找指定字符出现指定次数时的下标</span></span><br><span class="line">    System.out.println(StringUtils.ordinalIndexOf(str, <span class="string">&quot;l&quot;</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="comment">// 查找给定的多个字符中，第一个出现的下标</span></span><br><span class="line">    System.out.println(StringUtils.indexOfAny(str, <span class="string">&quot;lo&quot;</span>));</span><br><span class="line">    <span class="comment">// 查找除了给定的多个字符之外的字符，第一个出现的下标</span></span><br><span class="line">    System.out.println(StringUtils.indexOfAnyBut(str, <span class="string">&quot;lo&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-3-7-split"><a href="#3-3-7-split" class="headerlink" title="3.3.7 split"></a>3.3.7 split</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * split系列方法,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">splitTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;a.b.;.;e.f..g.h&quot;</span>;</span><br><span class="line">    <span class="comment">// JDK, 按正则&#x27;.;&#x27;分割字符串 [a.b, , e.f..g.h]，性能很差</span></span><br><span class="line">    System.out.println(Arrays.toString(str.split(<span class="string">&quot;.;&quot;</span>)));</span><br><span class="line">    <span class="comment">// 按照字符&#x27;.&#x27;,&#x27;;&#x27;来分割字符串 [a, b, e, f, g, h]</span></span><br><span class="line">    System.out.println(Arrays.toString(StringUtils.split(str, <span class="string">&quot;.;&quot;</span>)));</span><br><span class="line">    <span class="comment">// 按照字符&#x27;.&#x27;,&#x27;;&#x27;来分割字符串，但会保留空字符[a, b, , , , e, f, , g, h]</span></span><br><span class="line">    System.out.println(Arrays.toString(StringUtils.splitPreserveAllTokens(str, <span class="string">&quot;.;&quot;</span>)));</span><br><span class="line">    <span class="comment">// 按照字符串&quot;.;&quot;分割字符串 [a.b, e.f..g.h]</span></span><br><span class="line">    System.out.println(Arrays.toString(StringUtils.splitByWholeSeparator(str, <span class="string">&quot;.;&quot;</span>)));</span><br><span class="line">    <span class="comment">// 按照字符串&quot;.;&quot;分割字符串，但会保留空字符 [a.b, , e.f..g.h]</span></span><br><span class="line">    System.out.println(Arrays.toString(StringUtils.splitByWholeSeparatorPreserveAllTokens(str, <span class="string">&quot;.;&quot;</span>)));</span><br><span class="line">    <span class="comment">// 按照字符类型来分割，大写字母、小写字母、数字、空格、各类符号 [foo, 200, B, ar, BB, ar, !,  , ;]</span></span><br><span class="line">    System.out.println(Arrays.toString(StringUtils.splitByCharacterType(<span class="string">&quot;foo200BarBBar! ;&quot;</span>)));</span><br><span class="line">    <span class="comment">// 驼峰分割，大写字母后面是小写字母，则会分割到一起 [foo, 200, B, Bar, Bar, !,  , ;]</span></span><br><span class="line">    System.out.println(Arrays.toString(StringUtils.splitByCharacterTypeCamelCase(<span class="string">&quot;foo200BBarBar! ;&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-3-8-substring"><a href="#3-3-8-substring" class="headerlink" title="3.3.8 substring"></a>3.3.8 substring</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * subString系列方法，subString方法和jdk使用方式相同</span></span><br><span class="line"><span class="comment"> * 还提供了一些快捷的切割方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subStringTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="comment">// 首部取5个字符</span></span><br><span class="line">    System.out.println(StringUtils.left(str, <span class="number">5</span>));</span><br><span class="line">    <span class="comment">// 尾部取6个字符</span></span><br><span class="line">    System.out.println(StringUtils.right(str, <span class="number">6</span>));</span><br><span class="line">    <span class="comment">// 从小标3开始的字符(包括)，取5个字符</span></span><br><span class="line">    System.out.println(StringUtils.mid(str, <span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-3-9-replace"><a href="#3-3-9-replace" class="headerlink" title="3.3.9 replace"></a>3.3.9 replace</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换操作，String提供的方法使用了正则</span></span><br><span class="line"><span class="comment"> * 此外还提供了忽略大小写的替换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    System.out.println(StringUtils.replace(str, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    System.out.println(StringUtils.replaceIgnoreCase(str, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hello&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-3-10-其他编辑操作"><a href="#3-3-10-其他编辑操作" class="headerlink" title="3.3.10 其他编辑操作"></a>3.3.10 其他编辑操作</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 其他字符串编辑操作，移除、覆盖、重复</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">editTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="comment">// 移除remove操作</span></span><br><span class="line">    System.out.println(StringUtils.remove(str, <span class="string">&quot;l&quot;</span>));</span><br><span class="line">    <span class="comment">// 覆盖overlay操作，即将str中的[6,9)的字符替换为abc</span></span><br><span class="line">    System.out.println(StringUtils.overlay(str, <span class="string">&quot;abc&quot;</span>, <span class="number">6</span>, <span class="number">9</span>));</span><br><span class="line">    <span class="comment">// 重复repeat操作</span></span><br><span class="line">    System.out.println(StringUtils.repeat(str, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-4-compare"><a href="#3-4-compare" class="headerlink" title="3.4 compare"></a>3.4 compare</h3><p>代码可读性很强，但每次使用都要创建一个对象，比较鸡肋。。</p>
<h4 id="3-4-1-普通用法"><a href="#3-4-1-普通用法" class="headerlink" title="3.4.1 普通用法"></a>3.4.1 普通用法</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compareTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3.14&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;5.14&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3.14&quot;</span>);</span><br><span class="line">    ComparableUtils.ComparableCheckBuilder&lt;BigDecimal&gt; aCompare = ComparableUtils.is(a);</span><br><span class="line">    <span class="comment">// a在[b,c]或[c,b]区间内？</span></span><br><span class="line">    System.out.println(aCompare.between(b, c));</span><br><span class="line">    System.out.println(a.compareTo(c) &gt;= <span class="number">0</span> &amp;&amp; a.compareTo(b) &lt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// a在(b,c)或(c,b)区间内？</span></span><br><span class="line">    System.out.println(aCompare.betweenExclusive(b, c));</span><br><span class="line">    System.out.println(a.compareTo(c) &gt; <span class="number">0</span> &amp;&amp; a.compareTo(b) &lt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// a等于b？</span></span><br><span class="line">    System.out.println(aCompare.equalTo(b));</span><br><span class="line">    System.out.println(a.compareTo(b) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// a大于b？</span></span><br><span class="line">    System.out.println(aCompare.greaterThan(b));</span><br><span class="line">    System.out.println(a.compareTo(b) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// a大于等于b？</span></span><br><span class="line">    System.out.println(aCompare.greaterThanOrEqualTo(b));</span><br><span class="line">    System.out.println(a.compareTo(b) &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// a小于b？</span></span><br><span class="line">    System.out.println(aCompare.lessThan(b));</span><br><span class="line">    System.out.println(a.compareTo(b) &lt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// a小于等于b？</span></span><br><span class="line">    System.out.println(aCompare.lessThanOrEqualTo(b));</span><br><span class="line">    System.out.println(a.compareTo(b) &lt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-4-2-function用法"><a href="#3-4-2-function用法" class="headerlink" title="3.4.2 function用法"></a>3.4.2 function用法</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">functionTest</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;BigDecimal&gt; list = Arrays.asList(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1&quot;</span>), <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;2&quot;</span>), <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;4&quot;</span>), <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;5&quot;</span>), <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;6&quot;</span>));</span><br><span class="line">    <span class="comment">// 过滤出list中大于3.14的值</span></span><br><span class="line">    System.out.println(list.stream().filter(ComparableUtils.gt(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3.14&quot;</span>))).collect(Collectors.toList()));</span><br><span class="line">    System.out.println(list.stream().filter(a -&gt; a.compareTo(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3.14&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">            .collect(Collectors.toList()));</span><br><span class="line">    <span class="comment">// 过滤出list中在[3.14,5.18]中的值</span></span><br><span class="line">    System.out.println(list.stream().filter(ComparableUtils.between(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3.14&quot;</span>), <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;5.18&quot;</span>)))</span><br><span class="line">            .collect(Collectors.toList()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-5-function"><a href="#3-5-function" class="headerlink" title="3.5 function"></a>3.5 function</h3><p>可以在stream中抛出checked异常来终止stream操作，想不到使用场景</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;D:\\work\\function.txt&quot;</span>));</span><br><span class="line">        list.forEach(Failable.asConsumer(i -&gt; &#123;</span><br><span class="line">            writer.write(String.valueOf(i));</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125;));</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-6-Fraction"><a href="#3-6-Fraction" class="headerlink" title="3.6 Fraction"></a>3.6 Fraction</h3><p>分数类，可以在一定程度上代替BigDecimal，但需要进一步验证</p>
<h4 id="3-6-1-用法"><a href="#3-6-1-用法" class="headerlink" title="3.6.1 用法"></a>3.6.1 用法</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fractionTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 2/6，分子分母必须为int</span></span><br><span class="line">    <span class="type">Fraction</span> <span class="variable">f1</span> <span class="operator">=</span> Fraction.getFraction(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="comment">// 1/3，使用continued fraction algorithm算法，分母最大为10000</span></span><br><span class="line">    <span class="type">Fraction</span> <span class="variable">f2</span> <span class="operator">=</span> Fraction.getFraction(<span class="string">&quot;0.3333333&quot;</span>);</span><br><span class="line">    <span class="comment">// 3333/10000，和f2类似</span></span><br><span class="line">    <span class="type">Fraction</span> <span class="variable">f3</span> <span class="operator">=</span> Fraction.getFraction(<span class="number">0.3333</span>);</span><br><span class="line">    <span class="comment">// 生成带分数 2又1/3</span></span><br><span class="line">    <span class="type">Fraction</span> <span class="variable">f4</span> <span class="operator">=</span> Fraction.getFraction(<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 1/4，会进行约分操作</span></span><br><span class="line">    <span class="type">Fraction</span> <span class="variable">f5</span> <span class="operator">=</span> Fraction.getReducedFraction(<span class="number">3</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="comment">// 加减乘除运算</span></span><br><span class="line">    System.out.println(f1.add(f2).toProperString());</span><br><span class="line">    System.out.println(f1.subtract(f3).toProperString());</span><br><span class="line">    System.out.println(f1.multiplyBy(f4).toProperString());</span><br><span class="line">    System.out.println(f1.divideBy(f5).toProperString());</span><br><span class="line">    <span class="comment">// 倒数、约分、绝对值、幂、取反</span></span><br><span class="line">    System.out.println(f1.invert().toProperString());</span><br><span class="line">    System.out.println(f1.reduce().toProperString());</span><br><span class="line">    System.out.println(f1.abs().toProperString());</span><br><span class="line">    System.out.println(f1.pow(<span class="number">2</span>).toString());</span><br><span class="line">    System.out.println(f1.negate().toProperString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-6-2-使用场景"><a href="#3-6-2-使用场景" class="headerlink" title="3.6.2 使用场景"></a>3.6.2 使用场景</h4><p>计算两个均价的差值，BigDecimal执行除法为避免出现除不尽情况都需要指定小数位，导致精度损失，而Fraction就不会有这个问题</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">precisionTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">cost1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3451.21&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">count1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;110&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">cost2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;6553.21&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">count2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;70&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">avg1</span> <span class="operator">=</span> cost1.divide(count1, <span class="number">4</span>, RoundingMode.HALF_UP);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">avg2</span> <span class="operator">=</span> cost2.divide(count2, <span class="number">4</span>, RoundingMode.HALF_UP);</span><br><span class="line">    <span class="comment">//-62.2427</span></span><br><span class="line">    System.out.println(avg1.subtract(avg2));</span><br><span class="line">    <span class="type">Fraction</span> <span class="variable">cost3</span> <span class="operator">=</span> Fraction.getFraction(<span class="string">&quot;3451.21&quot;</span>);</span><br><span class="line">    <span class="type">Fraction</span> <span class="variable">count3</span> <span class="operator">=</span> Fraction.getFraction(<span class="string">&quot;110&quot;</span>);</span><br><span class="line">    <span class="type">Fraction</span> <span class="variable">cost4</span> <span class="operator">=</span> Fraction.getFraction(<span class="string">&quot;6553.21&quot;</span>);</span><br><span class="line">    <span class="type">Fraction</span> <span class="variable">count4</span> <span class="operator">=</span> Fraction.getFraction(<span class="string">&quot;70&quot;</span>);</span><br><span class="line">    <span class="type">Fraction</span> <span class="variable">avg3</span> <span class="operator">=</span> cost3.divideBy(count3);</span><br><span class="line">    <span class="type">Fraction</span> <span class="variable">avg4</span> <span class="operator">=</span> cost4.divideBy(count4);</span><br><span class="line">    <span class="comment">//-62.2426</span></span><br><span class="line">    System.out.println(BigDecimal.valueOf(avg3.subtract(avg4).doubleValue()).setScale(<span class="number">4</span>, RoundingMode.HALF_UP));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-7-mutable"><a href="#3-7-mutable" class="headerlink" title="3.7 mutable"></a>3.7 mutable</h3><p>提供了基本数据类型和不可变对象的包装，通常有两种使用场景</p>
<h4 id="3-7-1-修改入参"><a href="#3-7-1-修改入参" class="headerlink" title="3.7.1 修改入参"></a>3.7.1 修改入参</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 场景1，如果方法入参为不可变对象，而方法中需要修改入参且外部方法需要感知时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodParamTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 通过方法的return重新赋值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> <span class="string">&quot;outside&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">param1</span> <span class="operator">=</span> editParam(param);</span><br><span class="line">    System.out.println(param);</span><br><span class="line">    System.out.println(param1);</span><br><span class="line">    <span class="comment">// 使用MutableObject</span></span><br><span class="line">    MutableObject&lt;String&gt; mutableParam = <span class="keyword">new</span> <span class="title class_">MutableObject</span>&lt;&gt;(param);</span><br><span class="line">    editMutableParam(mutableParam);</span><br><span class="line">    System.out.println(mutableParam.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">editParam</span><span class="params">(String param)</span>&#123;</span><br><span class="line">    param = <span class="string">&quot;inside&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> param;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">editMutableParam</span><span class="params">(MutableObject&lt;String&gt; param)</span>&#123;</span><br><span class="line">    param.setValue(<span class="string">&quot;inside&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-7-2-集合修改基本数据类型"><a href="#3-7-2-集合修改基本数据类型" class="headerlink" title="3.7.2 集合修改基本数据类型"></a>3.7.2 集合修改基本数据类型</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 场景2，在集合中使用基本数据类型时，若值需要经常变动，可以使用可变对象</span></span><br><span class="line"><span class="comment"> * 和在循环中执行字符串+=操作类似</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">collectionTest</span><span class="params">()</span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map1.put(<span class="string">&quot;key&quot;</span>, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        map1.put(<span class="string">&quot;key&quot;</span>, map1.get(<span class="string">&quot;key&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        System.out.println(System.identityHashCode(map1.get(<span class="string">&quot;key&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(map1.get(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">    Map&lt;String, MutableInt&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map2.put(<span class="string">&quot;key&quot;</span>, <span class="keyword">new</span> <span class="title class_">MutableInt</span>(<span class="number">128</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        map2.get(<span class="string">&quot;key&quot;</span>).increment();</span><br><span class="line">        System.out.println(System.identityHashCode(map2.get(<span class="string">&quot;key&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(map2.get(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="四、简单总结"><a href="#四、简单总结" class="headerlink" title="四、简单总结"></a>四、简单总结</h2><p>使用好工具类可以达到事半功倍、简化代码的效果。但使用前需要深入调研，充分了解后再觉得是否使用，考验平时的积累</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>List &amp; AbstractList</title>
    <url>/2023/05/17/JDK8/util/List&amp;AbstractList/</url>
    <content><![CDATA[<p>List接口在Collection的基础上，定义了List独有的方法，也是List的特性</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../.vuepress/public/images/AbstractList.png"
                      alt="ArrayList"
                ><br>通过继承树，可以看到</p>
<ul>
<li>List继承了<a class="link"   href="https://www.huangkebing.com/blogs/JDK8/util/Collection&AbstractCollection.html" >Collection <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>List有一个抽象子类AbstractList</li>
</ul>
<h2 id="一、List"><a href="#一、List" class="headerlink" title="一、List"></a>一、List</h2><p>这里主要列举一下List相比Collection新定义的方法</p>
<ol>
<li>get</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>set</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>add</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>remove</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>subList</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="6">
<li>indexOf</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="7">
<li>lastIndexOf</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="8">
<li>addAll</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="9">
<li>replaceAll</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(operator);</span><br><span class="line">    <span class="keyword">final</span> ListIterator&lt;E&gt; li = <span class="built_in">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">while</span> (li.hasNext()) &#123;</span><br><span class="line">        li.set(operator.apply(li.next()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="10">
<li>sort</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = <span class="built_in">this</span>.toArray();</span><br><span class="line">    Arrays.sort(a, (Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = <span class="built_in">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="11">
<li>listIterator</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="二、AbstractList字段解读"><a href="#二、AbstractList字段解读" class="headerlink" title="二、AbstractList字段解读"></a>二、AbstractList字段解读</h2><p>提供了一个用于实现fast-fail机制的字段：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此列表在结构上被修改的次数。结构修改是指更改列表大小或以其他方式干扰列表，使正在进行的迭代可能会产生不正确结果的修改。</span></span><br><span class="line"><span class="comment"> * 如果此字段的值意外更改，迭代器（或列表迭代器）将抛出 &#123;<span class="doctag">@code</span> ConcurrentModificationException&#125; 以响应 &#123;<span class="doctag">@code</span> next&#125;、&#123;<span class="doctag">@code</span> remove&#125;、&#123;<span class="doctag">@code</span> previous&#125;、&#123;<span class="doctag">@code</span> set&#125; 或 &#123;<span class="doctag">@code</span> add&#125; 操作。 </span></span><br><span class="line"><span class="comment"> * 这提供了fast-fail机制，而不是在迭代期间面对并发修改时的非确定性行为。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 子类使用此字段是可选的。如果子类希望提供fast-fail机制，则只需在其 &#123;<span class="doctag">@code</span> add（int， E）&#125; 和 &#123;<span class="doctag">@code</span> remove（int）&#125; 方法（以及它覆盖的任何其他导致列表结构修改的方法）中递增此字段。 </span></span><br><span class="line"><span class="comment"> * 对 &#123;<span class="doctag">@code</span> add（int， E）&#125; 或 &#123;<span class="doctag">@code</span> remove（int）&#125; 的单个调用必须向此字段递增不超过1，否则迭代器（和列表迭代器）将抛出虚假的 &#123;<span class="doctag">@code</span> ConcurrentModificationExceptions&#125;。  </span></span><br><span class="line"><span class="comment"> * 如果实现不希望提供故障快速迭代器，则可以忽略此字段。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>::: tip</p>
<h3 id="备注1-fast-fail"><a href="#备注1-fast-fail" class="headerlink" title="备注1 fast-fail"></a>备注1 fast-fail</h3><p><code>fast-fail</code> 机制是指当在迭代过程中发现集合的结构被修改（如删除或添加）时，迭代器会立即抛出 ConcurrentModificationException 异常，防止程序继续迭代并对集合进行修改，从而避免出现预期之外的行为。这是为了增强程序的健壮性和安全性。</p>
<p>例如，在一个for循环中，如果使用迭代器来迭代某个集合，同时在循环中进行集合的元素的添加或删除，那么迭代器会快速响应，并抛出ConcurrentModificationException 异常，以避免对被迭代的集合造成不必要的影响。fast-fail 机制在集合类中广泛应用，如 ArrayList、LinkedList、HashSet、HashMap 等。它是基于已有集合数据结构实现的，在迭代器中添加了一些检查代码，以便快速检测到集合结构的变化。</p>
<p>:::</p>
<h2 id="三、AbstractList方法解读"><a href="#三、AbstractList方法解读" class="headerlink" title="三、AbstractList方法解读"></a>三、AbstractList方法解读</h2><p>和AbstractCollection类似，先略过</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>集合</category>
      </categories>
  </entry>
  <entry>
    <title>Collection &amp; AbstractCollection</title>
    <url>/2023/05/09/JDK8/util/Collection&amp;AbstractCollection/</url>
    <content><![CDATA[<p>Collection接口是Java集合框架的基本接口，它代表着一组对象的集合。List、Set和Queue均继承自Collection</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/AbstractCollection.png"
                      alt="AbstractCollection"
                ></p>
<p>通过继承树，可以看到</p>
<ul>
<li>Collection继承了Iterable</li>
<li>Collection有一个抽象子类AbstractCollection</li>
</ul>
<h2 id="一、Iterable"><a href="#一、Iterable" class="headerlink" title="一、Iterable"></a>一、Iterable</h2><p><code>Iterable</code>表示可迭代的、可遍历的，指的是一种对象，它可以被迭代、枚举、遍历</p>
<p>只要一个对象实现了Iterable接口，就可以使用for-each循环语句遍历对象中的元素。但是该对象必须提供一个Iterator对象来遍历元素。例如，List、Set和数组默认都实现了Iterable接口，因此可以使用for-each循环语句遍历它们中的元素</p>
<p>::: danger</p>
<h3 id="问题1-for-each与Iterator"><a href="#问题1-for-each与Iterator" class="headerlink" title="问题1 for-each与Iterator"></a>问题1 for-each与Iterator</h3><blockquote>
<p>Q：for-each和Iterator有什么关系？为什么要使用for-each还需要提供Iterator对象呢？</p>
</blockquote>
<p>以ArrayList为例，写一个简单的for-each循环测试样例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);list.add(<span class="number">2</span>);list.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">    System.out.println(integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>将样例的字节码反编译后得到如下内容：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="number">1</span>);list.add(<span class="number">2</span>);list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">var2</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> (Integer)var2.next();</span><br><span class="line">    System.out.println(integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到实际是用迭代器实现的，所以要使用for-each的类，必须提供Iterator对象。实际上<font color="#16b777">for-each用法是Java5发布的语法糖</font>。是一种更简洁的循环语法，可以遍历数组或集合中的所有元素，但实际上是通过迭代器来实现的。其全称是增强型for循环，可以让代码更加简洁、易读。</p>
<p>:::</p>
<p>Iterable接口定义了三个方法，除了迭代器的方法外，Java8还新增了forEach函数式接口的实现和可拆分的迭代器</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * forEach函数式接口的实现，本质还是for-each即迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="built_in">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得Spliterator(可拆分迭代器)对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="二、Collection"><a href="#二、Collection" class="headerlink" title="二、Collection"></a>二、Collection</h2><p>Collection接口定义了集合的通用方法并给出了一些设计规范，这里主要翻译了一下注释，有助于理解每个方法</p>
<ol>
<li>size 获取集合元素数</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此集合中的元素数。如果此集合包含的元素数量超过Integer.MAX_VALUE，则返回Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>isEmpty 判断集合是否为空</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此集合不包含任何元素，则返回 true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>contains 判断是否包含元素</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此集合包含指定的元素，则返回 true</span></span><br><span class="line"><span class="comment"> * 更正式地说，当且仅当此集合包含至少一个元素e时返回true，使得o==null？e==null:o.equals(e)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要测试其在此集合中的是否存在的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此集合包含指定的元素，则返回 true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException 如果指定元素的类型与此集合不兼容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的元素为 null，并且此集合不允许 null 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>iterator 获取迭代器</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此集合中元素的迭代器。对于元素的返回顺序没有保证（除非此集合是提供顺序保证的集合实例）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>toArray 转化为数组</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含此集合中所有元素的数组。如果此集合对其迭代器返回其元素的顺序做出任何保证，则此方法必须以相同的顺序返回元素</span></span><br><span class="line"><span class="comment"> * 此方法会分配一个新数组，即使这个集合底层是依托数组实现的。因此，调用方修改数组不会影响集合</span></span><br><span class="line"><span class="comment"> * 此方法充当数组和集合之间转化的桥梁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含此集合中所有元素的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object[] toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回包含此集合中所有元素的数组，返回数组的运行时类型是指定数组的运行时类型。</span></span><br><span class="line"><span class="comment"> * 如果集合的元素数量在指定的数组中足够存放，则在其中返回该集合。否则，将使用指定数组的运行时类型和集合的大小分配一个新数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果数组的元素多于集合，则紧跟在集合末尾之后的数组中的元素会被设置为null</span></span><br><span class="line"><span class="comment"> * 仅当调用方确定此集合不包含任何null元素时，这才可用于确定此集合的长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果此集合对其迭代器返回其元素的顺序做出任何保证，则此方法必须以相同的顺序返回元素</span></span><br><span class="line"><span class="comment"> * 与toArray()方法一样，此方法充当基于数组和基于集合的 API 之间的桥梁</span></span><br><span class="line"><span class="comment"> * 此外，该方法允许精确控制输出数组的运行时类型，并且在某些情况下可用于节省分配成本</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 假设x是一个已知只包含字符串的集合。以下代码可用于将集合转储到新分配的String数组中：</span></span><br><span class="line"><span class="comment"> * String[] y = x.toArray(new String[0]);</span></span><br><span class="line"><span class="comment"> * 请注意，toArray(new Object[0])在方法上与toArray()相同</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 要包含集合的数组的运行时类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 存储此集合的元素的数组（如果它足够大）;否则，将分配相同运行时类型的新数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含此集合中所有元素的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ArrayStoreException 如果指定数组的运行时类型不是此集合中每个元素的运行时类型的超类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的数组为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; T[] toArray(T[] a);</span><br></pre></td></tr></table></figure></div>

<ol start="6">
<li>add 新增元素</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可选择实现操作</span></span><br><span class="line"><span class="comment"> * 如果此集合因调用而更改，则返回true；如果此集合不允许重复且已包含指定的元素，则返回false</span></span><br><span class="line"><span class="comment"> * 支持此操作的集合可能会限制可以添加到此集合的元素,集合类应在其文档中明确指定对可以添加哪些元素的任何限制</span></span><br><span class="line"><span class="comment"> * 如果集合除了已经包含该元素外的任何原因拒绝添加特定元素，则必须引发异常，而不是返回false</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要确保其在此集合中的存在元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此集合因调用而更改，则为 true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException 如果此集合不支持添加操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException 如果指定元素的类阻止将其添加到此集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的元素为null，并且此集合不允许null元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果元素的某些属性阻止将其添加到此集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException 如果由于插入限制而此时无法添加元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="7">
<li>remove 移除元素</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可选择实现操作</span></span><br><span class="line"><span class="comment"> * 从此集合中删除指定元素的单个实例（如果存在），更正式地说，删除元素e，符合要求(o==null?e==null:o.equals(e))</span></span><br><span class="line"><span class="comment"> * 如果此集合包含指定的元素（如果此集合由于调用而更改），则返回 true</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要从此集合中删除的元素（如果存在）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果由于此调用而删除了元素，则为true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException 如果指定元素的类型与此集合不兼容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的元素为null，并且此集合不允许null元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException 如果此集合不支持删除操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="8">
<li>containsAll 批量包含</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此集合包含指定集合中的所有元素，则返回 true。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  c 要检查是否在此集合中的元素的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此集合包含指定集合中的所有元素，则为 true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException 如果指定集合中的一个或多个元素的类型与此集合不兼容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的集合包含一个或多个null元素，并且此集合不允许null元素或者，如果指定的集合为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>    #contains(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="9">
<li>addAll 批量新增</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合中的所有元素添加到此集合（可选操作）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 包含要添加到此集合的元素的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此集合因调用而更改，则为true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException 如果此集合不支持 addAll 操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException 如果指定集合的元素的类阻止将其添加到此集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的集合包含 null 元素，并且此集合不允许 null 元素，或者指定的集合为 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果指定集合的元素的某些属性阻止将其添加到此集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException 如果由于插入限制，此时无法添加所有元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #add(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="10">
<li>removeAll 批量移除</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除此集合中所有包含在指定集合中的元素(可选操作)。此调用返回后，此集合将不包含与指定集合相同的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 包含要从此集合中删除的元素的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此集合因调用而更改，则为true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException 如果此集合不支持removeAll方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException 如果此集合中一个或多个元素的类型与指定的集合不兼容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果此集合包含一个或多个null元素，并且指定的集合不支持null元素，或者如果指定的集合为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #remove(Object)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #contains(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="11">
<li>removeIf 移除满足predicate条件的元素</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除此集合中满足给定predicate(即predicate判断为true)的所有元素</span></span><br><span class="line"><span class="comment"> * 循环期间发生的错误或运行时异常将传递给调用方</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现规范：</span></span><br><span class="line"><span class="comment"> * 默认实现使用其迭代器遍历集合的所有元素。符合的元素使用迭代器的remove方法移除</span></span><br><span class="line"><span class="comment"> * 如果集合的迭代器不支持删除，则会在第一个匹配元素上抛出&#123;<span class="doctag">@code</span> UnsupportedOperationException&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filter 一个predicate，它为要删除的元素返回&#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125;如果删除了任何一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的filter为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException 如果无法从此集合中删除元素。如果无法删除匹配元素，或者通常不支持删除，则实现可能会引发此异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">final</span> Iterator&lt;E&gt; each = iterator();</span><br><span class="line">    <span class="keyword">while</span> (each.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter.test(each.next())) &#123;</span><br><span class="line">            each.remove();</span><br><span class="line">            removed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="12">
<li>retainAll 保留包含在给定集合中的元素</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 仅保留此集合中包含在给定集合中的元素 (可选操作)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 包含要保留在此集合中的元素的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此集合因调用而更改，则为 true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException 如果此集合不支持 retainAll 操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException 如果此集合中一个或多个元素的类型与给定的集合不兼容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果此集合包含一个或多个null元素，并且指定的集合不允许null元素，或者如果指定的集合为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #remove(Object)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #contains(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="13">
<li>clear 清空集合</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从此集合中删除所有元素 (可选操作)，此方法返回后，集合将为空。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException 如果此集合不支持清除操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="14">
<li>equals</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**	</span></span><br><span class="line"><span class="comment"> * 参考Object.equals()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要与此集合比较的对象 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果指定的对象等于此集合，则为 true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Object#equals(Object)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Set#equals(Object)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> List#equals(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="14">
<li>hashcode</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此集合的哈希值</span></span><br><span class="line"><span class="comment"> * 应该注意，任何重写Object.equals方法的类也必须重写Object.hashCode方法，以满足Object.hashCode方法的一般协定</span></span><br><span class="line"><span class="comment"> * 特别是，c1.equals(c2)意味着c1.hashCode()==c2.hashCode()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 此集合的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Object#hashCode()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Object#equals(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="15">
<li>spliterator</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此集合中的元素上创建&#123;<span class="doctag">@link</span> Spliterator&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 此集合中元素上的&#123;<span class="doctag">@code</span> Spliterator&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator(<span class="built_in">this</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="16">
<li>stream</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个连续的Stream，并将此集合作为其源</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回一个连续的Stream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="17">
<li>parallelStream</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个可能并行的Stream，并将此集合作为其源。此方法允许返回顺序流。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 此集合中的元素上可能并行的Stream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="三、AbstractCollection字段解读"><a href="#三、AbstractCollection字段解读" class="headerlink" title="三、AbstractCollection字段解读"></a>三、AbstractCollection字段解读</h2><p><code>AbstractCollection</code>中只有一个字段MAX_ARRAY_SIZE，即数组的最大长度</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure></div>

<p>::: danger</p>
<h3 id="问题2-为什么是要减8"><a href="#问题2-为什么是要减8" class="headerlink" title="问题2 为什么是要减8"></a>问题2 为什么是要减8</h3><blockquote>
<p>为什么MAX_ARRAY_SIZE的值是Integer.MAX_VALUE - 8？减8的意义是什么？</p>
</blockquote>
<p>注释中提到：某些VM会在数组中保留一些header，尝试分配更大的数组可能会导致OutOfMemoryError：请求的数组大小超过VM限制</p>
<p>但是在ArrayList中，可以看到扩容逻辑，其实最大值是Integer.MAX_VALUE</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>数组最大容量是 Integer.MAX_VALUE ，在图示情况扩容到 MAX_ARRAY_SIZE 是为了扩容到 MAX_ARRAY_SIZE以上长度就OOM的虚拟机可以尽量不OOM</p>
<p>详见：<a class="link"   href="https://blog.csdn.net/w605283073/article/details/109696771" >Java 8 ArrayList hugeCapacity 函数与 MAX_ARRAY_SIZE_明明如月学长的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>:::</p>
<h2 id="四、AbstractCollection方法解读"><a href="#四、AbstractCollection方法解读" class="headerlink" title="四、AbstractCollection方法解读"></a>四、AbstractCollection方法解读</h2><p><code>AbstractCollection</code>中的提供了部分方法的默认实现，均是基于迭代器来完成，如移除操作：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="literal">null</span>) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next())) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但很多实现类，如ArrayList，是基于下标来完成remove的，所以研究这部分实现意义不大</p>
<h2 id="五、Iterator"><a href="#五、Iterator" class="headerlink" title="五、Iterator"></a>五、Iterator</h2><p><code>Iterator</code>穿插在集合中，到底是什么呢？</p>
<p>迭代器（iterator）有时又称光标（cursor）是程序设计的软件设计模式，可在容器对象（container，例如链表或数组）上遍访的接口，设计人员无需关心容器对象的内存分配的实现细节。</p>
<p>也就是说，通过Iterator，我们无需关心集合内部是怎么实现的，就可以遍历集合</p>
<p>来看看Iterator接口都定义了哪些方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果还具有更多元素，则返回 true</span></span><br><span class="line"><span class="comment">     * 换句话说，如果 next 将返回一个元素而不是引发异常，则返回 true</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果还具有更多元素，则返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回迭代中的下一个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 迭代中的下一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException 如果没有元素了，抛异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从基础集合中删除此迭代器返回的最后一个元素（可选操作）。每次调用 next 时只能调用此方法一次。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException 如果此迭代器不支持删除操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException 如果尚未调用下一个方法，或者在上次调用下一个方法后已经调用了 Remove 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对其余每个元素执行给定的操作，直到处理完所有元素或操作引发异常。</span></span><br><span class="line"><span class="comment">     * 操作按迭代顺序（如果指定了该顺序）执行。操作引发的异常将中继到调用方。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 要对每个元素执行的操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException 如果执行的操作为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>::: tip</p>
<h3 id="备注1、Enumeration"><a href="#备注1、Enumeration" class="headerlink" title="备注1、Enumeration"></a>备注1、Enumeration</h3><p>在Iterator的注释中，发现了这个。Enumeration是Interator的前身，在Vector和Hashtable中使用，均是已经过时的内容了。</p>
<p>Enumeration有hasMoreElements()、hasMoreElements()两个方法对应Iterator的hasNext()和next()</p>
<p>Iterator相比Enumeration而言，有两个优势：</p>
<ol>
<li>具备remove的能力</li>
<li>方法名更简洁</li>
</ol>
<p>:::</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>集合</category>
      </categories>
  </entry>
  <entry>
    <title>文章链接</title>
    <url>/2023/10/20/blogs/</url>
    <content><![CDATA[<h2 id="博客搭建文档"><a href="#博客搭建文档" class="headerlink" title="博客搭建文档"></a>博客搭建文档</h2><ol>
<li><a class="link"   href="https://hexo.io/zh-cn/" >Hexo文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://redefine-docs.ohevan.com/getting-started" >redefine主题文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://mermaid.js.org/intro/" >mermaid文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<h2 id="博客站"><a href="#博客站" class="headerlink" title="博客站"></a>博客站</h2><ol>
<li><a class="link"   href="https://bugstack.cn/" >小傅哥 bugstack 虫洞栈 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.pdai.tech/" >Java 全栈知识体系 (pdai.tech) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<h2 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h2><ol>
<li><a class="link"   href="https://springdoc.cn/spring/" >Spring Framework 中文文档 (springdoc.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/m0_37959155/article/details/126273608" >spring源码环境5.2.x搭建(截图详细，踩坑多)_座上客的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><ol>
<li><a class="link"   href="https://www.wenjiangs.com/docs/spring-cloud" >Spring Cloud 中文文档(wenjiangs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>LCR_Part.2</title>
    <url>/2023/09/05/algorithm/LCR/LCR_Part2/</url>
    <content><![CDATA[<h2 id="21、删除链表的倒数第N个结点"><a href="#21、删除链表的倒数第N个结点" class="headerlink" title="21、删除链表的倒数第N个结点"></a><font color="orange">21、删除链表的倒数第N个结点</font></h2><p>给定一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p><strong>进阶：</strong>能尝试使用一趟扫描实现吗？</p>
<p>注意：本题与主站 19 题相同： <a class="link"   href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" >https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>因为是倒数第N的，而链表的长度是未知的，那么想要一次遍历就得使用双指针：</p>
<ol>
<li>大小指针初始化均指向head</li>
<li>大指针先移动n次</li>
<li>大小指针一直移动，直到大指针到最后一个结点(next为null)</li>
<li>此时小指针就是要删除结点的前置结点，修改next指针即可</li>
</ol>
<p>但是提交后遇到了问题，head&#x3D;[1,2], n&#x3D;2，这组用例，我们执行第3步是就会空指针(因为要判断大指针的next，而大指针此时已经为null了)</p>
<p>但我们能发现，如果出现这种情况，那么就是删除首结点，因此额外增加一个判断即可</p>
</div></div>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head, p2 = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p2为空，说明已经最后一个节点了，但此时还要往后，说明要移除首节点</span></span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1.next = p1.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="22、环形链表Ⅱ"><a href="#22、环形链表Ⅱ" class="headerlink" title="22、环形链表Ⅱ"></a><font color="orange">22、环形链表Ⅱ</font></h2><p>给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 <code>next</code> 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 <code>null</code>。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p>
<p><strong>说明：</strong>不允许修改给定的链表。</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：head = [1,2], pos = 0 </span><br><span class="line">输出：返回索引为 0 的链表节点 </span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：head = [1], pos = -1 </span><br><span class="line">输出：返回 null </span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure></div>



<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/LCR22.png"
                      alt="img"
                ></p>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 [0, 10^4] 内</li>
<li>-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5</li>
<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<p><strong>进阶：</strong>是否可以使用 <code>O(1)</code> 空间解决此题？</p>
<p>注意：本题与主站 142 题相同： <a class="link"   href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" >https://leetcode-cn.com/problems/linked-list-cycle-ii/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>第一想法：遍历链表并用哈希表保存，直到出现重复元素(找到环的头结点)或者遍历到null(没有环)，但是这不符合进阶的要求，因此需要找别的方案</p>
<p>这类题很容易联想到双指针，这里想到了快慢指针，如果有环，那么快慢指针必定能相遇，反之则没有环。到这一步还没有结束，我们只能知道有没有环确不知道环头在哪！因此快慢指针这个方案一度被我否了</p>
<p>最后没想法看了别人的思路，通过推导可以得出快慢指针到环头的距离和首结点到环头的距离一样。。。</p>
<p><font color="red">针对这类有隐藏规则的题，要么有大量题的积累，要么就得有推导的意识和思路，后续需要多加练习</font></p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head, fast = head, slow = head;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (fast != slow);</span><br><span class="line">        <span class="keyword">while</span> (fast != p1) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="23、相交链表"><a href="#23、相交链表" class="headerlink" title="23、相交链表"></a><font color="green">23、相交链表</font></h2><p>给定两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 </span><br><span class="line">输出：null </span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。 </span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 </span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>listA</code> 中节点数目为 <code>m</code></li>
<li><code>listB</code> 中节点数目为 <code>n</code></li>
<li>0 &lt;&#x3D; m, n &lt;&#x3D; 3 * 10^4</li>
<li>1 &lt;&#x3D; Node.val &lt;&#x3D; 10^5</li>
<li><code>0 &lt;= skipA &lt;= m</code></li>
<li><code>0 &lt;= skipB &lt;= n</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li>
</ul>
<p><strong>进阶：</strong>能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>
<p>注意：本题与主站 160 题相同：<a class="link"   href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" >https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>遇到过的题，双指针遍历两遍，指针A遍历链表A再遍历链表B，指针B相反</p>
<p>不论是否链表存在相交，最终两个指针都会在同一个结点相遇(如果不相交就都为null)</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA, p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 == <span class="literal">null</span>)&#123;</span><br><span class="line">                p1 = headB;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p2 == <span class="literal">null</span>)&#123;</span><br><span class="line">                p2 = headA;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="24、倒转链表"><a href="#24、倒转链表" class="headerlink" title="24、倒转链表"></a><font color="green">24、倒转链表</font></h2><p>给定单链表的头节点 <code>head</code> ，请反转链表，并返回反转后的链表的头节点。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：head = [1,2] </span><br><span class="line">输出：[2,1]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<p>注意：本题与主站 206 题相同： <a class="link"   href="https://leetcode-cn.com/problems/reverse-linked-list/" >https://leetcode-cn.com/problems/reverse-linked-list/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>很基本的链表题，题目要求用迭代或者递归，这里就用递归来做：</p>
<ol>
<li>先借助递归逐个调用到尾结点，记录为新的头指针</li>
<li>在归的过程中设置next指针即可</li>
</ol>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ListNode newHead;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(head);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            newHead = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">reverse</span> <span class="operator">=</span> reverse(node.next);</span><br><span class="line">        reverse.next = node;</span><br><span class="line">        node.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="25、两数相加Ⅱ"><a href="#25、两数相加Ⅱ" class="headerlink" title="25、两数相加Ⅱ"></a><font color="orange">25、两数相加Ⅱ</font></h2><p>给定两个 <strong>非空链表</strong> <code>l1</code>和 <code>l2</code> 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：l1 = [7,2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,8,0,7]</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[8,0,7]</span><br><span class="line"></span><br><span class="line">示例3：</span><br><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li>链表的长度范围为<code> [1, 100]</code></li>
<li><code>0 &lt;= node.val &lt;= 9</code></li>
<li>输入数据保证链表代表的数字无前导 0</li>
</ul>
<p><strong>进阶：</strong>如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。</p>
<p>注意：本题与主站 445 题相同：<a class="link"   href="https://leetcode-cn.com/problems/add-two-numbers-ii/" >https://leetcode-cn.com/problems/add-two-numbers-ii/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>不允许对原链表做操作，也就是不能翻转链表，就只能借助栈来做。需要特别注意进位问题</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty() || !stack2.isEmpty() || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> stack1.isEmpty() ? <span class="number">0</span> : stack1.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> stack2.isEmpty() ? <span class="number">0</span> : stack2.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> a + b + carry;</span><br><span class="line">            carry = cur / <span class="number">10</span>;</span><br><span class="line">            cur %= <span class="number">10</span>;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">curnode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(cur);</span><br><span class="line">            curnode.next = ans;</span><br><span class="line">            ans = curnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="26、重排链表"><a href="#26、重排链表" class="headerlink" title="26、重排链表"></a><font color="orange">26、重排链表</font></h2><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p>
<p><code>L0 → L1 → … → Ln-1 → Ln</code><br>请将其重新排列后变为：</font></p>
<p><code>L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …</code></p>
<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: head = [1,2,3,4]</span><br><span class="line">输出: [1,4,2,3]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: head = [1,2,3,4,5]</span><br><span class="line">输出: [1,5,2,4,3]</span><br></pre></td></tr></table></figure></div>

<p>提示：</p>
<ul>
<li>链表的长度范围为 <code>[1, 5 * 10^4]</code></li>
<li><code>1 &lt;= node.val &lt;= 1000</code></li>
</ul>
<p>注意：本题与主站 143 题相同：<a class="link"   href="https://leetcode-cn.com/problems/reorder-list/" >https://leetcode-cn.com/problems/reorder-list/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>一种思路是用栈保存所有元素，然后再次从head遍历，取栈中的一半元素插入到目标位置。这个想法的问题在于需要使用到JDK提供的容器，往往会涉及自动扩容等问题导致算法耗时偏高。</p>
<p>看到一种很巧妙的解法，就按照题目的思路走：</p>
<ul>
<li>先找到链表中点</li>
<li>再将后半段反转</li>
<li>再将链表合并</li>
</ul>
<p>虽然题目的要求看上去非常难，但是拆分为3步之后，每一步都是链表的基本操作了</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> getMiddle(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> mid.next;</span><br><span class="line">        mid.next = <span class="literal">null</span>;</span><br><span class="line">        cur1 = reverse(cur1);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        merge(cur, cur1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取中间元素，使用快慢指针，慢指针每次移动一个，快指针每次移动两个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">getMiddle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 翻转链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(ListNode cur, ListNode cur1)</span> &#123;</span><br><span class="line">        ListNode l1;</span><br><span class="line">        ListNode l2;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            l1 = cur.next;</span><br><span class="line">            l2 = cur1.next;</span><br><span class="line">            cur.next = cur1;</span><br><span class="line">            cur = l1;</span><br><span class="line">            cur1.next = l1;</span><br><span class="line">            cur1 = l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="27、回文链表"><a href="#27、回文链表" class="headerlink" title="27、回文链表"></a><font color="green">27、回文链表</font></h2><p>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: head = [1,2,3,3,2,1]</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: head = [1,2]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li>链表 L 的长度范围为 [1, 10^5]</li>
<li><code>0 &lt;= node.val &lt;= 9</code></li>
</ul>
<p><strong>进阶：</strong>能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<p>注意：本题与主站 234 题相同：<a class="link"   href="https://leetcode-cn.com/problems/palindrome-linked-list/" >https://leetcode-cn.com/problems/palindrome-linked-list/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>回文是很常见的一类题，通常是用首尾双指针，但这里是单向链表。然后想到将链表转化为数组，这样就具备了往前遍历的能力，然而时间复杂度为O(n)，但空间复杂度却不符合O(1)的要求</p>
<p>空间复杂度的要求，也就是不能用额外空间来保存链表的节点，也就是说只能操作链表本身。那么还是使用上一题的思路，先找中间结点，反转后段链表，在比较前后段链表是否相等</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 链表只有一个结点，是回文链表</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到链表中点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> getMiddle(head);</span><br><span class="line">        <span class="comment">// 取中点的next做后段链表的头结点</span></span><br><span class="line">        <span class="comment">// 链表为偶数情况，两个链表长度相等；为奇数情况，前段链表长度比后段大1</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rear</span> <span class="operator">=</span> mid.next;</span><br><span class="line">        mid.next = <span class="literal">null</span>;</span><br><span class="line">        rear = reverse(rear);</span><br><span class="line">        <span class="keyword">return</span> check(head, rear);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取链表的中间结点，奇数个即为中间结点，偶数个即为两个中间结点的前者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">getMiddle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 倒转链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验两个链表是否符合回文串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(ListNode front, ListNode rear)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前两个结点都不会空，比较值是否相等，如果不相等就不是回文串</span></span><br><span class="line">            <span class="keyword">if</span> (front != <span class="literal">null</span> &amp;&amp; rear != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (front.val != rear.val) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (front != <span class="literal">null</span> &amp;&amp; front.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果前段链表当前不会空，而后段链表当前为空，那么判断当前是否是前端链表的最后一个结点，如果是则是奇数的回文串</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 两者都为空，则为偶数的回文串</span></span><br><span class="line">                <span class="keyword">return</span> front == <span class="literal">null</span> &amp;&amp; rear == <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            front = front.next;</span><br><span class="line">            rear = rear.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="28、扁平化多级双向链表"><a href="#28、扁平化多级双向链表" class="headerlink" title="28、扁平化多级双向链表"></a><font color="orange">28、扁平化多级双向链表</font></h2><p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>
<p>给定位于列表第一级的头节点，请扁平化列表，即将这样的多级双向链表展平成普通的双向链表，使所有结点出现在单级双链表中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</span><br><span class="line">输出：[1,2,3,7,8,11,12,9,10,4,5,6]</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：head = [1,2,null,3]</span><br><span class="line">输出：[1,3,2]</span><br><span class="line">解释：</span><br><span class="line">输入的多级列表如下图所示：</span><br><span class="line">  1---2---NULL</span><br><span class="line">  |</span><br><span class="line">  3---NULL</span><br><span class="line">  </span><br><span class="line">示例 3：</span><br><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure></div>

<p><strong>如何表示测试用例中的多级链表？</strong></p>
<p>以 <strong>示例 1</strong> 为例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1---2---3---4---5---6--NULL</span><br><span class="line">      |</span><br><span class="line">      7---8---9---10--NULL</span><br><span class="line">         |</span><br><span class="line">         11--12--NULL</span><br></pre></td></tr></table></figure></div>

<p>序列化其中的每一级之后：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null]</span><br><span class="line">[7,8,9,10,null]</span><br><span class="line">[11,12,null]</span><br></pre></td></tr></table></figure></div>

<p>为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null]</span><br><span class="line">[null,null,7,8,9,10,null]</span><br><span class="line">[null,11,12,null]</span><br></pre></td></tr></table></figure></div>

<p>合并所有序列化结果，并去除末尾的 null 。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li>节点数目不超过 <code>1000</code></li>
<li><code>1 &lt;= Node.val &lt;= 10^5</code></li>
</ul>
<p>注意：本题与主站 430 题相同： <a class="link"   href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/" >https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>从题目要求中能看出是深度优先遍历，但这里是链表不是二叉树，一旦进入某个结点的child结点就无法回到该结点的next结点了</p>
<p>因此需要将结点保存起来，这里选用了栈，因为符合深度遍历的特征</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">flatten</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="comment">// 空链表特殊情况处理</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(head);</span><br><span class="line">        <span class="comment">// 记录上一个结点，用于后续结点的prev赋值</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            curr.prev = node;</span><br><span class="line">            <span class="comment">// next不为空，将next入栈</span></span><br><span class="line">            <span class="keyword">if</span> (curr.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(curr.next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// child不为空，将child入栈，并将child指针赋值null</span></span><br><span class="line">            <span class="keyword">if</span> (curr.child != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(curr.child);</span><br><span class="line">                curr.child = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将next指针赋值为当前栈的栈顶</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                curr.next = stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            node = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="29、循环有序列表的插入"><a href="#29、循环有序列表的插入" class="headerlink" title="29、循环有序列表的插入"></a><font color="orange">29、循环有序列表的插入</font></h2><p>给定<strong>循环单调非递减列表</strong>中的一个点，写一个函数向这个列表中插入一个新元素 <code>insertVal</code> ，使这个列表仍然是循环升序的。</p>
<p>给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。</p>
<p>如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。</p>
<p>如果列表为空（给定的节点是 <code>null</code>），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/example_1_before_65p.jpg"
                      alt="img"
                > <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/example_1_after_65p.jpg"
                      alt="img"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：head = [3,4,1], insertVal = 2</span><br><span class="line">输出：[3,4,1,2]</span><br><span class="line">解释：在上图中，有一个包含三个元素的循环有序列表，你获得值为 3 的节点的指针，我们需要向表中插入元素 2 。新插入的节点应该在 1 和 3 之间，插入之后，整个列表如上图所示，最后返回节点 3 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：head = [], insertVal = 1</span><br><span class="line">输出：[1]</span><br><span class="line">解释：列表为空（给定的节点是 null），创建一个循环有序列表并返回这个节点。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：head = [1], insertVal = 0</span><br><span class="line">输出：[1,0]</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= Number of Nodes &lt;= 5 * 10^4</code></li>
<li><code>-10^6 &lt;= Node.val &lt;= 10^6</code></li>
<li><code>-10^6 &lt;= insertVal &lt;= 10^6</code></li>
</ul>
<p>注意：本题与主站 708 题相同： <a class="link"   href="https://leetcode-cn.com/problems/insert-into-a-sorted-circular-linked-list/" >https://leetcode-cn.com/problems/insert-into-a-sorted-circular-linked-list/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>主要就是插入条件的判断，有很多种情况。最开始就想着快慢指针，目标值小于快指针大于慢指针即可</p>
<p>但提交后又陆续遇到目标值是新最大值、新最小值等等情况，这种很难一次就想到，个人认为更偏向于考验debug的能力</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">insert</span><span class="params">(Node head, <span class="type">int</span> insertVal)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(insertVal);</span><br><span class="line">            node.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">fast</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 第一部分条件，慢结点比快结点大，即到了非递减列表的边界，此时如果元素大于等于最大值或者小于等于最小值，视为新的临界点插入</span></span><br><span class="line"><span class="comment">             * 第二部分条件，元素大于等于慢结点，小于等于快结点说明是正常顺序找到了位置，插入</span></span><br><span class="line"><span class="comment">             * 第三部分条件，快结点等于头结点，说明此时已经找了一圈，仍然没有找到，那么就插在链表尾部</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((slow.val &gt; fast.val &amp;&amp; (insertVal &lt;= fast.val || insertVal &gt;= slow.val))</span><br><span class="line">                    || (insertVal &gt;= slow.val &amp;&amp; insertVal &lt;= fast.val)</span><br><span class="line">                    || fast == head) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(insertVal, fast);</span><br><span class="line">                slow.next = node;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="30、O-1-时间插入、删除和获取随机元素"><a href="#30、O-1-时间插入、删除和获取随机元素" class="headerlink" title="30、O(1)时间插入、删除和获取随机元素"></a><font color="orange">30、O(1)时间插入、删除和获取随机元素</font></h2><p>设计一个支持在<em>平均</em> 时间复杂度 <strong>O(1)</strong> 下，执行以下操作的数据结构：</p>
<ul>
<li><code>insert(val)</code>：当元素 <code>val</code> 不存在时返回 <code>true</code> ，并向集合中插入该项，否则返回 <code>false</code> 。</li>
<li><code>remove(val)</code>：当元素 <code>val</code> 存在时返回 <code>true</code> ，并从集合中移除该项，否则返回 <code>false</code> 。</li>
<li><code>getRandom</code>：随机返回现有集合中的一项。每个元素应该有 <strong>相同的概率</strong> 被返回。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 :</span><br><span class="line">输入: inputs = [&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[], [1], [2], [2], [], [1], [2], []]</span><br><span class="line">输出: [null, true, false, true, 2, true, false, 2]</span><br><span class="line">解释:</span><br><span class="line">RandomizedSet randomSet = new RandomizedSet();  // 初始化一个空的集合</span><br><span class="line">randomSet.insert(1); // 向集合中插入 1 ， 返回 true 表示 1 被成功地插入</span><br><span class="line">randomSet.remove(2); // 返回 false，表示集合中不存在 2 </span><br><span class="line">randomSet.insert(2); // 向集合中插入 2 返回 true ，集合现在包含 [1,2] </span><br><span class="line">randomSet.getRandom(); // getRandom 应随机返回 1 或 2 </span><br><span class="line">randomSet.remove(1); // 从集合中移除 1 返回 true 。集合现在包含 [2] </span><br><span class="line">randomSet.insert(2); // 2 已在集合中，所以返回 false </span><br><span class="line">randomSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 </span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>-2^31 &lt;= val &lt;= 2^31 - 1</code></li>
<li>最多进行<code> 2 * 105</code> 次 <code>insert</code> ， <code>remove</code> 和 <code>getRandom</code> 方法调用</li>
<li>当调用 <code>getRandom</code> 方法时，集合中至少有一个元素</li>
</ul>
<p>注意：本题与主站 380 题相同：<a class="link"   href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/" >https://leetcode-cn.com/problems/insert-delete-getrandom-o1/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>第一想法是没有思路，因为set不能实现随机访问，list无法做到O(1)删除。</p>
<p>于是学习了题解，使用map而不是set，map保存元素在list中的下标。这一点是我没有想到的，通过map让list也具备O(1)的查询能力</p>
<p>此外，还有一个细节就是删除元素时，如果不是尾部元素不要直接移除，而是将尾部元素替换删除元素，再删除尾部元素，这样可以避免执行数组移位操作</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    Random random;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RandomizedSet</span><span class="params">()</span> &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(val);</span><br><span class="line">        map.put(val, list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> map.get(val);</span><br><span class="line">        <span class="comment">// 如果要删除的就是尾部元素，则无需做元素移动操作</span></span><br><span class="line">        <span class="keyword">if</span> (index != list.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">last</span> <span class="operator">=</span> list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">            map.put(last, index);</span><br><span class="line">            list.set(index, last);</span><br><span class="line">        &#125;</span><br><span class="line">        map.remove(val);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(list.size());</span><br><span class="line">        <span class="keyword">return</span> list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="31、LRU缓存"><a href="#31、LRU缓存" class="headerlink" title="31、LRU缓存"></a><font color="orange">31、LRU缓存</font></h2><p>运用所掌握的数据结构，设计和实现一个 <a class="link"   href="https://baike.baidu.com/item/LRU" >LRU (Least Recently Used，最近最少使用) 缓存机制 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span><br><span class="line">lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 1</span><br><span class="line">lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br><span class="line">lRUCache.get(2);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    // 返回 3</span><br><span class="line">lRUCache.get(4);    // 返回 4</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 3000</code></li>
<li><code>0 &lt;= key &lt;= 10000</code></li>
<li><code>0 &lt;= value &lt;= 10^5</code></li>
<li>最多调用 <code>2 * 10^5</code> 次 <code>get</code> 和 <code>put</code></li>
</ul>
<p><strong>进阶</strong>：是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p>
<p>注意：本题与主站 146 题相同：<a class="link"   href="https://leetcode-cn.com/problems/lru-cache/" >https://leetcode-cn.com/problems/lru-cache/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>和30题一样，都是对数据结构的综合运用，这类题遇到很少，也是没有太多思路</p>
<p>了解到LinkedHashMap可以实现，只需要重写一个方法，但既然是在刷题练手，过度依赖JDK提供的容器是没意义的</p>
<p>又了解到，通过哈希表+双向链表可以实现LRU的效果</p>
<ul>
<li>哈希表中存放key和链表结点Node</li>
<li>链表来实现最近最少使用，即最新使用的放到链表头，那么尾部结点就是最近最少使用的结点</li>
</ul>
<p>和30题的思路其实类似，都是借助哈希表的O(1)查找使得原本查找需要O(n)的数据结构也拥有O(1)的能力</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储所有元素的map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, LinkedNode&gt; map;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 维护最近最少使用顺序链表的首尾结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedNode head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedNode tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">LinkedNode</span>();</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="keyword">new</span> <span class="title class_">LinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">LinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">LinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">LinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedNode</span>(key, value);</span><br><span class="line">            <span class="keyword">if</span>(size &gt;= capacity)&#123;</span><br><span class="line">                <span class="type">LinkedNode</span> <span class="variable">removeNode</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">                map.remove(removeNode.key);</span><br><span class="line">                removeTail(removeNode);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, newNode);</span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            size++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(LinkedNode node)</span>&#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(LinkedNode node)</span>&#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeTail</span><span class="params">(LinkedNode node)</span>&#123;</span><br><span class="line">        node.prev.next = tail;</span><br><span class="line">        tail.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    LinkedNode prev;</span><br><span class="line">    LinkedNode next;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedNode</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="32、有效的字母异位词"><a href="#32、有效的字母异位词" class="headerlink" title="32、有效的字母异位词"></a><font color="green">32、有效的字母异位词</font></h2><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断它们是不是一组变位词（字母异位词）。</p>
<p><strong>注意：</strong>若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同且<strong>字符顺序不完全相同</strong>，则称 <code>s</code> 和 <code>t</code> 互为变位词（字母异位词）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></div>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 5 * 10^4</code></li>
<li><code>s</code> and <code>t</code> 仅包含小写字母</li>
</ul>
<p><strong>进阶:</strong> 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<p>注意：本题与主站 242 题相似（字母异位词定义不同）：<a class="link"   href="https://leetcode-cn.com/problems/valid-anagram/" >https://leetcode-cn.com/problems/valid-anagram/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>第一种思路是利用哈希</p>
<ol>
<li>创建一个长度为26的数组，下标依次对应abcd…</li>
<li>然后遍历字符串s，将s中出现的字符，依次找到数组中对应位置并+1</li>
<li>遍历字符串t，将t中出现的字符，依次找到数组中对应位置并-1，最终如果数组中所有元素都为0则说明是异位词</li>
</ol>
<p>当前前提是两个字符串不是相等的</p>
<p>第二种思路是排序，将字符排序后比较是否相等即可</p>
<p>而两种方案比较，哈希时间复杂度是O(n)，排序时间复杂度为O(nlogn)</p>
<p>因此第一种方案更佳</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(t) || s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            counts[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            counts[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> count : counts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="33、字母异位词分组"><a href="#33、字母异位词分组" class="headerlink" title="33、字母异位词分组"></a><font color="orange">33、字母异位词分组</font></h2><p>给定一个字符串数组 <code>strs</code> ，将 <strong>变位词</strong> 组合在一起。 可以按任意顺序返回结果列表。</p>
<p><strong>注意：</strong>若两个字符串中每个字符出现的次数都相同，则称它们互为变位词。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: strs = [&quot;&quot;]</span><br><span class="line">输出: [[&quot;&quot;]]</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: strs = [&quot;a&quot;]</span><br><span class="line">输出: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 10^4</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> 仅包含小写字母</li>
</ul>
<p>注意：本题与主站 49 题相同： <a class="link"   href="https://leetcode-cn.com/problems/group-anagrams/" >https://leetcode-cn.com/problems/group-anagrams/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>算是第32题的加强版，也就是可以照搬基本逻辑，使用数组来记录字符出现次数</p>
<p>区别在于：不能使用减法了来判断了，需要将每个字符串的数组都计算出来</p>
<p>原本的想法是将每个分区的数组保存到一个List中，两个List下标相对应，这样每个字符串的数组先和已经分区了的比较，然后跟据比较结果执行存入已有分区或者另建分区</p>
<p>但是效率很差平均500ms，分析后发现，比较这一步耗时很大，其时间复杂度为O(n^2)</p>
<p>于是用哈希来优化key保存数组转化的字符串，value为分区list，把时间复杂度降为O(n)，以后需要注意能用hash的绝对不要遍历</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                counts[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键</span></span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (counts[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i));</span><br><span class="line">                    sb.append(counts[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="34、验证外星语词典"><a href="#34、验证外星语词典" class="headerlink" title="34、验证外星语词典"></a><font color="green">34、验证外星语词典</font></h2><p>某种外星语也使用英文小写字母，但可能顺序 <code>order</code> 不同。字母表的顺序（<code>order</code>）是一些小写字母的排列。</p>
<p>给定一组用外星语书写的单词 <code>words</code>，以及其字母表的顺序 <code>order</code>，只有当给定的单词在这种外星语中按字典序排列时，返回 <code>true</code>；否则，返回 <code>false</code>。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：在该语言的字母表中，&#x27;h&#x27; 位于 &#x27;l&#x27; 之前，所以单词序列是按字典序排列的。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：在该语言的字母表中，&#x27;d&#x27; 位于 &#x27;l&#x27; 之后，那么 words[0] &gt; words[1]，因此单词序列不是按字典序排列的。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：当前三个字符 &quot;app&quot; 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 &quot;apple&quot; &gt; &quot;app&quot;，因为 &#x27;l&#x27; &gt; &#x27;∅&#x27;，其中 &#x27;∅&#x27; 是空白字符，定义为比任何其他字符都小（更多信息）。</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 100</code></li>
<li><code>1 &lt;= words[i].length &lt;= 20</code></li>
<li><code>order.length == 26</code></li>
<li>在 <code>words[i]</code> 和 <code>order</code> 中的所有字符都是英文小写字母。</li>
</ul>
<p>注意：本题与主站 953 题相同： <a class="link"   href="https://leetcode-cn.com/problems/verifying-an-alien-dictionary/" >https://leetcode-cn.com/problems/verifying-an-alien-dictionary/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>首先将order转化为哈希表减少查询耗时</p>
<p>然后依次两两比对，如果前字符串出现字符值大于后字符串，或者两者相等长度都一致，且前字符串长度大于后字符串时，返回false</p>
<p>遍历完成未出现上述情况，返回true</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAlienSorted</span><span class="params">(String[] words, String order)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (words.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">32</span>);</span><br><span class="line">        <span class="type">char</span>[] orderChars = order.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; orderChars.length; i++) &#123;</span><br><span class="line">            map.put(orderChars[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lastStr</span> <span class="operator">=</span> words[<span class="number">0</span>];</span><br><span class="line">        next:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> words[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> Math.min(lastStr.length(), str.length());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lastStr.charAt(j) == str.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (map.get(lastStr.charAt(j)) &gt; map.get(str.charAt(j))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lastStr = str;</span><br><span class="line">                    <span class="keyword">continue</span> next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lastStr.length() &gt; str.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="35、最小时间差"><a href="#35、最小时间差" class="headerlink" title="35、最小时间差"></a><font color="orange">35、最小时间差</font></h2><p>给定一个 24 小时制（小时:分钟 **”HH:MM”**）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：timePoints = [&quot;23:59&quot;,&quot;00:00&quot;]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：timePoints = [&quot;00:00&quot;,&quot;23:59&quot;,&quot;00:00&quot;]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= timePoints &lt;= 2 * 10^4</code></li>
<li><code>timePoints[i]</code> 格式为 <strong>“HH:MM”</strong></li>
</ul>
<p>注意：本题与主站 539 题相同： <a class="link"   href="https://leetcode-cn.com/problems/minimum-time-difference/" >https://leetcode-cn.com/problems/minimum-time-difference/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>首先如果不排序的话，那么是O(n^2)，排序的话是O(nlogn)+O(n)，所以先排序效果会更好一些</p>
<p>排序后就是相邻两个元素，转化成分钟数后两两比较(不要漏掉首尾元素比较)，需要注意分钟差不是两者相减即可：</p>
<p>如23：59和00：00，即1439和0</p>
<p>两者的相隔分钟数应该是min(1439-0, 0+1440-1439) &#x3D; 1</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinDifference</span><span class="params">(List&lt;String&gt; timePoints)</span> &#123;</span><br><span class="line">        timePoints.sort(String::compareTo);</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> formatMinute(timePoints.get(<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastMinute</span> <span class="operator">=</span> formatMinute(timePoints.get(timePoints.size() - <span class="number">1</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> subtractTime(last, lastMinute);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; timePoints.size(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> formatMinute(timePoints.get(i));</span><br><span class="line">            <span class="type">int</span> <span class="variable">subtractTime</span> <span class="operator">=</span> subtractTime(last, minute);</span><br><span class="line">            <span class="keyword">if</span> (subtractTime == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (subtractTime &lt; min) &#123;</span><br><span class="line">                min = subtractTime;</span><br><span class="line">            &#125;</span><br><span class="line">            last = minute;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">formatMinute</span><span class="params">(String time)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> Integer.parseInt(time.substring(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> Integer.parseInt(time.substring(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> hour * <span class="number">60</span> + minute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subtractTime</span><span class="params">(<span class="type">int</span> time1, <span class="type">int</span> time2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(time2 - time1, time1 + <span class="number">1440</span> - time2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="36、逆波兰表达式求值"><a href="#36、逆波兰表达式求值" class="headerlink" title="36、逆波兰表达式求值"></a><font color="orange">36、逆波兰表达式求值</font></h2><p>根据<a class="link"   href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" > 逆波兰表示法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，求该后缀表达式的计算结果。</p>
<p>有效的算符包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p><strong>说明：</strong></p>
<ul>
<li>整数除法只保留整数部分。</li>
<li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= tokens.length &lt;= 10^4</code></li>
<li><code>tokens[i]</code> 要么是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），要么是一个在范围 <code>[-200, 200]</code> 内的整数</li>
</ul>
<p><strong>逆波兰表达式：</strong></p>
<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<ul>
<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>
<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>
</ul>
<p>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li>
</ul>
<p>注意：本题与主站 150 题相同： <a class="link"   href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" >https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>跟据示例，尤其是示例2，很明显符合栈的特征：</p>
<p>当遇到数字时入栈，遇到运算符则取栈顶两个元素，执行响应运算并将结果压回栈</p>
<p>注意尤其是除法和减法，不要写错运算数顺序</p>
<p>这里还发现JDK12一个语法: 这样写可以不加break，当然得是JDK12以上版本</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (token) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span> -&gt; &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">second</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">first</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        stack.push(first + second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>: &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">second</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">first</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    stack.push(first + second);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>: &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">second</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">first</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    stack.push(first - second);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>: &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">second</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">first</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    stack.push(first * second);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>: &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">second</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">first</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    stack.push(first / second);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    stack.push(Integer.valueOf(token));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="37、行星碰撞"><a href="#37、行星碰撞" class="headerlink" title="37、行星碰撞"></a><font color="orange">37、行星碰撞</font></h2><p>给定一个整数数组 <code>asteroids</code>，表示在同一行的小行星。</p>
<p>对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。</p>
<p>找出碰撞后剩下的所有小行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：asteroids = [5,10,-5]</span><br><span class="line">输出：[5,10]</span><br><span class="line">解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：asteroids = [8,-8]</span><br><span class="line">输出：[]</span><br><span class="line">解释：8 和 -8 碰撞后，两者都发生爆炸。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：asteroids = [10,2,-5]</span><br><span class="line">输出：[10]</span><br><span class="line">解释：2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：asteroids = [-2,-1,1,2]</span><br><span class="line">输出：[-2,-1,1,2]</span><br><span class="line">解释：-2 和 -1 向左移动，而 1 和 2 向右移动。 由于移动方向相同的行星不会发生碰撞，所以最终没有行星发生碰撞。 </span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= asteroids.length &lt;= 10^4</code></li>
<li><code>-1000 &lt;= asteroids[i] &lt;= 1000</code></li>
<li><code>asteroids[i] != 0</code></li>
</ul>
<p>注意：本题与主站 735 题相同： <a class="link"   href="https://leetcode-cn.com/problems/asteroid-collision/" >https://leetcode-cn.com/problems/asteroid-collision/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>比较典型的栈题。跟据规则，只有栈顶元素为正数，入栈元素为负数时会发生碰撞。碰撞时，判断两个数绝对值大小来讨论：</p>
<ul>
<li>栈顶元素绝对值大，则无需对栈做处理</li>
<li>入栈元素绝对值大，则移除栈顶元素，并和一下栈顶元素做新一轮判断</li>
<li>两者一样，则移除栈顶元素</li>
</ul>
<p>这里原本使用Stack来做但效率很差，最后用了ArrayDeque来代替</p>
</div></div>

<div class="note success"><h3 id="栈的使用"><a href="#栈的使用" class="headerlink" title="栈的使用"></a>栈的使用</h3><p>Stack其底层使用了Vector，是线程安全的，那么也就会导致性能偏差，耗时偏长</p>
<p>建议使用ArrayDeque来代替，使用起来没有区别</p>
<p>但还是有不同的地方，目前使用发现的有：</p>
<ul>
<li>使用Stream转化为数组时。Stack是从栈底到栈顶的顺序，而ArrayDeque是从栈顶到栈底的顺序</li>
</ul>
</div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] asteroidCollision(<span class="type">int</span>[] asteroids) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> asteroid : asteroids) &#123;</span><br><span class="line">            collision(asteroid, stack);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans[i] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">collision</span><span class="params">(<span class="type">int</span> asteroid, Deque&lt;Integer&gt; stack)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            stack.push(asteroid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">prev</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        <span class="keyword">if</span>(asteroid &lt; <span class="number">0</span> &amp;&amp; prev &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">abs</span> <span class="operator">=</span> Math.abs(asteroid);</span><br><span class="line">            <span class="keyword">if</span>(prev &lt; abs)&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                collision(asteroid, stack);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(prev == abs)&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(asteroid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="38、每日温度"><a href="#38、每日温度" class="headerlink" title="38、每日温度"></a><font color="orange">38、每日温度</font></h2><p>请根据每日 <code>气温</code> 列表 <code>temperatures</code> ，重新生成一个列表，要求其对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: temperatures = [30,40,50,60]</span><br><span class="line">输出: [1,1,1,0]</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: temperatures = [30,60,90]</span><br><span class="line">输出: [1,1,0]</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= temperatures.length &lt;= 10^5</code></li>
<li><code>30 &lt;= temperatures[i] &lt;= 100</code></li>
</ul>
<p>注意：本题与主站 739 题相同： <a class="link"   href="https://leetcode-cn.com/problems/daily-temperatures/" >https://leetcode-cn.com/problems/daily-temperatures/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>使用栈来做，但栈中存放的不能是温度，而是存温度在数组中的下标，从栈底到栈顶，下标对应温度逐渐下降</p>
<p>当遍历一个温度时，循环比较栈顶：当前温度大于栈顶温度时，可以弹出栈顶并计算两者下标差，直到出现当前问题小于等于栈顶温度或栈为空时结束循环，并将当前温度入栈</p>
<p>遍历完成后，将栈中元素全部弹出，并给0</p>
<p>这种栈也叫做单调栈，但不一定时栈中元素就是单调递增&#x2F;减，只要逻辑上存在单调递增&#x2F;减即可</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[temperatures.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temperature</span> <span class="operator">=</span> temperatures[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperature &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                result[index] = i - index;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result[index] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="39、柱状图中最大的矩阵"><a href="#39、柱状图中最大的矩阵" class="headerlink" title="39、柱状图中最大的矩阵"></a><font color="red">39、柱状图中最大的矩阵</font></h2><p>给定非负整数数组 <code>heights</code> ，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 <code>1</code> 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/LCR39.jpg"
                      alt="img"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 10</span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">输入： heights = [2,4]</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= heights.length &lt;=10^5</code></li>
<li><code>0 &lt;= heights[i] &lt;= 10^4</code></li>
</ul>
<p>注意：本题与主站 84 题相同： <a class="link"   href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" >https://leetcode-cn.com/problems/largest-rectangle-in-histogram/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large red"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>完全没思路，题解看了也不是很理解，先跳过吧</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(right, n);</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; mono_stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                right[mono_stack.peek()] = i;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.isEmpty() ? -<span class="number">1</span> : mono_stack.peek());</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = Math.max(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="40、最大矩阵"><a href="#40、最大矩阵" class="headerlink" title="40、最大矩阵"></a><font color="red">40、最大矩阵</font></h2><div class="note-large red"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>和39类似，一样的没思路，先提升实力后面再来</p>
</div></div>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offerⅡ</category>
      </categories>
  </entry>
  <entry>
    <title>LCR_Part.1</title>
    <url>/2023/08/02/algorithm/LCR/LCR_Part1/</url>
    <content><![CDATA[<h2 id="1、整数除法"><a href="#1、整数除法" class="headerlink" title="1、整数除法"></a><font color="green">1、整数除法</font></h2><p>给定两个整数 <code>a</code> 和 <code>b</code> ，求它们的除法的商 <code>a/b</code> ，要求不得使用乘号 <code>&#39;*&#39;</code>、除号 <code>&#39;/&#39;</code> 以及求余符号 <code>&#39;%&#39;</code> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>整数除法的结果应当截去（<code>truncate</code>）其小数部分，例如：<code>truncate(8.345) = 8</code> 以及 <code>truncate(-2.7335) = -2</code></li>
<li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 <code>[−2^31, 2^31−1]</code>。本题中，如果除法结果溢出，则返回 <code>2^31 − 1</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：a = 15, b = 2</span><br><span class="line">输出：7</span><br><span class="line">解释：15/2 = truncate(7.5) = 7</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：a = 7, b = -3</span><br><span class="line">输出：-2</span><br><span class="line">解释：7/-3 = truncate(-2.33333..) = -2</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：a = 0, b = 1</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：a = 1, b = 1</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line">- -2^31 &lt;= a, b &lt;= 2^31 - 1</span><br><span class="line">- b != 0</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 29 题相同：<a class="link"   href="https://leetcode-cn.com/problems/divide-two-integers/" >https://leetcode-cn.com/problems/divide-two-integers/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>因不能使用乘除，想到的解法就是循环减，但仔细不想感觉不对劲。如2^30^ &#x2F; 1，那就要循环2^30^次，这其实就算是暴力解法是不能接受的</p>
<p>学习了别人的解法，是基于循环减的优化版，利用2的幂次减少循环次数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果满足n+n&lt;m，n=n+n，商=商+商,如m=20,n=3：</span><br><span class="line">- n=3,商=1，3+3&lt;20成立</span><br><span class="line">- n=3+3=6,商=1+1=2，6+6&lt;20成立</span><br><span class="line">- n=6+6=12，商=2+2=4，12+12&lt;20不成立</span><br><span class="line">执行m=m-n，n=3,并重复上述逻辑，直到m&lt;n:</span><br><span class="line">- m=20-12=8,n=3,商=1，3+3&lt;8成立</span><br><span class="line">- n=3+3=6，商=1+1=2，6+6&lt;8不成立</span><br><span class="line">- m=8-6=2,此时m&lt;n,结束循环并累加商：</span><br><span class="line">最终商=4+2=6</span><br></pre></td></tr></table></figure></div>

<p>此外还需要注意越界问题，-2^31^&#x2F;-1会越界</p>
<p>而且正负数对应执行减加法，我们需要先将两个数都转化为同符号，因为正数转负数不会越界因此统一转化为负数来计算</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;</span><br><span class="line">        <span class="comment">//-2^31/ -1 = 2^31 溢出</span></span><br><span class="line">        <span class="keyword">if</span>(dividend == <span class="number">0x80000000</span> &amp;&amp; divisor == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0x7FFFFFFF</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">negative</span> <span class="operator">=</span> <span class="number">2</span>;<span class="comment">//用于记录正数个数</span></span><br><span class="line">        <span class="comment">//由于负数转为正数 -2^31 -&gt; 2^31 越界，所以采用正数转为负数</span></span><br><span class="line">        <span class="keyword">if</span>(dividend &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            negative --;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(divisor &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            negative --;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算两个负数相除</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(dividend &lt;= divisor)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> divisor;<span class="comment">//统计减数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">quotient</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//统计商</span></span><br><span class="line">            <span class="keyword">while</span>(value &gt; <span class="number">0xc0000000</span> &amp;&amp; value + value &gt;= dividend)&#123;<span class="comment">//value &gt; 0xc0000000 防止value*2溢出</span></span><br><span class="line">                quotient += quotient;<span class="comment">//如果可以用乘法 quotient*=2</span></span><br><span class="line">                value += value;<span class="comment">//如果可以用乘法 value*=2</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result += quotient;</span><br><span class="line">            dividend -= value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> negative == <span class="number">1</span> ? -result : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="2、二进制加法"><a href="#2、二进制加法" class="headerlink" title="2、二进制加法"></a><font color="green">2、二进制加法</font></h2><p>给定两个 01 字符串 <code>a</code> 和 <code>b</code> ，请计算它们的和，并以二进制字符串的形式输出。</p>
<p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: a = &quot;11&quot;, b = &quot;10&quot;</span><br><span class="line">输出: &quot;101&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">- 每个字符串仅由字符 `&#x27;0&#x27;` 或 `&#x27;1&#x27;` 组成。</span><br><span class="line">- `1 &lt;= a.length, b.length &lt;= 10^4`</span><br><span class="line">- 字符串如果不是 `&quot;0&quot;` ，就都不含前导零。</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 67 题相同：<a class="link"   href="https://leetcode-cn.com/problems/add-binary/" >https://leetcode-cn.com/problems/add-binary/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note success"><h3 id="Java关于进制的API"><a href="#Java关于进制的API" class="headerlink" title="Java关于进制的API"></a>Java关于进制的API</h3><p>其实Java中是提供了其他进制字符串转数值，或者数值转其他进制字符串的API的，以Integer为例子，本题也可以这样写：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ai</span> <span class="operator">=</span> Integer.parseInt(a, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">bi</span> <span class="operator">=</span> Integer.parseInt(b, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ai + bi;</span><br><span class="line">        <span class="keyword">return</span> Integer.toBinaryString(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中parseInt中的第二个参数就是进制，而toBinaryString方法就是将数值转化为二进制</p>
</div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>但在本题中，这样做行不通，因为ab的长度最大是10000，1w位的二进制数，早早就超过了int甚至long的范围，所以我们只能老老实实的自己来实现。逻辑比较多，但是都很容易想到，着重注意进位的问题即可</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="comment">// 考虑进位需要预留一位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> Math.max(a.length(), b.length()) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ai</span> <span class="operator">=</span> a.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bi</span> <span class="operator">=</span> b.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ci</span> <span class="operator">=</span> chars.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 从尾至头遍历，直到一个数用完</span></span><br><span class="line">        <span class="keyword">while</span> (ai &gt;= <span class="number">0</span> &amp;&amp; bi &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ac</span> <span class="operator">=</span> a.charAt(ai);</span><br><span class="line">            <span class="type">char</span> <span class="variable">bc</span> <span class="operator">=</span> b.charAt(bi);</span><br><span class="line">            <span class="keyword">if</span> (ac == bc) &#123;</span><br><span class="line">                <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">                    chars[ci--] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    chars[ci--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                carry = ac != <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">                    chars[ci--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    chars[ci--] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ai--;</span><br><span class="line">            bi--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ai &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ai = bi;</span><br><span class="line">            a = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理剩下的数</span></span><br><span class="line">        <span class="keyword">while</span> (ai &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ac</span> <span class="operator">=</span> a.charAt(ai);</span><br><span class="line">            <span class="keyword">if</span> (ac == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">                    chars[ci--] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    chars[ci--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                carry = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">                    chars[ci--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    chars[ci--] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ai--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断最后是否进位，如果不用进阶需要切割数组</span></span><br><span class="line">        <span class="type">int</span> offset;</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line">        <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">            chars[ci] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            offset = <span class="number">0</span>;</span><br><span class="line">            count = length;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            chars[ci] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            offset = <span class="number">1</span>;</span><br><span class="line">            count = length - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(chars, offset, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="3、比特位计数"><a href="#3、比特位计数" class="headerlink" title="3、比特位计数"></a><font color="green">3、比特位计数</font></h2><p>给定一个非负整数 <code>n</code> ，请计算 <code>0</code> 到 <code>n</code> 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: n = 2</span><br><span class="line">输出: [0,1,1]</span><br><span class="line">解释: </span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: n = 5</span><br><span class="line">输出: [0,1,1,2,1,2]</span><br><span class="line">解释:</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br><span class="line">3 --&gt; 11</span><br><span class="line">4 --&gt; 100</span><br><span class="line">5 --&gt; 101</span><br><span class="line"></span><br><span class="line">说明 :</span><br><span class="line">0 &lt;= n &lt;= 105</span><br></pre></td></tr></table></figure></div>

<p><strong>进阶:</strong></p>
<ul>
<li>给出时间复杂度为 <code>O(n*sizeof(integer))</code> 的解答非常容易。但你可以在线性时间 <code>O(n)</code> 内用一趟扫描做到吗？</li>
<li>要求算法的空间复杂度为 <code>O(n)</code> 。</li>
<li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 <code>__builtin_popcount</code> ）来执行此操作</li>
</ul>
<p>注意：本题与主站 338 题相同：<a class="link"   href="https://leetcode-cn.com/problems/counting-bits/" >https://leetcode-cn.com/problems/counting-bits/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>如果时间复杂度是O(n)，那么遍历每个数字的每一位就不符合要求了，只能跟据f(n-1)来推算f(n)，这样一来就成了动态规划，问题就变成了如何推算</p>
<p>之前提到过动态规划的难点在于如果找到推算公式，需要多刷题积累</p>
</div></div>

<div class="note success"><h3 id="数字比特位1数量的特点"><a href="#数字比特位1数量的特点" class="headerlink" title="数字比特位1数量的特点"></a>数字比特位1数量的特点</h3><p>奇数n比n-1多1</p>
<p>偶数n&#x3D;n&#x2F;2</p>
</div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] process = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        process[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                process[i] = process[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                process[i] = process[i / <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> process;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="4、只出现一次的数字Ⅱ"><a href="#4、只出现一次的数字Ⅱ" class="headerlink" title="4、只出现一次的数字Ⅱ"></a><font color="orange">4、只出现一次的数字Ⅱ</font></h2><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [2,2,3,2]</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0,1,0,1,0,1,100]</span><br><span class="line">输出：100</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li>
<li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li>
<li><code>nums</code> 中，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次</strong></li>
</ul>
<p><strong>进阶：</strong>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>注意：本题与主站 137 题相同：<a class="link"   href="https://leetcode-cn.com/problems/single-number-ii/" >https://leetcode-cn.com/problems/single-number-ii/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>此题和Offer56-2一样。思路是用位运算接口3的特征</p>
<p>将元素的二进制每一位累加(每一位用十进制保存)，最终将每一位取余3，得到的二进制数即为目标数的二进制，再转化为十进制即可</p>
</div></div>

<p><a class="link"   href="https://www.huangkebing.com/2023/06/25/algorithm/offer/%E5%89%91%E6%8C%87Offer_Part3/#56-2%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E2%85%A1" >剑指Offer_Part.3 - technology-inn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="5、最大单词长度乘积"><a href="#5、最大单词长度乘积" class="headerlink" title="5、最大单词长度乘积"></a><font color="orange">5、最大单词长度乘积</font></h2><p>给定一个字符串数组 <code>words</code>，请计算当两个字符串 <code>words[i]</code> 和 <code>words[j]</code> 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: words = [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;fxyz&quot;,&quot;abcdef&quot;]</span><br><span class="line">输出: 16 </span><br><span class="line">解释: 这两个单词为 &quot;abcw&quot;, &quot;fxyz&quot;。它们不包含相同字符，且长度的乘积最大。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: words = [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 这两个单词为 &quot;ab&quot;, &quot;cd&quot;。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]</span><br><span class="line">输出: 0 </span><br><span class="line">解释: 不存在这样的两个单词。</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= words.length &lt;= 1000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>
<li><code>words[i]</code> 仅包含小写字母</li>
</ul>
<p>注意：本题与主站 318 题相同：<a class="link"   href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/" >https://leetcode-cn.com/problems/maximum-product-of-word-lengths/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>这道题可以分成两部分：</p>
<ul>
<li>获取最大长度</li>
<li>判断两个字符串是否包含相同字符</li>
</ul>
<p>先来看获取最大长度，因为字符数组没有任何规律，因此两循环获得最大长度是没有优化空间的</p>
<p>那么问题就是如果判断两个字符串是否包含相同字符了，按照日常的业务思路，有这些思路：</p>
<ul>
<li>双循环判断</li>
<li>使用set</li>
</ul>
<p>但这两个方法，都存在重复遍历的问题，因为一个字符串肯定是要比较多次的，这里就可以用位运算的思路</p>
<p>如abc转化为111，def转化为111000，即a为第一位，b第二位，…</p>
<p>判断abc和def是否包含相同字符时，只需要将两个数执行&amp;操作，如果结果为0就代表没有相同字符</p>
<p>这个方法解决了重复遍历的问题，而且程序执行位运算是非常快的，进一步优化了耗时</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[words.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> words[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; word.length(); j++) &#123;</span><br><span class="line">                num = num | (<span class="number">1</span> &lt;&lt; word.charAt(j) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            numbers[i] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; numbers.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>((numbers[i] &amp; numbers[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    res = Math.max(res, words[i].length() * words[j].length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="6、两数之和Ⅱ-输入有序数组"><a href="#6、两数之和Ⅱ-输入有序数组" class="headerlink" title="6、两数之和Ⅱ-输入有序数组"></a><font color="green">6、两数之和Ⅱ-输入有序数组</font></h2><p>给定一个已按照 <strong>升序排列</strong> 的整数数组 <code>numbers</code> ，请你从数组中找出两个数满足相加之和等于目标数 <code>target</code> 。</p>
<p>函数应该以长度为 <code>2</code> 的整数数组的形式返回这两个数的下标值<em>。</em><code>numbers</code> 的下标 <strong>从 0 开始计数</strong> ，所以答案数组应当满足 <code>0 &lt;= answer[0] &lt; answer[1] &lt; numbers.length</code> 。</p>
<p>假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：numbers = [1,2,4,6,10], target = 8</span><br><span class="line">输出：[1,3]</span><br><span class="line">解释：2 与 6 之和等于目标数 8 。因此 index1 = 1, index2 = 3 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：numbers = [2,3,4], target = 6</span><br><span class="line">输出：[0,2]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：numbers = [-1,0], target = -1</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= numbers.length &lt;= 3 * 10^4</code></li>
<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>
<li><code>numbers</code> 按 <strong>非递减顺序</strong> 排列</li>
<li><code>-1000 &lt;= target &lt;= 1000</code></li>
<li>仅存在一个有效答案</li>
</ul>
<p>注意：本题与主站 167 题相似（下标起点不同）：<a class="link"   href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/" >https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>本来想到用二分查找，可以算出需要的数值，然后去有序数组里查找，但是结果耗时1ms，击败30%多，有点不能接受</p>
<p>然后考虑双指针，发现不太对，不管指针怎么移动，和都在变大。这里要注意，<strong>双指针的条件，必须是A指针移动结果变大，B指针移动结果变小(或者相反)</strong></p>
<p>这里双指针，可以从首尾开始，若和大于目标，尾指针前移，反之首指针后移</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> <span class="number">0</span>,big = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(small &lt; big)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> numbers[small] + numbers[big];</span><br><span class="line">            <span class="keyword">if</span>(add &gt; target)&#123;</span><br><span class="line">                big--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(add &lt; target)&#123;</span><br><span class="line">                small++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;small, big&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="7、三数之和"><a href="#7、三数之和" class="headerlink" title="7、三数之和"></a><font color="orange">7、三数之和</font></h2><p>给定一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <code>a</code> ，<code>b</code> ，<code>c</code> <em>，</em>使得 <code>a + b + c = 0</code> ？请找出所有和为 <code>0</code> 且 <strong>不重复</strong> 的三元组。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">- `0 &lt;= nums.length &lt;= 3000`</span><br><span class="line">- `-10^5 &lt;= nums[i] &lt;= 10^5`</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 15 题相同：<a class="link"   href="https://leetcode-cn.com/problems/3sum/" >https://leetcode-cn.com/problems/3sum/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>如果3个数都需要遍历，那就只能三循环，即O(n^3)，肯定是行不通的</p>
<p>因此，我们先将数组排序，再固定一位遍历，那么剩下两位就转化为了两数之和且数组有序，没错就是上面那题</p>
<p>但这里要注意的是需要去重</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fix</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (b &lt; c) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> fix + nums[b] + nums[c];</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    b++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    c--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    list1.add(fix);</span><br><span class="line">                    list1.add(nums[b]);</span><br><span class="line">                    list1.add(nums[c]);</span><br><span class="line">                    list.add(list1);</span><br><span class="line">                    <span class="comment">//较难理解</span></span><br><span class="line">                    <span class="keyword">while</span> (b&lt;nums.length - <span class="number">1</span> &amp;&amp; nums[b] == nums[++b] &amp;&amp; nums[c] == nums[--c]) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; nums.length - <span class="number">2</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="8、长度最小的子数组"><a href="#8、长度最小的子数组" class="headerlink" title="8、长度最小的子数组"></a><font color="orange">8、长度最小的子数组</font></h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> 。</p>
<p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure></div>

<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; target &lt;&#x3D; 10^9</li>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</li>
<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</li>
</ul>
<p>进阶：</p>
<ul>
<li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li>
</ul>
<p>注意：本题与主站 209 题相同：<a class="link"   href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" >https://leetcode-cn.com/problems/minimum-size-subarray-sum/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>基本就是双指针的变式，就是坑有点多，和简单的滑动窗口不同，此题如果不做限制，小指针可能会超过大指针，而且有各种数组越界的意外情况。</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">			<span class="comment">// 可能第一个值就比目标值大</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> <span class="number">0</span>,big = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(big &lt; nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(add &gt;= target)&#123;</span><br><span class="line">                result = Math.min(result, big - small + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 小大指针重合，避免小指针大于大指针，需要从下一个元素开始遍历</span></span><br><span class="line">                <span class="keyword">if</span>(small == big)&#123;</span><br><span class="line">                    big++;</span><br><span class="line">                    small++;</span><br><span class="line">                    add = nums[small];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    add -= nums[small++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                add += nums[++big];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 避免越界报错，当大指针到最后一个时，依次缩小滑动窗口的大小，直到和小于目标值或者小指针也到最后一个元素</span></span><br><span class="line">        <span class="keyword">while</span>(add &gt;= target &amp;&amp; small &lt;= nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">            result = Math.min(result, big - small + <span class="number">1</span>);</span><br><span class="line">            add -= nums[small++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="9、乘积小于K的子数组"><a href="#9、乘积小于K的子数组" class="headerlink" title="9、乘积小于K的子数组"></a><font color="orange">9、乘积小于K的子数组</font></h2><p>给定一个正整数数组 <code>nums</code>和整数 <code>k</code> ，请找出该数组内乘积小于 <code>k</code> 的连续的子数组的个数。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: nums = [10,5,2,6], k = 100</span><br><span class="line">输出: 8</span><br><span class="line">解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。</span><br><span class="line">需要注意的是 [10,5,2] 并不是乘积小于100的子数组。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: nums = [1,2,3], k = 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></div>

<p><strong>提示:</strong></p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 10^4</li>
<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li>
<li>0 &lt;&#x3D; k &lt;&#x3D; 10^6^</li>
</ul>
<p>注意：本题与主站 713 题相同：<a class="link"   href="https://leetcode-cn.com/problems/subarray-product-less-than-k/" >https://leetcode-cn.com/problems/subarray-product-less-than-k/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>这类题肯定是双指针做，但这里最大的问题是重复，没有太好的思路。</p>
<p>看了别人的解法，算是归纳出了一个公式？。。</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarrayProductLessThanK</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span> ||k==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            total *= nums[right];</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; total &gt;= k) &#123;</span><br><span class="line">                total /= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                ret += right - left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="10、和为K的子数组"><a href="#10、和为K的子数组" class="headerlink" title="10、和为K的子数组"></a><font color="orange">10、和为K的子数组</font></h2><p>给定一个整数数组和一个整数 <code>k</code> <strong>，</strong>请找到该数组中和为 <code>k</code> 的连续子数组的个数。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入:nums = [1,1,1], k = 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 此题 [1,1] 与 [1,1] 为两种不同的情况</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入:nums = [1,2,3], k = 3</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></div>

<p><strong>提示:</strong></p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 10^4</li>
<li>-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li>
<li>-10^7 &lt;&#x3D; k &lt;&#x3D; 10^7</li>
</ul>
<p>注意：本题与主站 560 题相同： <a class="link"   href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" >https://leetcode-cn.com/problems/subarray-sum-equals-k/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note success"><h3 id="滑动窗口适用场景"><a href="#滑动窗口适用场景" class="headerlink" title="滑动窗口适用场景"></a>滑动窗口适用场景</h3><p>如求和为k的数组，如果要使用滑动窗口，那么必须满足这个条件：</p>
<p>当大指针移动后，和必须永远变大&#x2F;变小，小指针移动后，和必须永远变小&#x2F;变大</p>
</div>

<div class="note success"><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>设数组nums&#x3D;[1，5，2，-3]</p>
<p>那么数组的前缀和S&#x3D;[1，6，8，5]，即S[0] &#x3D; nums[0]，S[1] &#x3D; nums[0] + nums[1]，…</p>
<p>求前缀和很简单，那这玩意有什么用？怎么用？</p>
<p>如果我们要求num[2] + nums[3]，那么就是S[3] - S[1]</p>
<p>假设需要找和为4的子数组，就可以跟据前缀和来找：</p>
<ol>
<li>第一位1，S&#x3D;1，找之前的前缀和中有没有等于-3的，没有。<font color="#1e9fff">为什么是-3？S1(为1) - S2 &#x3D; 4，所以S2 &#x3D; -3</font></li>
<li>第二位5，S&#x3D;6，找之前的前缀和中有没有等于2的，没有</li>
<li>第三位2，S&#x3D;8，找之前的前缀和中有没有等于4的，没有</li>
<li>第四位-3，S&#x3D;5，找之前的前缀和中有没有等于1的，有</li>
</ol>
</div>

<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>连续6道类似的题了，第一想法就是双指针形成滑动窗口，但后来发现不行！</p>
<p>而在这里，因为数组是无序的，自然没办法满足滑动窗口的适用场景</p>
<p>这里引入一个之前没接触过的思路，前缀和</p>
<p>有了前缀和后，本题就基于前缀和来做，不过因为需要获得所有的子数组数，还需要记录每个前缀和出现的次数</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 存入0，即从头到该节点这种情况</span></span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">// 求前缀和</span></span><br><span class="line">            sum += num;</span><br><span class="line">            count += map.getOrDefault(sum - k, <span class="number">0</span>);</span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="11、连续数组"><a href="#11、连续数组" class="headerlink" title="11、连续数组"></a><font color="orange">11、连续数组</font></h2><p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: nums = [0,1]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: nums = [0,1,0]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</li>
<li><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></li>
</ul>
<p>注意：本题与主站 525 题相同： <a class="link"   href="https://leetcode-cn.com/problems/contiguous-array/" >https://leetcode-cn.com/problems/contiguous-array/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>不满足滑动窗口的条件</p>
<p>将0赋为-1，问题就转化成了最长连续子数组且和为0，利用前缀和求解</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// key为前缀和，value为下标</span></span><br><span class="line">        map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                num = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += num;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(sum))&#123;</span><br><span class="line">                max = Math.max(max, i - map.get(sum));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(sum, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="12、寻找数组的中心下标"><a href="#12、寻找数组的中心下标" class="headerlink" title="12、寻找数组的中心下标"></a><font color="green">12、寻找数组的中心下标</font></h2><p>给你一个整数数组 <code>nums</code> ，请计算数组的 <strong>中心下标</strong> 。</p>
<p>数组 <strong>中心下标</strong> 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p>
<p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p>
<p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,7,3,6,5,6]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">中心下标是 3 。</span><br><span class="line">左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，</span><br><span class="line">右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1, 2, 3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">数组中不存在满足此条件的中心下标。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [2, 1, -1]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">中心下标是 0 。</span><br><span class="line">左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），</span><br><span class="line">右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4</li>
<li>-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li>
</ul>
<p>注意：本题与主站 724 题相同： <a class="link"   href="https://leetcode-cn.com/problems/find-pivot-index/" >https://leetcode-cn.com/problems/find-pivot-index/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>使用前缀和来解，但有两种特殊情况：</p>
<ul>
<li>第一位就是中心数，此时最后一位的前缀和-第一位前缀和&#x3D;0</li>
<li>最后一位是中心数，此时倒数第二位的前缀和 &#x3D; 0</li>
</ul>
<p>排除特殊情况后，第i位前缀和 + 第i+1位前缀和&#x3D;最后一位前缀和时，第i+1位就是中心数</p>
<p>另外题目要求最左边的中心数，也就是先判断特殊情况1，再正常遍历，最后判断特殊情况2</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        sum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 计算前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先检查第一个元素是否就是中心数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightSum</span> <span class="operator">=</span> sum[sum.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (rightSum - sum[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 依次检查每个前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; sum.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum[j] + sum[j + <span class="number">1</span>] == rightSum) &#123;</span><br><span class="line">                <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查最后一个数是否是中心数</span></span><br><span class="line">        <span class="keyword">if</span> (sum[sum.length - <span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum.length - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="13、二维区域和检索-矩阵不可变"><a href="#13、二维区域和检索-矩阵不可变" class="headerlink" title="13、二维区域和检索-矩阵不可变"></a><font color="orange">13、二维区域和检索-矩阵不可变</font></h2><p>给定一个二维矩阵 <code>matrix</code>，以下类型的多个请求：</p>
<ul>
<li>计算其子矩形范围内元素的总和，该子矩阵的左上角为 <code>(row1, col1)</code> ，右下角为 <code>(row2, col2)</code> 。</li>
</ul>
<p>实现 <code>NumMatrix</code> 类：</p>
<ul>
<li><code>NumMatrix(int[][] matrix)</code> 给定整数矩阵 <code>matrix</code> 进行初始化</li>
<li><code>int sumRegion(int row1, int col1, int row2, int col2)</code> 返回左上角 <code>(row1, col1)</code> 、右下角 <code>(row2, col2)</code> 的子矩阵的元素总和。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="../../../images/LCR13.png"
                      alt="img" style="zoom:50%;" 
                >

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: </span><br><span class="line">[&quot;NumMatrix&quot;,&quot;sumRegion&quot;,&quot;sumRegion&quot;,&quot;sumRegion&quot;]</span><br><span class="line">[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]</span><br><span class="line">输出: </span><br><span class="line">[null, 8, 11, 12]</span><br><span class="line">解释:</span><br><span class="line">NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]]);</span><br><span class="line">numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)</span><br><span class="line">numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)</span><br><span class="line">numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li>m &#x3D;&#x3D; matrix.length</li>
<li>n &#x3D;&#x3D; matrix[i].length</li>
<li>1 &lt;&#x3D; m, n &lt;&#x3D; 200</li>
<li>-10^5 &lt;&#x3D; matrix[i] [j] &lt;&#x3D; 10^5</li>
<li>0 &lt;&#x3D; row1 &lt;&#x3D; row2 &lt; m</li>
<li>0 &lt;&#x3D; col1 &lt;&#x3D; col2 &lt; n</li>
<li>最多调用 10^4 次 <code>sumRegion</code> 方法</li>
</ul>
<p>注意：本题与主站 304 题相同： <a class="link"   href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/" >https://leetcode-cn.com/problems/range-sum-query-2d-immutable/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>二维数组版的前缀和</p>
<p>前缀和计算公式：S(2,3) &#x3D; N(2,3) + S(1,3) + S(2,2) - S(1,2)</p>
<p>前缀和使用公式，如计算(1,1)、(2,3)之间的和，SUM &#x3D; S(2,3) - S(1,3) - S(2,2) + S(1,2)</p>
<p>另外前缀和使用时，注意边界点时，越界的情况即可</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] prefixSum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumMatrix</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        prefixSum = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">        prefixSum[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            prefixSum[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] + prefixSum[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; col; i++) &#123;</span><br><span class="line">            prefixSum[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i] + prefixSum[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">                prefixSum[i][j] = matrix[i][j] + prefixSum[i - <span class="number">1</span>][j] + prefixSum[i][j - <span class="number">1</span>] - prefixSum[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row1 == <span class="number">0</span> &amp;&amp; col1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> prefixSum[row2][col2];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (row1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> prefixSum[row2][col2] - prefixSum[row2][col1 - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (col1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> prefixSum[row2][col2] - prefixSum[row1 - <span class="number">1</span>][col2];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> prefixSum[row2][col2] - prefixSum[row1 - <span class="number">1</span>][col2] - prefixSum[row2][col1 - <span class="number">1</span>] + prefixSum[row1 - <span class="number">1</span>][col1 - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="14、字符串的排列"><a href="#14、字符串的排列" class="headerlink" title="14、字符串的排列"></a><font color="orange">14、字符串的排列</font></h2><p>给定两个字符串 <code>s1</code> 和 <code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的某个变位词。</p>
<p>换句话说，第一个字符串的排列之一是第二个字符串的 <strong>子串</strong> 。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; s1.length, s2.length &lt;&#x3D; 10^4</li>
<li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li>
</ul>
<p>注意：本题与主站 567 题相同： <a class="link"   href="https://leetcode-cn.com/problems/permutation-in-string/" >https://leetcode-cn.com/problems/permutation-in-string/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>做一个长度为s1的滑动窗口，统计两个字符串的每个字符出现的次数，当出现两个数组完全一致时，即出现变位词</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s2.length();</span><br><span class="line">        <span class="keyword">if</span>(m &gt; n)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span>[] cnt1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] cnt2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt1[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">            cnt2[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Arrays.equals(cnt1, cnt2))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt2[s2.charAt(i - m) - <span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">            cnt2[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">            <span class="keyword">if</span>(Arrays.equals(cnt1, cnt2))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="15、找到字符串中所有的异位词"><a href="#15、找到字符串中所有的异位词" class="headerlink" title="15、找到字符串中所有的异位词"></a><font color="orange">15、找到字符串中所有的异位词</font></h2><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>变位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p><strong>变位词</strong> 指字母相同，但排列不同的字符串。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的变位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的变位词。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的变位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的变位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的变位词。</span><br></pre></td></tr></table></figure></div>

<p><strong>提示:</strong></p>
<ul>
<li>1 &lt;&#x3D; s.length, p.length &lt;&#x3D; 3 * 10^4</li>
<li><code>s</code> 和 <code>p</code> 仅包含小写字母</li>
</ul>
<p>注意：本题与主站 438 题相同： <a class="link"   href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" >https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>和上题类似，判断变位词的方式可以直接沿用，区别是需要执行完循环，并返回变位词的开始下标</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> p.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">big</span> <span class="operator">=</span> s.length();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (small &gt; big) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] cnt1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] cnt2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; small; i++) &#123;</span><br><span class="line">            cnt1[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            cnt2[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Arrays.equals(cnt1, cnt2))&#123;</span><br><span class="line">            list.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> small; i &lt; big; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt1[s.charAt(i - small) - <span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">            cnt1[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">            <span class="keyword">if</span>(Arrays.equals(cnt1, cnt2))&#123;</span><br><span class="line">                list.add(i - small + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="16、无重复字符的最长字串"><a href="#16、无重复字符的最长字串" class="headerlink" title="16、无重复字符的最长字串"></a><font color="orange">16、无重复字符的最长字串</font></h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长连续子字符串</strong> 的长度。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子字符串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子字符串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br><span class="line">     </span><br><span class="line">示例 4:</span><br><span class="line">输入: s = &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 10^4</li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<p>注意：本题与主站 3 题相同： <a class="link"   href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" >https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>记录每个元素出现的下标，如果出现重复则记录后者</p>
<p>起点指针记录离当前指针最近的重复元素：如dacbdefg，那么当遍历到第二个d时，起点指针指向第一个d</p>
<p>那么长度就是当前指针-起点指针，最终取最大值返回</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//把当前 字符与其下标存入map</span></span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 定义一个指针 每次都指向与遍历右指针最近的那个重复元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">choose_right</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">                <span class="comment">//如果存在重复元素 获取该元素下标 获取与right距离最近的重复元素</span></span><br><span class="line">                choose_right = Math.max(choose_right,map.get(c));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把重复元素存进当前位置</span></span><br><span class="line">            map.put(c,right);</span><br><span class="line">            <span class="comment">//当前重复元素位置减掉最近的重复元素位置 得到该段距离长度</span></span><br><span class="line">            res = Math.max(res,right - choose_right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="17、最小覆盖子串"><a href="#17、最小覆盖子串" class="headerlink" title="17、最小覆盖子串"></a><font color="red">17、最小覆盖子串</font></h2><p>给定两个字符串 <code>s</code> 和 <code>t</code> 。返回 <code>s</code> 中包含 <code>t</code> 的所有字符的最短子字符串。如果 <code>s</code> 中不存在符合条件的子字符串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p>如果 <code>s</code> 中存在多个符合条件的子字符串，返回任意一个。</p>
<p><strong>注意：</strong> 对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot; </span><br><span class="line">解释：最短子字符串 &quot;BANC&quot; 包含了字符串 t 的所有字符 &#x27;A&#x27;、&#x27;B&#x27;、&#x27;C&#x27;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 10^5</li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
<p><strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</p>
<p>注意：本题与主站 76 题相似（本题答案不唯一）：<a class="link"   href="https://leetcode-cn.com/problems/minimum-window-substring/" >https://leetcode-cn.com/problems/minimum-window-substring/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large red"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>尝试使用滑动窗口解决，即当前窗口内的目标元素数量小于目标字符串则扩大窗口，反之则缩小窗口，并记录最短的子串</p>
<p>元素数量使用map来记录</p>
<p>实现之后发现效率不高，只击败了13%的用户，看到有人写出了仅1ms的答案，看了一下暂时没理解，等后续再遇到这道题再看吧</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; tMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tc</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> tMap.getOrDefault(tc, <span class="number">0</span>);</span><br><span class="line">            tMap.put(tc, ++count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> <span class="number">0</span>,big = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; sMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        sMap.put(s.charAt(big), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(big &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(check(tMap, sMap))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">newLength</span> <span class="operator">=</span> big - small + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(newLength &lt; minLength)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(big == small)&#123;</span><br><span class="line">                        <span class="keyword">return</span> s.substring(small, big + <span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        minLength = newLength;</span><br><span class="line">                        result = s.substring(small, big + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> sMap.get(s.charAt(small));</span><br><span class="line">                sMap.put(s.charAt(small), --integer);</span><br><span class="line">                small++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                big++;</span><br><span class="line">                <span class="keyword">if</span>(big == s.length())&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">sc</span> <span class="operator">=</span> s.charAt(big);</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> sMap.getOrDefault(sc, <span class="number">0</span>);</span><br><span class="line">                sMap.put(sc, ++integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(Map&lt;Character, Integer&gt; tMap, Map&lt;Character, Integer&gt; sMap)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : tMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">sCount</span> <span class="operator">=</span> sMap.getOrDefault(entry.getKey(), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(sCount &lt; entry.getValue())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="18、验证回文串"><a href="#18、验证回文串" class="headerlink" title="18、验证回文串"></a><font color="green">18、验证回文串</font></h2><p>给定一个字符串 <code>s</code> ，验证 <code>s</code> 是否是 <strong>回文串</strong> ，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>本题中，将空字符串定义为有效的 <strong>回文串</strong> 。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: s = &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释：&quot;amanaplanacanalpanama&quot; 是回文串</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s = &quot;race a car&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释：&quot;raceacar&quot; 不是回文串</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; s.length &lt;&#x3D; 2 * 10^5</li>
<li>字符串 <code>s</code> 由 ASCII 字符组成</li>
</ul>
<p>注意：本题与主站 125 题相同： <a class="link"   href="https://leetcode-cn.com/problems/valid-palindrome/" >https://leetcode-cn.com/problems/valid-palindrome/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>回文串的判断很简单，两个指针分别从首尾相向遍历，如果出现不一样的就可以认定不是回文串</p>
<p>但这里还在此基础上增加了两点</p>
<ol>
<li>需要排除掉除数字大小写字母之外的字符，这个跟据ASCII码来判断</li>
<li>需要忽略大小写，根据ASCII码值的差是否等于32，但是这里有特例如0P，其差值也是32，需要排除数字的情况</li>
</ol>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 空字符串默认回文串</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指针分别指向首尾</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> <span class="number">0</span>, big = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (small &lt; big) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">cSmall</span> <span class="operator">=</span> s.charAt(small);</span><br><span class="line">            <span class="type">char</span> <span class="variable">cBig</span> <span class="operator">=</span> s.charAt(big);</span><br><span class="line">            <span class="comment">// 先判断元素是否需要跳过，只有字母和数字保留</span></span><br><span class="line">            <span class="keyword">if</span> (isIgnoreChar(cSmall)) &#123;</span><br><span class="line">                small++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isIgnoreChar(cBig)) &#123;</span><br><span class="line">                big--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查是否符合回文要求</span></span><br><span class="line">            <span class="keyword">if</span> (checkEquals(cSmall, cBig)) &#123;</span><br><span class="line">                small++;</span><br><span class="line">                big--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只有数字大小写字母保留</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isIgnoreChar</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果相等直接返回</span></span><br><span class="line"><span class="comment">     * 如果不相等且其中有一个数字，则必定不相等</span></span><br><span class="line"><span class="comment">     * 如果均为字母且ascii码相差32则会同个字母的大小写，返回相等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkEquals</span><span class="params">(<span class="type">char</span> c1, <span class="type">char</span> c2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((c1 &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c1 &lt;= <span class="string">&#x27;9&#x27;</span>) || (c2 &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c2 &lt;= <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(c1 - c2) == <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="19、验证回文串Ⅱ"><a href="#19、验证回文串Ⅱ" class="headerlink" title="19、验证回文串Ⅱ"></a><font color="green">19、验证回文串Ⅱ</font></h2><p>给定一个非空字符串 <code>s</code>，请判断如果 <strong>最多</strong> 从字符串中删除一个字符能否得到一个回文字符串。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: s = &quot;aba&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s = &quot;abca&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可以删除 &quot;c&quot; 字符 或者 &quot;b&quot; 字符</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: s = &quot;abc&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></div>

<p><strong>提示:</strong></p>
<ul>
<li>1 &lt;&#x3D; s.length &lt;&#x3D; 10^5</li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<p>注意：本题与主站 680 题相同： <a class="link"   href="https://leetcode-cn.com/problems/valid-palindrome-ii/" >https://leetcode-cn.com/problems/valid-palindrome-ii/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>最直接的想法，当遇到不一样的元素时，小指针往后，如果还不一样，就大指针往前。但还是发生了最怕的问题：</p>
<p>就是两个指针移动都暂时满足回文，取了一种处理后，发现不是回文了！但其实另一种处理是回文</p>
<p>于是想到了类似递归的手法：先遍历直到出现不一致元素，然后再利用方法的局部变量分别检查小指针后移、大指针前移两种是否是回文串。这样子处理可以避免回滚指针的问题</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> <span class="number">0</span>,big = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(small &lt; big)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">cSmall</span> <span class="operator">=</span> s.charAt(small);</span><br><span class="line">            <span class="type">char</span> <span class="variable">cBig</span> <span class="operator">=</span> s.charAt(big);</span><br><span class="line">            <span class="keyword">if</span>(cSmall == cBig)&#123;</span><br><span class="line">                --big;</span><br><span class="line">                ++small;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> check(s, small + <span class="number">1</span>, big) || check(s, small, big - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String s, <span class="type">int</span> small ,<span class="type">int</span> big)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(small &lt; big)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">cSmall</span> <span class="operator">=</span> s.charAt(small);</span><br><span class="line">            <span class="type">char</span> <span class="variable">cBig</span> <span class="operator">=</span> s.charAt(big);</span><br><span class="line">            <span class="keyword">if</span>(cSmall != cBig) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --big;</span><br><span class="line">                ++small;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="20、回文子串"><a href="#20、回文子串" class="headerlink" title="20、回文子串"></a><font color="orange">20、回文子串</font></h2><p>给定一个字符串 <code>s</code> ，请计算这个字符串中有多少个回文子字符串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<p>注意：本题与主站 70 题相同：<a class="link"   href="https://leetcode-cn.com/problems/palindromic-substrings/" >https://leetcode-cn.com/problems/palindromic-substrings/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>第一感觉是没有思路，这个反应问题很大，代表我们刷的题型还不够，或者还没有融汇贯通</p>
<p>然后看到相关词条里有动态规划，立刻想到了一种方法：</p>
<ul>
<li>每加入一个元素，就从该元素开始往前遍历所有元素，找到加入该元素后新出现的回文子串</li>
<li>但这个方案，时间复杂度很不理想，为O(n^3^)</li>
</ul>
<p>看别人的思路，了解到一种中心遍历法，依次遍历每个元素并以该元素为回文中心，往两边遍历，需要注意奇回文串和偶回文串的情况，时间复杂度为O(n^2^)</p>
<p>但今天状态很差，实在不想去深入理解了，先记在这，后续遇到类似题了再自己来实现</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i / <span class="number">2</span>, r = i / <span class="number">2</span> + i % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offerⅡ</category>
      </categories>
  </entry>
  <entry>
    <title>剑指Offer_Part.1</title>
    <url>/2023/05/10/algorithm/offer/%E5%89%91%E6%8C%87Offer_Part1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大学时刷过一段时间的算法题，但那时候对编程的理解不深，且疏于总结和记录，以至于几年后对算法题这块已经忘的精光了。工作两年，这段时间里也一直有学习一些内容，但过一段时间就又忘记了。为此，特地搭了一个博客，专门记录学习的过程，争取做到笔记分类分明、内容快速检索。</p>
<p>针对算法题这块，分类上属于<code>算法题</code>大类，标签上分为<code>算法基础提升</code>、<code>算法专项突破</code>和<code>算法难题巩固</code></p>
<p>本篇是算法基础提升的第一篇，通过剑指Offer和剑指OfferⅡ(LCR)，对各类算法做一个初步的认知以及找到一些解题的通用思路，算是打基础</p>
<h2 id="03、数组中重复的数字"><a href="#03、数组中重复的数字" class="headerlink" title="03、数组中重复的数字"></a><font color="green">03、数组中重复的数字</font></h2><p>找出数组中重复的数字</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">2 &lt;= n &lt;= 100000</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><ol>
<li>将数组排序O(N*logN)，并遍历O(N)，找出当前位置和后一个位置相等的元素</li>
<li>空间换时间，使用哈希表来做</li>
</ol>
<p>相比之下认为哈希表效率更佳，使用HashSet即可快速解决</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(num)) &#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="04、二维数组中的查找"><a href="#04、二维数组中的查找" class="headerlink" title="04、二维数组中的查找"></a><font color="orange">04、二维数组中的查找</font></h2><p>在一个n*m的二维数组中，每一行都按照从左到右 <strong>非递减</strong> 的顺序排序，每一列都按照从上到下 <strong>非递减</strong> 的顺序排序</p>
<p>请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">现有矩阵 matrix 如下：</span><br><span class="line">[</span><br><span class="line">  [1,  4,  7,  11, 15],</span><br><span class="line">  [2,  5,  8,  12, 19],</span><br><span class="line">  [3,  6,  9,  16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target = 5，返回 true</span><br><span class="line">给定 target = 20，返回 false</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">0 &lt;= n &lt;= 1000</span><br><span class="line">0 &lt;= m &lt;= 1000</span><br></pre></td></tr></table></figure></div>

<p><strong>注意</strong>：本题与主站 240 题相同：<a class="link"   href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" >https://leetcode-cn.com/problems/search-a-2d-matrix-ii/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>二分查找的另类实现</p>
<ul>
<li>首先普通二分查找的前提：待查找的数据必须按照一定的顺序排列</li>
<li>其次二分查找有一个中间值，跟据中间值和目标的大小关系缩小查找范围</li>
</ul>
<p>那么我们只需要将上述的<font color="#16b777">顺序</font>、<font color="#16b777">中间值</font>和<font color="#16b777">缩小范围</font>在二维数组中对应到即可</p>
<ul>
<li>顺序，这个是最难想到的点。从左下角或者右上角作为起点，以左下角为例，中间值的上边部分都是小值，右边部分都是大值。如左上角，下边和右边的值均比中间值大，这样就没办法二分</li>
<li>中间值，即左下角或右上角</li>
<li>缩小范围，以左下角为例。若中间值&gt;目标值则上移，若中间值&lt;目标值则右移</li>
</ul>
<p>找到了这些概念，剩下的就是循环的终止条件，比较简单。当循环的数组下标超过数组范围时，或者找到目标值时终止循环</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取数组列数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">column</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (column == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化循环的行列，从最后一行第一列开始，即左下角</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当i=-1，或者j=column(即超出数组范围)，或者找到目前值时终止循环</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; column) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">                <span class="comment">// 当前值大于目标值时，向上移</span></span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前值小于目标值时，向右移</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="05、替换空格"><a href="#05、替换空格" class="headerlink" title="05、替换空格"></a><font color="green">05、替换空格</font></h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">0 &lt;= s 的长度 &lt;= 10000</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>字符串替换，最直接的实现是JDK提供的String.replace：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> s.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;%20&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>但要注意，String.replace是<font color="#dd0000">使用正则表达式来实现的，性能不佳</font>。如果可以，尽量使用Apache commons lang里的StringUtils.replace系列方法来代替</p>
<p>其次，可以使用StringBuilder或者char数组自己来实现一个简易版的替换，这里使用StringBuilder</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定初始容量，可以避免发生扩容</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s.length() * <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="06、从尾到头打印链表"><a href="#06、从尾到头打印链表" class="headerlink" title="06、从尾到头打印链表"></a><font color="green">06、从尾到头打印链表</font></h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">0 &lt;= 链表长度 &lt;= 10000</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>有两个想法</p>
<ol>
<li>借由栈来做，先把元素压入栈中，再以此出栈</li>
<li>使用数组，先保存正序再翻转数组</li>
</ol>
<p>由于Java中的栈基于Vertor来实现，不推荐使用，使用ArrayList来实现</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">            list.add(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[j++] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="07、重建二叉树"><a href="#07、重建二叉树" class="headerlink" title="07、重建二叉树"></a><font color="orange">07、重建二叉树</font></h2><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p>
<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/offer07.jpg"
                      alt="img"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">Input: preorder = [-1], inorder = [-1]</span><br><span class="line">Output: [-1]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">0 &lt;= 节点个数 &lt;= 5000</span><br></pre></td></tr></table></figure></div>

<p><strong>注意</strong>：本题与主站 105 题重复：<a class="link"   href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" >https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>主要是考察二叉树的前中后序遍历，以及递归。因为二叉树的结构，往往二叉树遍历相关的都离不开递归</p>
<p>将两个数组划分为3个部分：</p>
<p>通过preorder可以快速定位到根节点，再通过该跟节点可以在inorder中获取左子树部分和右子树部分</p>
<p>通过递归再分别从左子树和右子树中建立二叉树即可</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, inorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preEnd || inStart &gt; inEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> preorder[preStart];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="comment">//查找根节点在中序遍历的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> inStart;i &lt;= inEnd;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == val)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - inStart;</span><br><span class="line">        node.left = build(preorder, inorder, preStart + <span class="number">1</span>, preStart + leftSize, inStart, index - <span class="number">1</span>);</span><br><span class="line">        node.right = build(preorder, inorder, preStart + leftSize + <span class="number">1</span>, preEnd, index + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="09、用两个栈实现队列"><a href="#09、用两个栈实现队列" class="headerlink" title="09、用两个栈实现队列"></a><font color="green">09、用两个栈实现队列</font></h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[],[]]</span><br><span class="line">输出：[null,null,3,-1,-1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">- 1 &lt;= values &lt;= 10000</span><br><span class="line">- 最多会对appendTail、deleteHead进行 10000 次调用</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>队列的特性是先入先出，栈则是先入后出，正好相反</p>
<p>因此可以设置一个输入栈和一个输出栈，输入全部放在输入栈中。关键是输出时：</p>
<ol>
<li>当输出栈内有值时直接取出</li>
<li>当输出栈为空时，从输入栈获取，此时输出栈内的顺序符合队列特性</li>
<li>两个栈均为空，按题意返回-1</li>
</ol>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Stack&lt;Integer&gt; in;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Stack&lt;Integer&gt; out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        in = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        out = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        in.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(in.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!in.isEmpty())&#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="10-1、斐波那契数列"><a href="#10-1、斐波那契数列" class="headerlink" title="10-1、斐波那契数列"></a><font color="green">10-1、斐波那契数列</font></h2><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure></div>

<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;= n &lt;= 100</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>因为斐波那契数列明显符合递归特征，使用递归实现最简单，但存在重复计算，如果使用数组来做记忆化又需要花费数组的空间</p>
<p>因此使用循环来做</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fn1</span> <span class="operator">=</span> <span class="number">1</span>,fn2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum = (fn1 + fn2) % <span class="number">1000000007</span>;</span><br><span class="line">            fn2 = fn1;</span><br><span class="line">            fn1 = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="10-2、青蛙跳台阶问题"><a href="#10-2、青蛙跳台阶问题" class="headerlink" title="10-2、青蛙跳台阶问题"></a><font color="green">10-2、青蛙跳台阶问题</font></h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;= n &lt;= 100</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 70 题相同：<a class="link"   href="https://leetcode-cn.com/problems/climbing-stairs/" >https://leetcode-cn.com/problems/climbing-stairs/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>和10-1一样，都是斐波那契数列，只是将问题抽象了一下，需要先理解后关联到斐波那契数列</p>
<p>区别在于f(0)&#x3D;1</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fn1</span> <span class="operator">=</span> <span class="number">1</span>,fn2 = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum = (fn1 + fn2) % <span class="number">1000000007</span>;</span><br><span class="line">            fn2 = fn1;</span><br><span class="line">            fn1 = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="11、旋转数组的最小数字"><a href="#11、旋转数组的最小数字" class="headerlink" title="11、旋转数组的最小数字"></a><font color="green">11、旋转数组的最小数字</font></h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>
<p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>numbers</code> ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的<strong>最小元素</strong>。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一次旋转，该数组的最小值为 1。</p>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：numbers = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：numbers = [2,2,2,0,1]</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">- n == numbers.length</span><br><span class="line">- 1 &lt;= n &lt;= 5000</span><br><span class="line">- -5000 &lt;= numbers[i] &lt;= 5000</span><br><span class="line">- numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 154 题相同：<a class="link"   href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" >https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>归结到底还是查找数组最小值，通过的查找方法也适用</p>
<p>跟据题意，数组是升序-&gt;最小值-&gt;升序的规律，那么只需要拿第一个值记作n，遍历数组，出现的第一个小于n的数字即为最小值</p>
<p>特殊情况，遍历一遍没有发现比n小的数字，那么n就是最小值</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] &lt; first)&#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="12、矩阵中的路径"><a href="#12、矩阵中的路径" class="headerlink" title="12、矩阵中的路径"></a><font color="orange">12、矩阵中的路径</font></h2><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/offer12.jpg"
                      alt="img"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">- m == board.length</span><br><span class="line">- n = board[i].length</span><br><span class="line">- 1 &lt;= m, n &lt;= 6</span><br><span class="line">- 1 &lt;= word.length &lt;= 15</span><br><span class="line">- board 和 word 仅由大小写英文字母组成</span><br></pre></td></tr></table></figure></div>

<p><strong>注意</strong>：本题与主站 79 题相同：<a class="link"   href="https://leetcode-cn.com/problems/word-search/" >https://leetcode-cn.com/problems/word-search/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>首先找到目标字符串首字母的格子，再遍历周边是否有第二个字母的格子，主要是终止条件的设置</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> n, m, len;</span><br><span class="line">    <span class="type">boolean</span>[][] f;</span><br><span class="line">    <span class="type">char</span>[] s;</span><br><span class="line">    <span class="type">char</span>[][] b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        b = board;</span><br><span class="line">        s = word.toCharArray();</span><br><span class="line">        <span class="comment">// 目标串的长度</span></span><br><span class="line">        len = s.length;</span><br><span class="line">        n = board.length;</span><br><span class="line">        m = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 标记搜索的过程中格子是否被使用过</span></span><br><span class="line">        f = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到与目标串第一个字符相同的格子，开始搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n ; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[<span class="number">0</span>] == board[i][j])&#123;</span><br><span class="line">                    f[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    dfs(<span class="number">1</span>, i, j);</span><br><span class="line">                    f[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 每次搜索后判断是否已经找到</span></span><br><span class="line">                <span class="keyword">if</span>(res)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// u == len 终止条件</span></span><br><span class="line">        <span class="comment">// res  如果已经找到，则直接return (剪枝)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里要加res的原因主要是为了剪去不需要的搜索</span></span><br><span class="line">        <span class="comment">// 这里是优化了后面代码中的一个dfs搜索</span></span><br><span class="line">        <span class="comment">// 如果在某一次循环中找到了结果，就直接退出</span></span><br><span class="line">        <span class="comment">// 如果没加上res判断，由于要判断四个方格，程序会继续判断下一个方格，这里就是无用的搜索，直接剪去即可</span></span><br><span class="line">        <span class="keyword">if</span>(u == len || res)&#123;</span><br><span class="line">            res = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方向数组</span></span><br><span class="line">        <span class="type">int</span>[] dx = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;, dy = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>; d &lt; <span class="number">4</span>; d ++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i + dx[d], y = j + dy[d];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 坐标越界 或者 当前格子已经被使用了  就直接结束此次循环</span></span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= n || y &gt;= m || f[x][y])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(b[x][y] == s[u])&#123;</span><br><span class="line">                <span class="comment">// 标记被使用</span></span><br><span class="line">                f[x][y] = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 这里找到答案回溯后，下一个循环会继续进入dfs函数</span></span><br><span class="line">                <span class="comment">// 也就是在下一个循环做无用的搜索，这里也是为什么要判断res的原因</span></span><br><span class="line">                <span class="comment">// 或者你可以在这行代码之后判断res，然后退出</span></span><br><span class="line">                dfs(u + <span class="number">1</span>, x, y);</span><br><span class="line">                <span class="comment">// 恢复现场</span></span><br><span class="line">                f[x][y] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="note success"><h3 id="知识点1、数组迷宫类遍历"><a href="#知识点1、数组迷宫类遍历" class="headerlink" title="知识点1、数组迷宫类遍历"></a>知识点1、数组迷宫类遍历</h3><p>使用以下语句即可清晰的依次遍历格子的上下左右4个临格，如果要遍历周边包括对角的8个格子也是同理的</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] dx = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;, dy = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// d的值为[0,3]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i + dx[d], y = j + dy[d];</span><br></pre></td></tr></table></figure></div>
</div>

<h2 id="13、机器人的运动范围"><a href="#13、机器人的运动范围" class="headerlink" title="13、机器人的运动范围"></a><font color="orange">13、机器人的运动范围</font></h2><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0] </code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：m = 2, n = 3, k = 1</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：m = 3, n = 1, k = 0</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">- 1 &lt;= n,m &lt;= 100</span><br><span class="line">- 0 &lt;= k &lt;= 20</span><br></pre></td></tr></table></figure></div>

<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>这一题相当于我们在一个矩阵中找到合适的点，求得总共有多少点即可</p>
<ul>
<li>我们从（0，0）出发，首先需要满足的是在“矩阵”中，并且行坐标和列坐标的数位之和必须小于等于k,（base case）</li>
<li>如果满足上述条件，说明这个格子符合题意，我们直接res++</li>
<li>然后我们只需要调用我们的dfs函数，向他的上下左右四个方向分别寻找即可。</li>
</ul>
<p>如果我们直接这样做，肯定会导致时间超出，因为我们没有做“剪枝”处理，我们走过的路肯定不能重复走啊对吧。所以我们需要标记我们走过的路，显然一个二维的Boolean类型的数组最为合适。我们只需要在走过之后，把当前坐标对应的数组的坐标置为true，下次判断前，我们先判断是否走过这条路即可</p>
<p>这一类问题主要就是2个点：</p>
<ul>
<li>递归</li>
<li>剪枝</li>
</ul>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//用来做标记的数组</span></span><br><span class="line">        <span class="type">boolean</span>[][] arr = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,m,n,k,arr);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j,<span class="type">int</span> m,<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">boolean</span>[][] arr)</span>&#123;</span><br><span class="line">        <span class="comment">//基本判断 + 判断是否走过这条路</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || i &lt; <span class="number">0</span> || j &gt;= n || j &lt; <span class="number">0</span> || arr[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有走过，先标记，在判断是否符合题意</span></span><br><span class="line">        arr[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//求和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> i % <span class="number">10</span> + j % <span class="number">10</span> + i / <span class="number">10</span> + j / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; k)<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//符合题意数量+1</span></span><br><span class="line">        res ++;</span><br><span class="line">        <span class="comment">//直接大范围撒网</span></span><br><span class="line">        dfs(i+<span class="number">1</span>,j,m,n,k,arr);</span><br><span class="line">        dfs(i-<span class="number">1</span>,j,m,n,k,arr);</span><br><span class="line">        dfs(i,j+<span class="number">1</span>,m,n,k,arr);</span><br><span class="line">        dfs(i,j-<span class="number">1</span>,m,n,k,arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="14-1、剪绳子"><a href="#14-1、剪绳子" class="headerlink" title="14-1、剪绳子"></a><font color="orange">14-1、剪绳子</font></h2><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m-1]</code> 。请问 <code>k[0]*k[1]*...*k[m-1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">2 &lt;= n &lt;= 58</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 343 题相同：<a class="link"   href="https://leetcode-cn.com/problems/integer-break/" >https://leetcode-cn.com/problems/integer-break/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>有两种算法，动态规划和贪心算法，两者中贪心算法的效率往往更高：</p>
<ul>
<li>贪心算法不需要像动态规划一样保存所有的过程状态，只需要根据当前状态做出最优选择即可。这使得贪心算法的空间复杂度较低，且常常能够得到近似最优解</li>
<li>动态规划则需要将每一个可能的状态都保存下来，并且需要一个二维数组存储子问题的解，这使得它的空间复杂度较高，且常常需要较多的计算时间才能得到最优解</li>
</ul>
<p>因此，在求解问题时，如果能够通过贪心策略保证每一步的最优解也是全局最优解，那么贪心算法的效率通常优于动态规划算法</p>
<p>但是，贪心算法并不是所有问题的最优解，对于一些需要考虑多个子问题之间的关系的问题，动态规划仍然是更好的选择</p>
<p>而剪绳子，通过规律能发现，全部剪成2和3的小段，乘积是最大的。也就是说只需要每次剪2或3即可，即可以使用贪心算法</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 2和3时直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 大于3时，比较剪2和剪3哪个乘积更大</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(<span class="number">2</span> * dp[i - <span class="number">2</span>], <span class="number">3</span> * dp[i - <span class="number">3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="14-2、剪绳子Ⅱ"><a href="#14-2、剪绳子Ⅱ" class="headerlink" title="14-2、剪绳子Ⅱ"></a><font color="orange">14-2、剪绳子Ⅱ</font></h2><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m - 1]</code> 。请问 <code>k[0]*k[1]*...*k[m - 1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">2 &lt;= n &lt;= 1000</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 343 题相同：<a class="link"   href="https://leetcode-cn.com/problems/integer-break/" >https://leetcode-cn.com/problems/integer-break/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>和1的区别时n的范围更大了，因此int会越界。如果还是用1的代码，那么需要用BigInteger来做(不能边算边取模，因为涉及比较操作)</p>
<p>这里用贪心的另一个实现，有3切3，即可保证乘积最大</p>
<p>算法还是需要跟据题目的规律来做优化，通用的动态规划可以解决问题，但如果数据量一大很可能会不符合时间要求！</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            res *= <span class="number">3</span>;</span><br><span class="line">            res %= mod;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(res * n % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="15、二进制中1的个数"><a href="#15、二进制中1的个数" class="headerlink" title="15、二进制中1的个数"></a><font color="green">15、二进制中1的个数</font></h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a class="link"   href="http://en.wikipedia.org/wiki/Hamming_weight" >汉明重量 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)）。</p>
<p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</p>
<p>在 Java 中，编译器使用 <a class="link"   href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284" >二进制补码 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 11 (控制台输入 00000000000000000000000000001011)</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 128 (控制台输入 00000000000000000000000010000000)</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">输入必须是长度为 32 的 二进制串</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 191 题相同：<a class="link"   href="https://leetcode-cn.com/problems/number-of-1-bits/" >https://leetcode-cn.com/problems/number-of-1-bits/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>主要涉及位运算，简单回顾：</p>
<ol>
<li>n&amp;1，如果结果为1，说明n的末位是1；如果结果为0，说明n的末位是0</li>
<li>带符号右移（&gt;&gt;），无符号右移（&gt;&gt;&gt;）</li>
</ol>
<p>基于这些点，只需要依次判断n的末位后，执行无符号右移即可</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            res += n &amp; <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="16、数值的整数次方"><a href="#16、数值的整数次方" class="headerlink" title="16、数值的整数次方"></a><font color="orange">16、数值的整数次方</font></h2><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：x = 2.10000, n = 3</span><br><span class="line">输出：9.26100</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：x = 2.00000, n = -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 = 1/22 = 1/4 = 0.25</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">- -100.0 &lt; x &lt; 100.0</span><br><span class="line">- -2^31 &lt;= n &lt;= 2^31 -1</span><br><span class="line">- -10^4 &lt;= x^n &lt;= 10^4</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 50 题相同：<a class="link"   href="https://leetcode-cn.com/problems/powx-n/" >https://leetcode-cn.com/problems/powx-n/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>虽然题中有递归标签，但不能使用递归来做。原因是n的范围很大，如果用递归必会导致<code>StackOverflowError</code></p>
<p>于是尝试循环，但也不行，超时。因此普通的计算方法行不通，然后发现有一种方法快速幂</p>
</div></div>

<div class="note success"><h3 id="知识点2、快速幂"><a href="#知识点2、快速幂" class="headerlink" title="知识点2、快速幂"></a>知识点2、快速幂</h3><p>快速幂是一种用于计算幂的算法，相对于一般的幂运算方法，它可以极大地提高计算效率。</p>
<p>快速幂算法的基本思想是，将指数 n 认为是 2 进行二进制拆分，将底数不断平方，而每次将指数除以 2，这样可以在指数 n 的二进制表示中快速找到每一位对应的幂，从而得出最终的结果。这个算法的时间复杂度为 O(log n)。在计算机科学的一些场景中，比如密码学、图论、高精度运算等，快速幂都得到了广泛的应用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../images/offer16.png"
                      alt="image-20230523102430634"
                ></p>
</div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// n可能为-2^31，涉及取反操作，取反后依旧是原值导致错误，所以必须是long</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 最后一位为1，需要乘上该位上的权重</span></span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                res *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            b &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="17、打印从1到最大的n位数"><a href="#17、打印从1到最大的n位数" class="headerlink" title="17、打印从1到最大的n位数"></a><font color="green">17、打印从1到最大的n位数</font></h2><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: n = 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">- 用返回一个整数列表来代替打印</span><br><span class="line">- n 为正整数</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>只要找到最大值，然后从1开始遍历即可</p>
<p>最大值 &#x3D; 10^n -1，同时最大值也是数组的长度</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] printNumbers(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[(<span class="type">int</span>) Math.pow(<span class="number">10</span>, n) - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= res.length; i++) &#123;</span><br><span class="line">            res[i - <span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="18、删除链表的节点"><a href="#18、删除链表的节点" class="headerlink" title="18、删除链表的节点"></a><font color="green">18、删除链表的节点</font></h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p><strong>注意：</strong>此题对比原题有改动</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: head = [4,5,1,9], val = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: head = [4,5,1,9], val = 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">- 题目保证链表中节点的值互不相同</span><br><span class="line">- 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>遍历链表，找到目标节点n，修改其父节点p的next字段，p.next &#x3D; n.next</p>
<p><font color="orange">注意这里目标节点n也可能是头节点</font></p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">point</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span>(point.val == val)&#123;</span><br><span class="line">            head = point.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(point.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> point.next;</span><br><span class="line">            <span class="keyword">if</span>(next.val == val)&#123;</span><br><span class="line">                point.next = next.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            point = point.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="19、正则表达式匹配"><a href="#19、正则表达式匹配" class="headerlink" title="19、正则表达式匹配"></a><font color="red">19、正则表达式匹配</font></h2><p>请实现一个函数用来匹配包含<code>&#39;. &#39;</code>和<code>&#39;*&#39;</code>的正则表达式。模式中的字符<code>&#39;.&#39;</code>表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: s = &quot;aa&quot;，p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s = &quot;aa&quot;，p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: s = &quot;ab&quot;，p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入: s = &quot;aab&quot;，p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#x27;*&#x27; 表示零个或多个，这里 &#x27;c&#x27; 为 0 个, &#x27;a&#x27; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line">输入: s = &quot;mississippi&quot;，p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">- s 可能为空，且只包含从 a-z 的小写字母。</span><br><span class="line">- p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 *。</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 10 题相同：<a class="link"   href="https://leetcode-cn.com/problems/regular-expression-matching/" >https://leetcode-cn.com/problems/regular-expression-matching/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large red"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>主要难点在<code>*</code>号上，如何用代码来实现<code>*</code>号的匹配规则。</p>
<p>另外就是动态规划</p>
</div></div>

<div class="note success"><h3 id="知识点3、动态规划"><a href="#知识点3、动态规划" class="headerlink" title="知识点3、动态规划"></a>知识点3、动态规划</h3><p>动态规划（英语：Dynamic programming，简称 DP），是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。</p>
<p><font color="#dd0000">动态规划最核心的思想，就在于<strong>拆分子问题，记住过往，减少重复计算</strong>。</font></p>
<p>因此通过会设计一个数组或二维数组来记录子问题的结果，然后跟据子问题的结果来得出最终结果</p>
<p>如斐波那契数列(<a class="link"   href="https://www.huangkebing.com/2023/05/10/algorithm/offer/%E5%89%91%E6%8C%87Offer_Part1/#10-1%E3%80%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97" >斐波那契数列 - technology-inn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)，其实就是最简单的动态规划</p>
<p>虽然没有设置数组来记录，但是有两个变量，因为题目的解题思路，两个变量足够得出答案</p>
<p>因此实现动态规划，需要跟据题意理出这几个点：</p>
<ul>
<li>子问题拆分，通常字符串则拆分成字符，数组则按照元素来，或者明显的递归</li>
<li>记忆过往，通常是数组，也可以用集合</li>
<li>利用子问题答案求解</li>
</ul>
</div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String A, String B)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] str = A.toCharArray(),pattern = B.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> str.length, n = pattern.length;</span><br><span class="line">        <span class="comment">// dp数组的下标代表字符串和正则串的长度，如行下标为0，列下标为2，表示字符串前0个字符和正则串前2个字符的匹配情况</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 空字符串和空正则串，必定是匹配的</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 空字符串和非空正则串，需要验证，如c*也能匹配空字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pattern[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 此处取减2是因为*号前面必定有另一个字符，而针对空字符串，*必定代表出现0次，因此直接取前面的状态即可</span></span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两者皆是非空时</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[i - <span class="number">1</span>] == pattern[j - <span class="number">1</span>] || pattern[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 当前两个字符相等，或者正则串字符为. 则继承上一个长度的匹配情况</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">// 如果为*</span></span><br><span class="line">                    <span class="keyword">if</span> (pattern[j - <span class="number">2</span>] == str[i - <span class="number">1</span>] || pattern[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                        dp[i][j] |= dp[i][j - <span class="number">1</span>]; <span class="comment">// a* counts as single a</span></span><br><span class="line">                        dp[i][j] |= dp[i - <span class="number">1</span>][j]; <span class="comment">// a* counts as multiple a</span></span><br><span class="line">                        dp[i][j] |= dp[i][j - <span class="number">2</span>]; <span class="comment">// a* counts as empty</span></span><br><span class="line">                    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>];   <span class="comment">// a* only counts as empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="20、表示数值的字符串"><a href="#20、表示数值的字符串" class="headerlink" title="20、表示数值的字符串"></a><font color="orange">20、表示数值的字符串</font></h2><p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）</p>
<p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>若干空格</li>
<li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li>
<li>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 <strong>整数</strong></li>
<li>若干空格</li>
</ol>
<p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li>
<li>下述格式之一：<ol>
<li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code></li>
<li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code> ，后面再跟着至少一位数字</li>
<li>一个点 <code>&#39;.&#39;</code> ，后面跟着至少一位数字</li>
</ol>
</li>
</ol>
<p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li>
<li>至少一位数字</li>
</ol>
<p>部分<strong>数值</strong>列举如下：</p>
<ul>
<li><code>[&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;]</code></li>
</ul>
<p>部分<strong>非数值</strong>列举如下：</p>
<ul>
<li><code>[&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;]</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;0&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;e&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s = &quot;.&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：s = &quot;    .1  &quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">- 1 &lt;= s.length &lt;= 20</span><br><span class="line">- s仅含英文字母（大写和小写），数字（0-9），加号 &#x27;+&#x27; ，减号 -&#x27; ，空格 &#x27; &#x27; 或者点 &#x27;.&#x27;</span><br></pre></td></tr></table></figure></div>

<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>只需要跟据题意编写if-else即可</p>
</div></div>

<div class="note success"><h3 id="知识点4、判断字符串是否是数值"><a href="#知识点4、判断字符串是否是数值" class="headerlink" title="知识点4、判断字符串是否是数值"></a>知识点4、判断字符串是否是数值</h3><p>使用apache commons lang包中的<a class="link"   href="https://www.huangkebing.com/2023/04/26/util/apache/commons-lang3/#3-1-NumberUtils" >NumberUtils - technology-inn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>即可，无需自行封装</p>
</div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.trim();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">numFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">eFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">dianFlg</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(ch)) &#123;</span><br><span class="line">                numFlag = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span> &amp;&amp; !dianFlg &amp;&amp; !eFlag &amp;&amp; ((i + <span class="number">1</span> &lt; str.length() &amp;&amp; Character.isDigit(str.charAt(i + <span class="number">1</span>)) || (i != <span class="number">0</span> &amp;&amp; numFlag)))) &#123;</span><br><span class="line">                dianFlg = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((ch == <span class="string">&#x27;e&#x27;</span> || ch == <span class="string">&#x27;E&#x27;</span>) &amp;&amp; !eFlag &amp;&amp; numFlag) &#123;</span><br><span class="line">                eFlag = <span class="literal">true</span>;</span><br><span class="line">                numFlag = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((ch == <span class="string">&#x27;-&#x27;</span> || ch == <span class="string">&#x27;+&#x27;</span>) &amp;&amp; (i == <span class="number">0</span> || str.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;e&#x27;</span> || str.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;E&#x27;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numFlag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指Offer_Part.2</title>
    <url>/2023/05/30/algorithm/offer/%E5%89%91%E6%8C%87Offer_Part2/</url>
    <content><![CDATA[<h2 id="21、调整数组顺序使奇数位于偶数前面"><a href="#21、调整数组顺序使奇数位于偶数前面" class="headerlink" title="21、调整数组顺序使奇数位于偶数前面"></a>21、调整数组顺序使奇数位于偶数前面</h2><h2 id="21、调整数组顺序使奇数位于偶数前面-1"><a href="#21、调整数组顺序使奇数位于偶数前面-1" class="headerlink" title="21、调整数组顺序使奇数位于偶数前面"></a><font color="green">21、调整数组顺序使奇数位于偶数前面</font></h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1. 0 &lt;= nums.length &lt;= 50000</span><br><span class="line">2. 0 &lt;= nums[i] &lt;= 10000</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>有两种思路</p>
<ol>
<li>基于双指针</li>
</ol>
<p>快指针用于遍历数组，慢指针记录奇数位置，当快指针遍历到奇数时快慢指针交换值</p>
<ol start="2">
<li>直接思路</li>
</ol>
<p>将奇偶数分成两个数组，再将偶数添加到奇数尾部</p>
<p>当前双指针效率更高一些，只涉及一次遍历，且无额外的数组空间消耗</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                tmp = nums[fast];</span><br><span class="line">                nums[fast] = nums[slow];</span><br><span class="line">                nums[slow] = tmp;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="22、链表中倒数第k个节点"><a href="#22、链表中倒数第k个节点" class="headerlink" title="22、链表中倒数第k个节点"></a><font color="green">22、链表中倒数第k个节点</font></h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>使用快慢指针，用差值的思想。跟据题意：</p>
<ul>
<li>快慢指针的下标相差k-1(如123456，取倒数第3个，那么快指针应当在3，慢指针在1)</li>
<li>随后将快慢指针同步平移，直至快指针到达链表尾部</li>
<li>此时慢指针即是解</li>
</ul>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="23、反转链表"><a href="#23、反转链表" class="headerlink" title="23、反转链表"></a><font color="green">23、反转链表</font></h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">0 &lt;= 节点个数 &lt;= 5000</span><br></pre></td></tr></table></figure></div>

<p><strong>注意</strong>：本题与主站 206 题相同：<a class="link"   href="https://leetcode-cn.com/problems/reverse-linked-list/" >https://leetcode-cn.com/problems/reverse-linked-list/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>将当前节点的next指针指向前置节点，头节点next置为null</p>
<p>但此处链表是单链表，所以需要定义变量来缓存前置节点</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head,p2 = p1.next;</span><br><span class="line">        p1.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> p2.next;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = curr;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p2.next = p1;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="25、合并两个排序的链表"><a href="#25、合并两个排序的链表" class="headerlink" title="25、合并两个排序的链表"></a><font color="green">25、合并两个排序的链表</font></h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">0 &lt;= 链表长度 &lt;= 1000</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 21 题相同：<a class="link"   href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" >https://leetcode-cn.com/problems/merge-two-sorted-lists/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>因为链表是排序的，所以只需要比较两个链表的当前首节点即可</p>
<p>但要注意null(即链表比完)的情况：</p>
<ul>
<li>有空链表，则直接返回另一条</li>
<li>某一条链表用完，需要将另一条加到生成链表的尾部</li>
</ul>
<p>两个链表均有值时，取小值添加到生成链表的尾部，具体可以结合代码注释</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="comment">// 先判断是否有空链</span></span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排除空链后，取两个链表中的小值作为头节点</span></span><br><span class="line">        ListNode head;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &gt;= l2.val)&#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两个链表均有节点时，获取小值，直到有一个链表用完</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &gt;= l2.val)&#123;</span><br><span class="line">                p.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将剩余链表接到新链表中</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            p.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            p.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="26、树的子结构"><a href="#26、树的子结构" class="headerlink" title="26、树的子结构"></a><font color="orange">26、树的子结构</font></h2><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定的树 A:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \ </span><br><span class="line">1	2</span><br><span class="line">给定的树 B:</span><br><span class="line">  4</span><br><span class="line"> /</span><br><span class="line">1</span><br><span class="line">返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：A = [1,2,3], B = [3,1]</span><br><span class="line">输出：false</span><br><span class="line">示例 2：</span><br><span class="line">输入：A = [3,4,5,1,2], B = [4,1]</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">0 &lt;= 节点个数 &lt;= 10000</span><br></pre></td></tr></table></figure></div>

<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>凡是二叉树的题，基本是用递归没跑</p>
<p>但这里首先在A中找到B的根节点，然后再依次比对子节点，如果比对不上还需要继续查找根节点</p>
<p>然后就纳闷了这递归要怎么写，最后找到用双递归</p>
<p>看来这一类题还是不到火候，只直到用递归但要写出代码还少点感觉，还需要继续刷题思考总结</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//函数的作用就是判断B 是否是 A 的子结构树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="comment">//约定空树不是任意一个树的子结构</span></span><br><span class="line">        <span class="keyword">if</span> (B == <span class="literal">null</span> || A == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp的作用是判断从A 的根节点出发，是否存在跟B 结构相同的树。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dp</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (B == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || B.val != A.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(A.left, B.left) &amp;&amp; dp(A.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="27、二叉树的镜像"><a href="#27、二叉树的镜像" class="headerlink" title="27、二叉树的镜像"></a><font color="green">27、二叉树的镜像</font></h2><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如输入：</span><br><span class="line">     4    </span><br><span class="line">   /   \   </span><br><span class="line">  2      7  </span><br><span class="line"> /  \	 /  \ </span><br><span class="line">1   3  6   9</span><br><span class="line">镜像输出：</span><br><span class="line">	  4    </span><br><span class="line">   /   \   </span><br><span class="line">  7      2  </span><br><span class="line"> /  \	 /  \ </span><br><span class="line">9   6  3   1</span><br><span class="line">示例 1：</span><br><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br><span class="line">限制：</span><br><span class="line">0 &lt;= 节点个数 &lt;= 1000</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>前面说了二叉树基本就是递归，这里所谓的镜像只需要把左右子树互换位置即可</p>
<p>递归结束条件更简单就是当前节点为null</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode temp;</span><br><span class="line">        temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        mirrorTree(root.left);</span><br><span class="line">        mirrorTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="28、对称的二叉树"><a href="#28、对称的二叉树" class="headerlink" title="28、对称的二叉树"></a><font color="green">28、对称的二叉树</font></h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class="line">	  1    </span><br><span class="line">   /   \   </span><br><span class="line">  2      2  </span><br><span class="line"> /  \	 /  \ </span><br><span class="line">3   4  4   3</span><br><span class="line">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line">	  1    </span><br><span class="line">   /   \   </span><br><span class="line">  2      2  </span><br><span class="line">   \	   \ </span><br><span class="line">    3      3</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">0 &lt;= 节点个数 &lt;= 1000</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 101 题相同：<a class="link"   href="https://leetcode-cn.com/problems/symmetric-tree/" >https://leetcode-cn.com/problems/symmetric-tree/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>同样是递归，但是绕了个圈子</p>
<p>如果直接拿二叉树就开始递归，那没办法做到判断是否对称</p>
<p>需要先将二叉树划分为左右树，然后在递归中同步遍历两个树，主要递归遍历时左右树的方向要相反(即左树的左子树和右树的右子树比较)</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkTree(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkTree</span><span class="params">(TreeNode leftTree, TreeNode rightTree)</span> &#123;</span><br><span class="line">        <span class="comment">// 两边子树均遍历到叶子，true</span></span><br><span class="line">        <span class="keyword">if</span> (leftTree == <span class="literal">null</span> &amp;&amp; rightTree == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有一边到叶子，不说不是对称的</span></span><br><span class="line">        <span class="keyword">if</span> (leftTree == <span class="literal">null</span> || rightTree == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 值不相等，不是对称</span></span><br><span class="line">        <span class="keyword">if</span> (leftTree.val != rightTree.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 值相等，继续比较子树，注意要左树的左子树和右树的右子树比较</span></span><br><span class="line">        <span class="keyword">return</span> checkTree(leftTree.left, rightTree.right) &amp;&amp; checkTree(leftTree.right, rightTree.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="29、顺时针打印矩阵"><a href="#29、顺时针打印矩阵" class="headerlink" title="29、顺时针打印矩阵"></a><font color="green">29、顺时针打印矩阵</font></h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">- 0 &lt;= matrix.length &lt;= 100</span><br><span class="line">- 0 &lt;= matrix[i].length &lt;= 100</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 54 题相同：<a class="link"   href="https://leetcode-cn.com/problems/spiral-matrix/" >https://leetcode-cn.com/problems/spiral-matrix/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>按照题目意思来编写循环即可，需要4个变量来存储上下左右4个边界</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="comment">// 空数组校验</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">column</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (column == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果以四个方向的限制设置</span></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[row * column];</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, bottom = row - <span class="number">1</span>, left = <span class="number">0</span>, right = column - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 按4个方向依次遍历，并移动方向限制</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">                result[res++] = matrix[top][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++top &gt; bottom) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &lt;= bottom; i++) &#123;</span><br><span class="line">                result[res++] = matrix[i][right];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--right &lt; left) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right; i &gt;= left; i--) &#123;</span><br><span class="line">                result[res++] = matrix[bottom][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--bottom &lt; top) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom; i &gt;= top; i--) &#123;</span><br><span class="line">                result[res++] = matrix[i][left];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++left &gt; right) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="30、包含min函数的栈"><a href="#30、包含min函数的栈" class="headerlink" title="30、包含min函数的栈"></a><font color="green">30、包含min函数的栈</font></h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1. 各函数的调用总次数不超过 20000 次</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 155 题相同：<a class="link"   href="https://leetcode-cn.com/problems/min-stack/" >https://leetcode-cn.com/problems/min-stack/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>采用ArrayList来实现栈，入栈出栈非常容易</p>
<p>最小值，最初版是直接调用Collections.min()来做，但耗时400ms以上，非常慢</p>
<p>原因是每次调用min都需要查找一遍，于是做了个优化：用一个变量来保存min，每次入栈出栈时判断是否要更新最小值</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; stack;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack.add(x);</span><br><span class="line">        min = Math.min(min, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">remove</span> <span class="operator">=</span> stack.remove(stack.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (min == remove) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                min = Integer.MAX_VALUE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                min = Collections.min(stack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.get(stack.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="31、栈的压入、弹出序列"><a href="#31、栈的压入、弹出序列" class="headerlink" title="31、栈的压入、弹出序列"></a><font color="orange">31、栈的压入、弹出序列</font></h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1. 0 &lt;= pushed.length == popped.length &lt;= 1000</span><br><span class="line">2. 0 &lt;= pushed[i], popped[i] &lt; 1000</span><br><span class="line">3. pushed 是 popped 的排列。</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 946 题相同：<a class="link"   href="https://leetcode-cn.com/problems/validate-stack-sequences/" >https://leetcode-cn.com/problems/validate-stack-sequences/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>将入栈序列依次入栈，每次入栈判断栈首和弹出序列是否相等，若相等则出栈并继续判断直到不相等为止</p>
<p>最后入栈完毕，若栈中还有元素，那么结果为false反之为true</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 思路 ：即，使用辅助栈temp来模拟入栈出栈，若是按照pushed数组所入栈的元素，都能够按照popped数组出栈的话，则代表符合条件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> pushed.length;</span><br><span class="line">        <span class="comment">// 双指针分别指向当前正在遍历的pushed数组中元素 &amp;&amp; popped数组中元素;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// while循环结束条件 ：指向pushed数组的指针p1 &gt;= len；</span></span><br><span class="line">        <span class="comment">// 需要注意的是，p1 &gt;= p2是永远满足的;</span></span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; len)&#123;</span><br><span class="line">            <span class="comment">// 即，pushed数组中当前所指向的元素压入栈中;</span></span><br><span class="line">            stack.push(pushed[p1++]);</span><br><span class="line">            <span class="comment">// 当前栈不为空 &amp;&amp; 当前栈顶元素与popped数组中当前所指向的元素一样</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() == popped[p2])&#123;</span><br><span class="line">                <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="32-1、从上到下打印二叉树"><a href="#32-1、从上到下打印二叉树" class="headerlink" title="32-1、从上到下打印二叉树"></a><font color="orange">32-1、从上到下打印二叉树</font></h2><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line">	 3</span><br><span class="line">   / \</span><br><span class="line">  9   20</span><br><span class="line">     /  \</span><br><span class="line">    15   7</span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">[3,9,20,15,7]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1. 节点总数 &lt;= 1000</span><br></pre></td></tr></table></figure></div>

<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>前面提到二叉树基本都是递归，但这里就不能用递归了！因为这里是广度优先遍历，而递归是深度优先遍历</p>
<p>广度优先的二叉树遍历，必定越遍历节点越多，所以需要存储节点，按照题意使用队列即可</p>
<p>消费队列头的节点将值保存到结果数组，并将左右子节点存到队列尾(null不存)</p>
</div></div>

<div class="note success"><h3 id="知识点1、基本数据类型尽量不用集合"><a href="#知识点1、基本数据类型尽量不用集合" class="headerlink" title="知识点1、基本数据类型尽量不用集合"></a>知识点1、基本数据类型尽量不用集合</h3><p>基本数据类型使用集合会有装箱拆箱操作</p>
<p>如此题，因为不确定二叉树节点的数量，开始使用ArrayList来保存结果，再转化成int数组，耗时4ms</p>
<p>指定初始容量避免扩容操作后，耗时也在3ms</p>
<p>虽然在3ms在业务代码中可以忽略不计，但在算法题里打败用户数还是挺明显的</p>
<p>而用数组代替ArrayList，避免装箱拆箱后，直接到了0ms</p>
</div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>; <span class="type">int</span> [] ans=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1010</span>];</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            ans[index++] = node.val;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(ans,<span class="number">0</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="32-2、从上到下打印二叉树Ⅱ"><a href="#32-2、从上到下打印二叉树Ⅱ" class="headerlink" title="32-2、从上到下打印二叉树Ⅱ"></a><font color="green">32-2、从上到下打印二叉树Ⅱ</font></h2><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回其层次遍历结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1. 节点总数 &lt;= 1000</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 102 题相同：<a class="link"   href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" >https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>在32-1的基础上，添加了每行打印单独一行的要求，那么如果区分一行已经结束就是唯一的设计点</p>
<p>用了两个队列，队列1用于遍历，队列2存放子节点</p>
<ol>
<li>遍历队列1</li>
<li>队列1遍历完毕后，检查队列2是否为空，若为空则结束循环</li>
<li>队列1完毕后交换两个队列指针，并创建新的一行</li>
</ol>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        queue1.add(root);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; line = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        result.add(line);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!queue1.isEmpty())&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue1.poll();</span><br><span class="line">                line.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue2.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue2.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(queue2.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Queue&lt;TreeNode&gt; temp = queue1;</span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = temp;</span><br><span class="line">            line = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            result.add(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="32-3、从上到下打印二叉树Ⅲ"><a href="#32-3、从上到下打印二叉树Ⅲ" class="headerlink" title="32-3、从上到下打印二叉树Ⅲ"></a><font color="orange">32-3、从上到下打印二叉树Ⅲ</font></h2><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">返回其层次遍历结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1. 节点总数 &lt;= 1000</span><br></pre></td></tr></table></figure></div>

<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>在32-2的基础上，又新增了偶数行右到左展示，这里有两个思路</p>
<ol>
<li>保持32-2逻辑不变，遍历完成后再遍历一次，将偶数行List倒序</li>
<li>使用双端队列，跟据行数使用对应的遍历方向</li>
</ol>
<p>为了快捷我直接使用了第一个方法，然后找了个别人写的方法二</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt;lists=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> lists;</span><br><span class="line">        Deque&lt;TreeNode&gt;deque=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque.offerLast(root);</span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> size=deque.size();</span><br><span class="line">            List&lt;Integer&gt;list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;<span class="comment">// 奇数层正序</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                    TreeNode node=deque.pollFirst();</span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) deque.offerLast(node.left);</span><br><span class="line">                    <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) deque.offerLast(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 偶数层逆序</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                    TreeNode node=deque.pollLast();</span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) deque.offerFirst(node.right);</span><br><span class="line">                    <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) deque.offerFirst(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lists.add(list);</span><br><span class="line">            flag=!flag;<span class="comment">// 通过将flag每次取反改变状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="33、二叉树的后序遍历序列"><a href="#33、二叉树的后序遍历序列" class="headerlink" title="33、二叉树的后序遍历序列"></a><font color="orange">33、二叉树的后序遍历序列</font></h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考以下这颗二叉搜索树：</span><br><span class="line">     5</span><br><span class="line">    / \</span><br><span class="line">   2   6</span><br><span class="line">  / \</span><br><span class="line"> 1   3</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1. 数组长度 &lt;= 1000</span><br></pre></td></tr></table></figure></div>

<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>先需要知晓几个点：</p>
<ul>
<li>后序序列的最后一个元素即为根节点</li>
<li>二叉搜索树，左子树的所有节点都比根节点小，右子树的所有节点都比跟节点大</li>
</ul>
<p>跟据规则编写判断逻辑</p>
<ol>
<li>取最后一个元素root</li>
<li>从root-1往前遍历序列，找到第一个小于root的元素，那就找到了左右子树的分界点</li>
<li>遍历一下左子树，看有没有比root大的，如果有那么不符合二叉搜索树规则，返回false</li>
<li>如果左子树均小于root，那么利用递归再分别检查左子树和右子树是不是符合二叉搜索树</li>
</ol>
<p>递归可以通过数组下标来做，编码时注意很容易数组越界</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifyPostorder</span><span class="params">(<span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkPostorder(postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkPostorder</span><span class="params">(<span class="type">int</span>[] postorder, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> postorder[end];</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postorder[i] &lt; root) &#123;</span><br><span class="line">                rightIndex = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; rightIndex; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postorder[i] &gt; root) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin == rightIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> checkPostorder(postorder, rightIndex, end - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end == rightIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> checkPostorder(postorder, begin, rightIndex - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkPostorder(postorder, begin, rightIndex - <span class="number">1</span>) &amp;&amp; checkPostorder(postorder, rightIndex, end - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="34、二叉树中和为某一值的路径"><a href="#34、二叉树中和为某一值的路径" class="headerlink" title="34、二叉树中和为某一值的路径"></a><font color="orange">34、二叉树中和为某一值的路径</font></h2><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11   13  4</span><br><span class="line"> / \     / \</span><br><span class="line">7  2     5  1</span><br><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 </span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2 	3</span><br><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：root = [1,2], targetSum = 0</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">- 树中节点总数在范围 [0, 5000] 内</span><br><span class="line">- -1000 &lt;= Node.val &lt;= 1000</span><br><span class="line">- -1000 &lt;= targetSum &lt;= 1000</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 113 题相同：<a class="link"   href="https://leetcode-cn.com/problems/path-sum-ii/" >https://leetcode-cn.com/problems/path-sum-ii/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>依旧用递归来解，但这里有一点，没办法做剪枝</p>
<ul>
<li>节点有负值，不到最后的叶子节点你是不知道是否符合要求的</li>
<li>需要找出所有的路径</li>
</ul>
<p>还有一点，因为要保存路径，所以使用了List(数组也一样因为是引用对象)，所以在递归中add之后必须要手动remove</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; currLine = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        findPath(root, target, currLine, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findPath</span><span class="params">(TreeNode node, <span class="type">int</span> target, List&lt;Integer&gt; currLine, <span class="type">int</span> currNum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> node.val + currNum;</span><br><span class="line">        <span class="keyword">if</span> (value == target &amp;&amp; node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            currLine.add(node.val);</span><br><span class="line">            List&lt;Integer&gt; newLine = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(currLine);</span><br><span class="line">            result.add(newLine);</span><br><span class="line">            currLine.remove(currLine.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currNum = value;</span><br><span class="line">        currLine.add(node.val);</span><br><span class="line">        findPath(node.left, target, currLine, currNum);</span><br><span class="line">        findPath(node.right, target, currLine, currNum);</span><br><span class="line">        currLine.remove(currLine.size() -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="35、复杂链表的复制"><a href="#35、复杂链表的复制" class="headerlink" title="35、复杂链表的复制"></a><font color="orange">35、复杂链表的复制</font></h2><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">示例 2：</span><br><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br><span class="line">示例 3：</span><br><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br><span class="line">示例 4：</span><br><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">- -10000 &lt;= Node.val &lt;= 10000</span><br><span class="line">- Node.random 为空（null）或指向链表中的节点</span><br><span class="line">- 节点数目不超过 1000</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：</strong>本题与主站 138 题相同：<a class="link"   href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" >https://leetcode-cn.com/problems/copy-list-with-random-pointer/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>这里难点在于链表节点的值可能会重复，因此在复制节点时还需要保留顺序，否则没办法区分重复值的节点</p>
<p>最后学到了这样的方法，利用原链表的顺序来保存复制链表的顺序：</p>
<ol>
<li>将节点复制后，直接插到原节点后</li>
<li>这样设置random时需要要原节点.random.next</li>
<li>然后将链表分成两个，返回复制链表</li>
</ol>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="comment">// 1) 将1-&gt;2-&gt;3  ==&gt;  1-&gt;1&#x27;-&gt;2-&gt;2&#x27;-3-&gt;3&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">            newNode.next = cur.next;</span><br><span class="line">            cur.next = newNode;</span><br><span class="line">            cur = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2）将 1，2，3的random 的给 1&#x27;,2&#x27;.3&#x27; 例如：1 random 3 则 1&#x27; random 3&#x27;</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.random == <span class="literal">null</span>) &#123;</span><br><span class="line">                cur.next.random = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next.random = cur.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3） 将2）得到的链表拆分成两个，一个是 1，2，3 另一个是 1&#x27;,2&#x27;,3&#x27;</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">head2</span> <span class="operator">=</span> head.next;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4）输出 1&#x27;,2&#x27;,3&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> head2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="36、二叉搜索树与双向链表"><a href="#36、二叉搜索树与双向链表" class="headerlink" title="36、二叉搜索树与双向链表"></a><font color="orange">36、二叉搜索树与双向链表</font></h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了让您更好地理解问题，以下面的二叉搜索树为例：</span><br><span class="line">      4</span><br><span class="line">     / \</span><br><span class="line">    2   5</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</span><br><span class="line">下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</span><br><span class="line">1-2-3-4-5</span><br><span class="line">特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：</strong>本题与主站 426 题相同：<a class="link"   href="https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/" >https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>观察链表的值，可以发现就是二叉树的中序遍历</p>
<p>因此我们只需要设置一个prev指针用于保存上一个节点</p>
<ol>
<li>执行中序遍历递归先遍历左子树，直到叶子节点</li>
<li>叶子节点node.left &#x3D; prev，prev.right &#x3D; node， prev &#x3D; node</li>
<li>左子树遍历后，执行本节点</li>
<li>右子树遍历</li>
<li>从root向左向右找到首尾节点，按题目要求连接首尾节点，并返回首节点</li>
</ol>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 保存上一个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        toList(root);</span><br><span class="line">        <span class="comment">// 寻找首尾节点，并连接</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">left</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(left.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            left = left.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(right.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            right = right.right;</span><br><span class="line">        &#125;</span><br><span class="line">        left.left = right;</span><br><span class="line">        right.right = left;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toList</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="comment">// 叶子节点直接连接</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.left = prev;</span><br><span class="line">            <span class="keyword">if</span>(prev != <span class="literal">null</span>)&#123;</span><br><span class="line">                prev.right = node;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历左子树</span></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            toList(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 节点左子树完成后，连接本节点</span></span><br><span class="line">        node.left = prev;</span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="literal">null</span>)&#123;</span><br><span class="line">            prev.right = node;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;</span><br><span class="line">        <span class="comment">// 遍历右子树</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            toList(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="37、序列化二叉树"><a href="#37、序列化二叉树" class="headerlink" title="37、序列化二叉树"></a><font color="red">37、序列化二叉树</font></h2><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p><strong>提示：</strong>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a class="link"   href="https://support.leetcode-cn.com/hc/kb/article/1567641/" >LeetCode 序列化二叉树的格式 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,null,null,4,5]</span><br><span class="line">输出：[1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 297 题相同：<a class="link"   href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" >https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large red"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>主要就是怎么样序列化在反序列化的时候方便，一般来说有前中后序中的两个就可以复原一个二叉树但很麻烦</p>
<p>另一个就是层序列，但要记录叶子节点信息</p>
<p>相比前中后序，层序列更便捷一些</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> -<span class="number">2000</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">emptyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(INF);</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        d.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!d.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">            sb.append(poll.val + <span class="string">&quot;_&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (!poll.equals(emptyNode)) &#123;</span><br><span class="line">                d.addLast(poll.left != <span class="literal">null</span> ? poll.left : emptyNode);</span><br><span class="line">                d.addLast(poll.right != <span class="literal">null</span> ? poll.right : emptyNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        String[] ss = data.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ss.length;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(ss[<span class="number">0</span>]));</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        d.addLast(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(ss[i]), b = Integer.parseInt(ss[i + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (a != INF) &#123;</span><br><span class="line">                poll.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(a);</span><br><span class="line">                d.addLast(poll.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b != INF) &#123;</span><br><span class="line">                poll.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(b);</span><br><span class="line">                d.addLast(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="38、字符串的排列"><a href="#38、字符串的排列" class="headerlink" title="38、字符串的排列"></a><font color="orange">38、字符串的排列</font></h2><p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 &lt;= s 的长度 &lt;= 8</span><br></pre></td></tr></table></figure></div>

<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>刷了近40题，第一次遇到回溯法</p>
</div></div>

<div class="note success"><h3 id="知识点2、回溯法"><a href="#知识点2、回溯法" class="headerlink" title="知识点2、回溯法"></a>知识点2、回溯法</h3><p>回溯法，又叫试探法，是一种寻找<strong>最优解</strong>的<strong>暴力搜寻法</strong>。由于暴力，回溯法的<strong>时间复杂度较高</strong>，因此在比较一些数字较大的问题时，比如上次我们提到的最短路径问题等，运行时间一般比较长。</p>
<p>在回溯法中，深度优先搜索是一种很重要的工具——说到这是不是想起来上次的最短路径问题的DFS解法了？了解了DFS，就比较容易理解回溯法。</p>
<p>简单地介绍一下DFS，用一句话概括，就是“不撞南墙不回头”。（这句话也适用于回溯法）</p>
<p>它的基本思想是：</p>
<ol>
<li>某一种可能情况向前探索，并生成一个子节点。</li>
<li>过程中，一旦发现原来的选择不符合要求，就<strong>回溯</strong>至父亲结点，然后重新选择另一方向，再次生成子结点，继续向前探索。</li>
<li>如此反复进行，直至求得最优解。</li>
</ol>
<p>回溯法基本思想是：</p>
<ol>
<li>针对具体问题，定义问题的<strong>解空间</strong>；</li>
<li>确定易于搜索的解空间结构（数据结构的选择）。</li>
<li>一般以<strong>DFS</strong>的方式搜索解空间。</li>
<li>在搜索过程中，可以使用<strong>剪枝函数</strong>等来优化算法。</li>
</ol>
</div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; rec;</span><br><span class="line">    <span class="type">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        rec = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">perm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        backtrack(arr, <span class="number">0</span>, n, perm);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> rec.size();</span><br><span class="line">        String[] recArr = <span class="keyword">new</span> <span class="title class_">String</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            recArr[i] = rec.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> n, StringBuffer perm)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            rec.add(perm.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[j] || (j &gt; <span class="number">0</span> &amp;&amp; !vis[j - <span class="number">1</span>] &amp;&amp; arr[j - <span class="number">1</span>] == arr[j])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[j] = <span class="literal">true</span>;</span><br><span class="line">            perm.append(arr[j]);</span><br><span class="line">            backtrack(arr, i + <span class="number">1</span>, n, perm);</span><br><span class="line">            perm.deleteCharAt(perm.length() - <span class="number">1</span>);</span><br><span class="line">            vis[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="39、数组中出现次数超过一半的数字"><a href="#39、数组中出现次数超过一半的数字" class="headerlink" title="39、数组中出现次数超过一半的数字"></a><font color="green">39、数组中出现次数超过一半的数字</font></h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">限制：1 &lt;= 数组长度 &lt;= 50000</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 169 题相同：<a class="link"   href="https://leetcode-cn.com/problems/majority-element/" >https://leetcode-cn.com/problems/majority-element/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>其实就是找众数，通常没刷过算法题的人，能想到的办法</p>
<ul>
<li>用hashmap来统计数量，当有元素数量超过阈值(即数组长度一半)，即找到该元素</li>
</ul>
<p>但Java的集合，基本数据类型需要使用包装类，每次执行数量加1都需要重建对象，会比较耗性能</p>
<p>随后跟据题意还可以这样解：</p>
<ul>
<li>将数组排序，取数组中间的元素</li>
</ul>
<p>如果用快排则复杂度为O(nlogn)</p>
<p>最后还有一种求众数的算法：摩尔投票</p>
</div></div>

<div class="note success"><h3 id="知识点3、Boyer-Moore-摩尔投票算法"><a href="#知识点3、Boyer-Moore-摩尔投票算法" class="headerlink" title="知识点3、Boyer-Moore 摩尔投票算法"></a>知识点3、Boyer-Moore 摩尔投票算法</h3><p><strong>限定一定存在众数的情况</strong><br>把众数记为 +1，把其他数记为 -1，将它们全部加起来，显然和大于 0，从结果本身可以看出众数比其他数多。</p>
<ol>
<li>维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；</li>
<li>遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予candidate，随后我们判断 x：<br>（1）如果 x 与 candidate 相等，那么计数器 count 的值增加 1；<br>（2）如果 x 与 candidate 不等，那么计数器 count 的值减少 1。</li>
<li>在遍历完成后，candidate 即为整个数组的众数。</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">1</span> | <span class="number">5</span>, <span class="number">7</span> | <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span> | <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>]</span><br><span class="line">每一步遍历时 candidate 和 count 的值：</span><br><span class="line"></span><br><span class="line">nums    :[<span class="number">7</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">1</span> | <span class="number">5</span>, <span class="number">7</span> | <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span> | <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>]</span><br><span class="line">candidate:[<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span> | <span class="number">5</span>, <span class="number">5</span> | <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span> | <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>]</span><br><span class="line">count:   [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span> | <span class="number">1</span>, <span class="number">0</span> | <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span> | <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure></div>
</div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidate == nums[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;  <span class="comment">//若count为0，更换候选人</span></span><br><span class="line">                    candidate = nums[i];</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="40、最小的k个数"><a href="#40、最小的k个数" class="headerlink" title="40、最小的k个数"></a><font color="green">40、最小的k个数</font></h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">- 0 &lt;= k &lt;= arr.length &lt;= 10000</span><br><span class="line">- 0 &lt;= arr[i] &lt;= 10000</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>最简单的就是直接排序，然后取前k个数，但这样一来效率注定不高</p>
<p>因为题目并不要求我们返回的结果集要是有序的，也就是说我们白做了一部分活</p>
<p>有一个算法基于快排实现——快速选择，专门解决最大&#x2F;小的k个数</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个参数表示我们要找的是下标为k-1的数</span></span><br><span class="line">        <span class="keyword">return</span> quickSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] quickSearch(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(nums, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span></span><br><span class="line">        <span class="keyword">return</span> j &gt; k? quickSearch(nums, lo, j - <span class="number">1</span>, k): quickSearch(nums, j + <span class="number">1</span>, hi, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> nums[lo];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= hi &amp;&amp; nums[i] &lt; v);</span><br><span class="line">            <span class="keyword">while</span> (--j &gt;= lo &amp;&amp; nums[j] &gt; v);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[j];</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">            nums[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[lo] = nums[j];</span><br><span class="line">        nums[j] = v;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指Offer_Part.3</title>
    <url>/2023/06/25/algorithm/offer/%E5%89%91%E6%8C%87Offer_Part3/</url>
    <content><![CDATA[<h2 id="41、数据流中的中位数"><a href="#41、数据流中的中位数" class="headerlink" title="41、数据流中的中位数"></a><font color="red">41、数据流中的中位数</font></h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，[2,3,4] 的中位数是 3，[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>
<li>double findMedian() - 返回目前所有元素的中位数。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">最多会对 `addNum、findMedian` 进行 `50000` 次调用。</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 295 题相同：<a class="link"   href="https://leetcode-cn.com/problems/find-median-from-data-stream/" >https://leetcode-cn.com/problems/find-median-from-data-stream/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large red"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>核心有两个点：</p>
<ol>
<li>怎么维持有序</li>
<li>支持快速定位到中位数</li>
</ol>
<p>最先想到的解法：二分查找+数组</p>
<p>但这里有个问题——数组选型，如果选用ArrayList那么每次插入大概率会引起数组位移，如果用LinkedList那么二分查找的性能会下降(因为无法随机访问)</p>
<p>于是借鉴了别人的思路，用大顶堆+小顶堆</p>
<p>这个思路需要保证两点</p>
<ul>
<li>保证两个堆的堆大小不超过1</li>
<li>保证小顶堆中的元素都大于大顶堆</li>
</ul>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="comment">// 大顶堆存储较小一半的值</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap;</span><br><span class="line">    <span class="comment">// 小顶堆存储较大一般的值</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; (y - x));</span><br><span class="line">        minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="comment">// 跟据奇偶数不同，入不同的堆，保证堆大小差不超过1</span></span><br><span class="line">        <span class="keyword">if</span>(maxHeap.size() != minHeap.size())&#123;</span><br><span class="line">            <span class="comment">// 保证小顶堆中的元素均大于大顶堆</span></span><br><span class="line">            maxHeap.add(num);</span><br><span class="line">            minHeap.add(maxHeap.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minHeap.add(num);</span><br><span class="line">            maxHeap.add(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(maxHeap.size() != minHeap.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> maxHeap.peek();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (maxHeap.peek() + minHeap.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="42、连续子数组的最大和"><a href="#42、连续子数组的最大和" class="headerlink" title="42、连续子数组的最大和"></a><font color="green">42、连续子数组的最大和</font></h2><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例1:</span><br><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">- 1 &lt;= arr.length &lt;= 10^5</span><br><span class="line">- -100 &lt;= arr[i] &lt;= 100</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 53 题相同：<a class="link"   href="https://leetcode-cn.com/problems/maximum-subarray/" >https://leetcode-cn.com/problems/maximum-subarray/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>动态规划，利用最大和的特性：负数+最大和&lt;最大和</p>
<p>也就是说遍历到某个元素时，和已经为负数了，那么就抛弃前面的和，从该元素重新开始计算和，并记录历史最大值</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 这里不需要保存每一个和，只需要保存当前和即可</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">currSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 从第2个元素开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果之前的和已经小于0，抛弃前面的累赘重新开始</span></span><br><span class="line">            <span class="keyword">if</span> (currSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                currSum = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currSum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录历史最大值</span></span><br><span class="line">            <span class="keyword">if</span> (currSum &gt; max) &#123;</span><br><span class="line">                max = currSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="43、1-n-整数中1出现的次数"><a href="#43、1-n-整数中1出现的次数" class="headerlink" title="43、1~n 整数中1出现的次数"></a><font color="red">43、1~n 整数中1出现的次数</font></h2><p>输入一个整数 <code>n</code> ，求1～n这n个整数的十进制表示中1出现的次数。</p>
<p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 12</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 13</span><br><span class="line">输出：6</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 &lt;= n &lt; 2^31</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 233 题相同：<a class="link"   href="https://leetcode-cn.com/problems/number-of-digit-one/" >https://leetcode-cn.com/problems/number-of-digit-one/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large red"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>本来思路是逐个逐位遍历，但超时了，也没有啥其他办法</p>
<p>看了别人的题解，属于是这道题的一种专属解法：</p>
<p><a class="link"   href="https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solutions/757536/dong-hua-mo-ni-wo-tai-xi-huan-zhe-ge-ti-vxzwc/" >剑指 Offer 43. 1～n 整数中 1 出现的次数 - 力扣（Leetcode） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>算法题其实最怕遇到的就是这类题，因为刷题可以练的是通用解法和题感，但这种题还需要活跃的思维</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//高位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="comment">//低位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (high != <span class="number">0</span> || cur != <span class="number">0</span>) &#123;</span><br><span class="line">            cur = high % <span class="number">10</span>;</span><br><span class="line">            high /= <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//这里我们可以提出 high * num 因为我们发现无论为几，都含有它</span></span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span>) count += high * num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) count += high * num + <span class="number">1</span> + low;</span><br><span class="line">            <span class="keyword">else</span> count += (high + <span class="number">1</span>) * num;</span><br><span class="line">            <span class="comment">//低位</span></span><br><span class="line">            low = cur * num + low;</span><br><span class="line">            num *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="44、数字序列中某一位的数字"><a href="#44、数字序列中某一位的数字" class="headerlink" title="44、数字序列中某一位的数字"></a><font color="orange">44、数字序列中某一位的数字</font></h2><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p>
<p>请写一个函数，求任意第n位对应的数字。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 11</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">0 &lt;= n &lt; 2^31</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 400 题相同：<a class="link"   href="https://leetcode-cn.com/problems/nth-digit/" >https://leetcode-cn.com/problems/nth-digit/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>又是找规律的题，暴力解法肯定不用想，必超时(哪怕不超时，也尽量不要用，因为没意义，总不能面试的时候你写个暴力解法，那肯定就挂了)</p>
<p>思路是按位数来，0-9、10-99、100-999每一段有多少位都是可以通过计算得到的，然后再跟据给定n和位数的商和余数定位</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 找到小于n且最接近n的一档</span></span><br><span class="line">        <span class="keyword">while</span> (length + (<span class="type">long</span>) (<span class="number">9</span> * Math.pow(<span class="number">10</span>, bit - <span class="number">1</span>) * bit) &lt; n) &#123;</span><br><span class="line">            length += (<span class="type">long</span>) (<span class="number">9</span> * Math.pow(<span class="number">10</span>, bit - <span class="number">1</span>) * bit);</span><br><span class="line">            bit++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算出解所在的数字和该数字的第几位</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">long</span>) Math.pow(<span class="number">10</span>, bit - <span class="number">1</span>) + (n - length) / bit;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(num).charAt((<span class="type">int</span>)(n - length) % bit) - (<span class="type">int</span>) (<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="45、把数组排成最小的数"><a href="#45、把数组排成最小的数" class="headerlink" title="45、把数组排成最小的数"></a><font color="orange">45、把数组排成最小的数</font></h2><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line"> 0 &lt; nums.length &lt;= 100</span><br></pre></td></tr></table></figure></div>

<p><strong>说明:</strong></p>
<ul>
<li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li>
<li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</li>
</ul>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>这题有点像数学的应用题，需要先跟据题目找到用什么方法来解</p>
<p>这里其实就是排序的变式，只不过排序的方式变了：</p>
<ul>
<li>两个字符串 xy &gt; yx , 那么 x &gt; y</li>
</ul>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        String[] array = <span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            array[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里直接用Java提供的排序了，因为日常开发中不会自己来实现排序</span></span><br><span class="line">        Arrays.sort(array, (s1,s2) -&gt; (s1+s2).compareTo(s2+s1));</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String s : array) &#123;</span><br><span class="line">            builder.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="46、把数字翻译成字符串"><a href="#46、把数字翻译成字符串" class="headerlink" title="46、把数字翻译成字符串"></a><font color="orange">46、把数字翻译成字符串</font></h2><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;= num &lt; 2^31</span><br></pre></td></tr></table></figure></div>

<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>就是数字在[10,25]之间的两个数可以合并</p>
<p>然后最后的找到的规律:</p>
<ul>
<li>第n位和第n-1位能合并：f(n) &#x3D; f(n-1) + f(n-2)</li>
<li>第n位和第n-1位不能合并：f(n) &#x3D; f(n-1)</li>
</ul>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line">        <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1</span>, f2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(i - <span class="number">2</span>, i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> str.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; str.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> ? f1 + f2 : f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="47、礼物的最大价值"><a href="#47、礼物的最大价值" class="headerlink" title="47、礼物的最大价值"></a><font color="orange">47、礼物的最大价值</font></h2><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">- `0 &lt; grid.length &lt;= 200`</span><br><span class="line">- `0 &lt; grid[0].length &lt;= 200`</span><br></pre></td></tr></table></figure></div>

<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>很典型的动态规划，当前位置的最大价值取决于上或左位置的最大价值</p>
<p>因此，创建一个二维数组，当前位置的最大价值 &#x3D; Max(上位置的最大价值，左位置的最大价值) + 当前位置价值</p>
<p>将数组填满后，取右下角的值即为题解</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">column</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 创建过程记录数组</span></span><br><span class="line">        <span class="type">int</span>[][] value = <span class="keyword">new</span> <span class="title class_">int</span>[row][column];</span><br><span class="line">        <span class="comment">// 初始化上边界和左边界的值</span></span><br><span class="line">        value[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            value[i][<span class="number">0</span>] = value[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; column; i++) &#123;</span><br><span class="line">            value[<span class="number">0</span>][i] = value[<span class="number">0</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 推算每个节点的最大值，值为Max(上元素礼物累计值，左元素礼物累计值) + 当前节点礼物值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; column; j++) &#123;</span><br><span class="line">                value[i][j] = Math.max(value[i-<span class="number">1</span>][j], value[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value[value.length - <span class="number">1</span>][value[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="48、最长不含重复字符的子字符串"><a href="#48、最长不含重复字符的子字符串" class="headerlink" title="48、最长不含重复字符的子字符串"></a><font color="orange">48、最长不含重复字符的子字符串</font></h2><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br><span class="line">     </span><br><span class="line">提示：</span><br><span class="line">s.length &lt;= 40000</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 3 题相同：<a class="link"   href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" >https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>用map记录每个字符和出现的下标，记录长度，当出现重复时，从该重复元素后重新开始计数</p>
<p>这样做是可以解的，但是耗时比较大</p>
<p>最后参考了其他人的解法</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//把当前 字符与其下标存入map</span></span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 定义一个指针 每次都指向与遍历右指针最近的那个重复元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">choose_right</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">                <span class="comment">//如果存在重复元素 获取该元素下标 获取与right距离最近的重复元素</span></span><br><span class="line">                choose_right = Math.max(choose_right,map.get(c));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把重复元素存进当前位置</span></span><br><span class="line">            map.put(c,right);</span><br><span class="line">            <span class="comment">//当前重复元素位置减掉最近的重复元素位置 得到该段距离长度</span></span><br><span class="line">            res = Math.max(res,right - choose_right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="49、丑数"><a href="#49、丑数" class="headerlink" title="49、丑数"></a><font color="orange">49、丑数</font></h2><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: n = 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">1. 1 是丑数</span><br><span class="line">2. n 不超过1690</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 264 题相同：<a class="link"   href="https://leetcode-cn.com/problems/ugly-number-ii/" >https://leetcode-cn.com/problems/ugly-number-ii/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>新丑数&#x3D;原丑数*2&#x2F;3&#x2F;5</p>
<p>但问题是怎么保证顺序，起始数1乘2&#x2F;3&#x2F;5分别得到2&#x2F;3&#x2F;5，但中间其实还有一个4</p>
<p>这里需要使用多指针，分别记录2&#x2F;3&#x2F;5因子的乘数位置，每次取3个积中的小值</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//表示可能被选择的三个元素的值，初始值为1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>, y = <span class="number">1</span>, z = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//dp[i]的值是三个元素分别乘2乘3乘5后，其中的最小值</span></span><br><span class="line">            <span class="comment">//最小值一定在这三个元素中，其他元素被排除，从而减少了重复查找</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> dp[x] * <span class="number">2</span>, num3 = dp[y] * <span class="number">3</span>, num5 = dp[z] * <span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(num2, Math.min(num3, num5));</span><br><span class="line">            <span class="comment">//已经被选择过的元素，应该被排除，后续只会选择更大的值</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i] == num2) x++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == num3) y++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == num5) z++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="50、第一个只出现一次的字符"><a href="#50、第一个只出现一次的字符" class="headerlink" title="50、第一个只出现一次的字符"></a><font color="green">50、第一个只出现一次的字符</font></h2><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：s = &quot;abaccdeff&quot;</span><br><span class="line">输出：&#x27;b&#x27;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：s = &quot;&quot; </span><br><span class="line">输出：&#x27; &#x27;</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">0 &lt;= s 的长度 &lt;= 50000</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>首先只出现一次，因此需要记录每个字符的状态(未重复&#x2F;已重复)</p>
<p>其次需要第一个，还需要记录字符的顺序</p>
<p>因此使用LinkedHashMap即可，当然也可以HashMap+List，两者耗时接近</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        LinkedHashMap&lt;Character, Boolean&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> aChar : chars) &#123;</span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">value</span> <span class="operator">=</span> map.getOrDefault(aChar, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                map.put(aChar, Boolean.TRUE);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value) &#123;</span><br><span class="line">                map.put(aChar, Boolean.FALSE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Boolean&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue()) &#123;</span><br><span class="line">                <span class="keyword">return</span> entry.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="51、数组中的逆序对"><a href="#51、数组中的逆序对" class="headerlink" title="51、数组中的逆序对"></a><font color="red">51、数组中的逆序对</font></h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">0 &lt;= 数组长度 &lt;= 50000</span><br></pre></td></tr></table></figure></div>

<div class="note-large red"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>归并排序的变形</p>
<p>需要知晓该元素后的每个元素的大小关系，且肯定不能是O(n^2^)的算法，只有归并排序符合要求</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">return</span> mergeSort(nums, <span class="number">0</span>, n - <span class="number">1</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 采用归并排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums  待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp  临时存放数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="comment">//只有一个元素 没有逆序对</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//求出左边数组的逆序对</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftPairs</span> <span class="operator">=</span> mergeSort(nums, left, mid, temp);</span><br><span class="line">        <span class="comment">//求出右边数组的逆序对</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightParis</span> <span class="operator">=</span> mergeSort(nums, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">        <span class="comment">//由于左右两个数组均有序，若左数组的最后一个节点 &lt;= 右数组的最后一个节点</span></span><br><span class="line">        <span class="comment">//则整个【left，right】有序，这些元素不会贡献逆序对</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftPairs + rightParis;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算两个数组的元素 贡献的逆序对</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">crossPairs</span> <span class="operator">=</span> mergeAndCount(nums, left, mid, right, temp);</span><br><span class="line">        <span class="keyword">return</span> leftPairs + rightParis + crossPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">mergeAndCount</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="comment">//临时存放元素</span></span><br><span class="line">        <span class="keyword">if</span> (right + <span class="number">1</span> - left &gt;= <span class="number">0</span>) System.arraycopy(nums, left, temp, left, right + <span class="number">1</span> - left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; k &lt;= right; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//左数组已经全部遍历完毕</span></span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == right + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//右数组已经全部遍历完毕</span></span><br><span class="line">                nums[k] = temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &lt;= temp[j]) &#123;</span><br><span class="line">                <span class="comment">//左节点小于等于右节点</span></span><br><span class="line">                nums[k] = temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//左节点大于右节点 会贡献逆序对</span></span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j++;</span><br><span class="line">                count += (mid - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="52、两个链表的第一个公共节点"><a href="#52、两个链表的第一个公共节点" class="headerlink" title="52、两个链表的第一个公共节点"></a><font color="green">52、两个链表的第一个公共节点</font></h2><p>输入两个链表，找出它们的第一个公共节点。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例1：</span><br><span class="line">   a1-&gt;a2</span><br><span class="line">         c1-&gt;c2-&gt;c3</span><br><span class="line">b1-&gt;b2-&gt;b3</span><br><span class="line">则返回c1</span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">2-&gt;6-&gt;4</span><br><span class="line">1-&gt;5</span><br><span class="line">则返回null</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：</strong></p>
<ul>
<li>如果两个链表没有交点，返回 <code>null</code>.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li>
<li>本题与主站 160 题相同：<a class="link"   href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" >https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>最直观的想法是把两个链表的元素都存到Set中，边遍历边存边校验是否存在，但耗时比较大</p>
<p>看到一个方法，设置两个指针A和B分别遍历链表1和链表2，当A遍历完1和从2开始遍历，B类似。这样最多在第二轮遍历时，A和B就会同时到第一个相同的节点(或者同时遍历到链表末尾，即null)</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA, p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            p1 = p1 == <span class="literal">null</span> ? headB : p1.next;</span><br><span class="line">            p2 = p2 == <span class="literal">null</span> ? headA : p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="53-1、在排序数组中查找数字Ⅰ"><a href="#53-1、在排序数组中查找数字Ⅰ" class="headerlink" title="53-1、在排序数组中查找数字Ⅰ"></a><font color="green">53-1、在排序数组中查找数字Ⅰ</font></h2><p>统计一个数字在排序数组中出现的次数。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">- 0 &lt;= nums.length &lt;= 105</span><br><span class="line">- -109 &lt;= nums[i] &lt;= 109</span><br><span class="line">- nums 是一个非递减数组</span><br><span class="line">- -109 &lt;= target &lt;= 109</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：</strong>本题与主站 34 题相同（仅返回值不同）：<a class="link"   href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" >https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>可以分为两步来做，先是定位到任意一个目标值，再往前往后统计目标值数量</p>
<p>因为是有序数组，第一步，可以使用二分查找</p>
<p>第二步直接用下标遍历即可，因为相等的值就在附近</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> nums[mid];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (midVal &lt; target)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; target)</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找到任意一个目标值，往前往后遍历，统计目标值数量即可</span></span><br><span class="line">                <span class="keyword">return</span> count(nums, mid, target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> index;</span><br><span class="line">        <span class="keyword">while</span>(temp &lt; nums.length &amp;&amp; target == nums[temp])&#123;</span><br><span class="line">            count++;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp &gt;= <span class="number">0</span> &amp;&amp; target == nums[temp])&#123;</span><br><span class="line">            count++;</span><br><span class="line">            temp--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="53-2、0-n-1中缺失的数字"><a href="#53-2、0-n-1中缺失的数字" class="headerlink" title="53-2、0~n-1中缺失的数字"></a><font color="green">53-2、0~n-1中缺失的数字</font></h2><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 &lt;= 数组长度 &lt;= 10000</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>如数组[0,1,3]，其长度为3即数字为0，1，2，3</p>
<p>因为数组是递增的，且只缺一个数，那么只需要拿元素和其下标比对即可，第一个不同的下标就是缺少的数字</p>
<p>如果遍历完没有匹配到，那只可能是[0,1,2]这种情况，那么返回数组的长度即3</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != nums[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="54、二叉搜索树的第k大节点"><a href="#54、二叉搜索树的第k大节点" class="headerlink" title="54、二叉搜索树的第k大节点"></a><font color="green">54、二叉搜索树的第k大节点</font></h2><p>给定一棵二叉搜索树，请找出其中第 <code>k</code> 大的节点的值。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 ≤ k ≤ 二叉搜索树元素个数</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>二叉搜索树的特性，右子树&gt;根节点&gt;左子树</p>
<p>因此，只需要递归遍历，先右子树再根节点再左子树(即可保证从大到小遍历)，每遍历一个节点就计数，当到达第k大时，返回该值即可</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            kthLargest(root.right, k);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">            val = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            kthLargest(root.left, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="55-1、二叉树的深度"><a href="#55-1、二叉树的深度" class="headerlink" title="55-1、二叉树的深度"></a><font color="green">55-1、二叉树的深度</font></h2><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">给定二叉树 `[3,9,20,null,null,15,7]`，</span><br><span class="line">   3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1. `节点总数 &lt;= 10000`</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 104 题相同：<a class="link"   href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" >https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>直接递归即可</p>
<p>有一个点是：要求深度最大值，最好是设一个成员变量在递归体之外，用于记录最大值，这样实现起来会轻松很多</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        findMaxDepth(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findMaxDepth</span><span class="params">(TreeNode node, <span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            max = Math.max(max, depth);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">        findMaxDepth(node.left, depth);</span><br><span class="line">        findMaxDepth(node.right, depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="55-2、平衡二叉树"><a href="#55-2、平衡二叉树" class="headerlink" title="55-2、平衡二叉树"></a><font color="green">55-2、平衡二叉树</font></h2><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">给定二叉树 `[3,9,20,null,null,15,7]`</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回 `true`</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">给定二叉树 `[1,2,2,3,3,null,null,4,4]`</span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   2</span><br><span class="line">    / \</span><br><span class="line">   3   3</span><br><span class="line">  / \</span><br><span class="line"> 4   4</span><br><span class="line"> 返回 `false`</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">- `0 &lt;= 树的结点个数 &lt;= 10000`</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 110 题相同：<a class="link"   href="https://leetcode-cn.com/problems/balanced-binary-tree/" >https://leetcode-cn.com/problems/balanced-binary-tree/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>求深度的变式，每次求完左右子树的深度后，需要判断一下两者差值是否大于1，如果大于1了则无需再遍历了</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> balance;</span><br><span class="line">        &#125;</span><br><span class="line">        check(root);</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">check</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!balance) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            leftDepth = check(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            rightDepth = check(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(leftDepth - rightDepth) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            balance = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="56-1、数组中数字出现的次数"><a href="#56-1、数组中数字出现的次数" class="headerlink" title="56-1、数组中数字出现的次数"></a><font color="orange">56-1、数组中数字出现的次数</font></h2><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">- `2 &lt;= nums.length &lt;= 10000`</span><br></pre></td></tr></table></figure></div>

<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>第一想法是用set，但是不符合空间复杂度O(1)的要求</p>
<p>然后看到相关词条有位运算，想到用一个二进制数值，若2则左移两位执行异或操作，最后两个1就是所求的值。但数组长度最大为10000，也就是说最大值也在5000左右，这个方法也不合理</p>
<p>然后看到别人的解法，也是异或，但还是不太理解，对位运算还是接触太少</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumbers(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xorNumber</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;nums.length; k++)&#123;</span><br><span class="line">            xorNumber ^=nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">onePosition</span> <span class="operator">=</span> xorNumber&amp;(-xorNumber);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> <span class="number">0</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; onePosition) == onePosition) &#123;</span><br><span class="line">                ans1 ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans2 ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;ans1, ans2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="56-2、数组中数字出现的次数Ⅱ"><a href="#56-2、数组中数字出现的次数Ⅱ" class="headerlink" title="56-2、数组中数字出现的次数Ⅱ"></a><font color="orange">56-2、数组中数字出现的次数Ⅱ</font></h2><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [3,4,3,3]</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">- `1 &lt;= nums.length &lt;= 10000`</span><br><span class="line">- `1 &lt;= nums[i] &lt; 2^31`</span><br></pre></td></tr></table></figure></div>

<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>如果要位运算实现的话没啥思路，能想到的也就是排序或者set</p>
<p>目前位运算这块是最薄弱的一类了，后续考虑挑点这块的题做个专项提升</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;<span class="comment">//本算法同样适用于数组nums中存在负数的情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//输入数组长度不符合要求，返回-1;</span></span><br><span class="line">        <span class="type">int</span>[] bitSum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];<span class="comment">//java int类型有32位，其中首位为符号位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bitMask</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//需要在这里初始化，不能和res一起初始化</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//bitSum[0]为符号位</span></span><br><span class="line">                <span class="comment">//这里同样可以通过num的无符号右移&gt;&gt;&gt;来实现，否则带符号右移(&gt;&gt;)左侧会补符号位，对于负数会出错。</span></span><br><span class="line">                <span class="comment">//但是不推荐这样做，最好不要修改原数组nums的数据</span></span><br><span class="line">                <span class="keyword">if</span> ((num &amp; bitMask) != <span class="number">0</span>) bitSum[i]++;<span class="comment">//这里判断条件也可以写为(num&amp;bitMask)==bitMask,而不是==1</span></span><br><span class="line">                bitMask = bitMask &lt;&lt; <span class="number">1</span>;<span class="comment">//左移没有无符号、带符号的区别，都是在右侧补0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;<span class="comment">//这种做法使得本算法同样适用于负数的情况</span></span><br><span class="line">            res = res &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            res += bitSum[i] % <span class="number">3</span>;<span class="comment">//这两步顺序不能变，否则最后一步会多左移一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="57-1、和为s的两个数字"><a href="#57-1、和为s的两个数字" class="headerlink" title="57-1、和为s的两个数字"></a><font color="green">57-1、和为s的两个数字</font></h2><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [10,26,30,31,47,60], target = 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">- `1 &lt;= nums.length &lt;= 10^5`</span><br><span class="line">- `1 &lt;= nums[i] &lt;= 10^6`</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>设置两个指针，A指针从头向尾遍历，B指针从尾向头遍历</p>
<p>两个指针的元素和大于目标值则B指针前移，小于目标值则A指针后移</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">big</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(small &lt;= big)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> nums[small] + nums[big];</span><br><span class="line">            <span class="keyword">if</span>(value &gt; target)&#123;</span><br><span class="line">                big--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(value &lt; target)&#123;</span><br><span class="line">                small++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[small], nums[big]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="57-2、和为s的连续正数序列"><a href="#57-2、和为s的连续正数序列" class="headerlink" title="57-2、和为s的连续正数序列"></a><font color="green">57-2、和为s的连续正数序列</font></h2><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：target = 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：target = 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 &lt;= target &lt;= 10^5</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>双指针圈出一个范围，范围内的数值和大于目标值，移动小值，反之移动大值</p>
<p>注意这里有一个可以剪枝的点，如15，最大就是7和8，如果大值到了9，那么15-9&#x3D;6，已经不符合连续的要求了。因此利用这一点可以只循环[1,n&#x2F;2+1]，节约近一半的时间</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] findContinuousSequence(<span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> <span class="number">1</span>,big = <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">biggest</span> <span class="operator">=</span> target / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(big &lt;= biggest)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                big++;</span><br><span class="line">                sum += big;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                sum -= small;</span><br><span class="line">                small++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[big - small + <span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> small; i &lt;= big; i++) &#123;</span><br><span class="line">                    res[index++] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(res);</span><br><span class="line">                big++;</span><br><span class="line">                sum += big;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="58-1、翻转单词顺序"><a href="#58-1、翻转单词顺序" class="headerlink" title="58-1、翻转单词顺序"></a><font color="green">58-1、翻转单词顺序</font></h2><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">- 无空格字符构成一个单词。</span><br><span class="line">- 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line">- 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：</strong>本题与主站 151 题相同：<a class="link"   href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" >https://leetcode-cn.com/problems/reverse-words-in-a-string/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>注意：</strong>此题对比原题有改动</p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>依旧使用双指针来做即可，跟据遍历到字符的不同做不同的事情来划分出每个单词：</p>
<ul>
<li>遍历到空格，两个指针指在同一个元素。代表首尾空格或者单词间的冗余空格，忽略即可</li>
<li>遍历到空格，两个指针不在同一个元素，代表单词前的第一个空格，执行划分单词的逻辑</li>
<li>遍历到非空格，小指针前移，大指针不动</li>
</ul>
<p>另外提一下，Java中提供了split方法，按照空格划分可以实现，但split方法基于正则实现效率非常差(8ms)，除非真的要使用正则，否则不推荐使用</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">big</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(small == big)&#123;</span><br><span class="line">                    small--;</span><br><span class="line">                    big--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    builder.append(s, small + <span class="number">1</span>, big + <span class="number">1</span>).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                    small--;</span><br><span class="line">                    big = small;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                small--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(small != big)&#123;</span><br><span class="line">            builder.append(s, small + <span class="number">1</span>, big + <span class="number">1</span>).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(builder.length() != <span class="number">0</span>)&#123;</span><br><span class="line">            builder.deleteCharAt(builder.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="58-2、左旋转字符串"><a href="#58-2、左旋转字符串" class="headerlink" title="58-2、左旋转字符串"></a><font color="green">58-2、左旋转字符串</font></h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: s = &quot;lrloseumgh&quot;, k = 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 &lt;= k &lt; s.length &lt;= 10000</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>按照给定的n执行substring，切出两段字符串再拼接</p>
<p>当然也可以用双指针来切割，但是有契合且效率很好的现成方法，就没必要自己造轮子</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> s.substring(<span class="number">0</span>, n);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.substring(n);</span><br><span class="line">        <span class="keyword">return</span> s2 + s1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="59-1、滑动窗口的最大值"><a href="#59-1、滑动窗口的最大值" class="headerlink" title="59-1、滑动窗口的最大值"></a><font color="red">59-1、滑动窗口的最大值</font></h2><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line">  滑动窗口的位置              最大值</span><br><span class="line">---------------              -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7        3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7        3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7        5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7        5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7        6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]       7</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">你可以假设 *k* 总是有效的，在输入数组 不为空 的情况下，1 ≤ k ≤ nums.length</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 239 题相同：<a class="link"   href="https://leetcode-cn.com/problems/sliding-window-maximum/" >https://leetcode-cn.com/problems/sliding-window-maximum/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large red"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>初步想法是用优先队列，始终保持优先队列中的元素是滑动窗口的元素，这样最大值可以很便捷的获得，但超时了(主要是维护堆的耗时，)</p>
<p>后来看了别人的手法，队列中存的是元素下标，且在存入时比较大小关系</p>
<p>队列中的下标，从队首到队尾依次递增；下标对应的元素从队首到队尾依次递减；通过下标的大小关系来判断是否移除队首</p>
<p>算是完美契合的题目的要求，Hard难度的题感觉很需要题感，光会一个通用解法还是不够</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 窗口个数</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历数组中元素，right表示滑动窗口右边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 如果队列不为空且当前考察元素大于等于队尾元素，则将队尾元素移除。</span></span><br><span class="line">            <span class="comment">// 直到，队列为空或当前考察元素小于新的队尾元素</span></span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; nums[right] &gt;= nums[queue.peekLast()]) &#123;</span><br><span class="line">                queue.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 存储元素下标</span></span><br><span class="line">            queue.addLast(right);</span><br><span class="line">            <span class="comment">// 计算窗口左侧边界</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> right - k +<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 当队首元素的下标小于滑动窗口左侧边界left时</span></span><br><span class="line">            <span class="comment">// 表示队首元素已经不再滑动窗口内，因此将其从队首移除</span></span><br><span class="line">            <span class="keyword">if</span> (queue.peekFirst() &lt; left) &#123;</span><br><span class="line">                queue.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 由于数组下标从0开始，因此当窗口右边界right+1大于等于窗口大小k时</span></span><br><span class="line">            <span class="comment">// 意味着窗口形成。此时，队首元素就是该窗口内的最大值</span></span><br><span class="line">            <span class="keyword">if</span> (right +<span class="number">1</span> &gt;= k) &#123;</span><br><span class="line">                res[left] = nums[queue.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="59-2、队列的最大值"><a href="#59-2、队列的最大值" class="headerlink" title="59-2、队列的最大值"></a><font color="orange">59-2、队列的最大值</font></h2><p>请定义一个队列并实现函数 <code>max_value</code> 得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code> 的<strong>均摊</strong>时间复杂度都是O(1)。</p>
<p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">- `1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000`</span><br><span class="line">- `1 &lt;= value &lt;= 10^5`</span><br></pre></td></tr></table></figure></div>

<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>即要保证先进先出，还需要有堆的特性。维护单调队列</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; deque;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max_value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty() ? -<span class="number">1</span> :deque.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        queue.offer(value);</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast()&lt; value)</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        deque.offerLast(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop_front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(queue.peek().equals(deque.peekFirst()))</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="60、n个骰子的点数"><a href="#60、n个骰子的点数" class="headerlink" title="60、n个骰子的点数"></a><font color="orange">60、n个骰子的点数</font></h2><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
<p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 2</span><br><span class="line">输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 &lt;= n &lt;= 11</span><br></pre></td></tr></table></figure></div>

<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>动态规划题，重点就是如果使用n-1的解推出n，以及中间过程的存储方式</p>
<p>这里如2个骰子，可以看出1个骰子的基础上再来一个骰子</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span>[] dicesProbability(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">double</span>[] pre = &#123;<span class="number">1</span> / <span class="number">6d</span>, <span class="number">1</span> / <span class="number">6d</span>, <span class="number">1</span> / <span class="number">6d</span>, <span class="number">1</span> / <span class="number">6d</span>, <span class="number">1</span> / <span class="number">6d</span>, <span class="number">1</span> / <span class="number">6d</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">double</span>[] tmp = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">5</span> * i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; pre.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 在原来的基础上，分别再加上一个骰子的1~6情况</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; <span class="number">6</span>; x++) &#123;</span><br><span class="line">                    tmp[j + x] += pre[j] / <span class="number">6</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>剑指Offer_Part.4</title>
    <url>/2023/07/17/algorithm/offer/%E5%89%91%E6%8C%87Offer_Part4/</url>
    <content><![CDATA[<h2 id="61、扑克牌中的顺子"><a href="#61、扑克牌中的顺子" class="headerlink" title="61、扑克牌中的顺子"></a><font color="green">61、扑克牌中的顺子</font></h2><p>从<strong>若干副扑克牌</strong>中随机抽 <code>5</code> 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">数组长度为 5</span><br><span class="line">数组的数取值为 [0, 13]</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>首先需要进行排序，然后遍历数组</p>
<p>有两种情况出现，可以判定非顺子</p>
<ul>
<li>有两个非0值相同</li>
<li>两个值之间有差距且0的数量不足。如2和5，中间少了3和4，需要用0来补，如果0不够补则不是顺子</li>
</ul>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">jokerCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i - <span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                jokerCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sub</span> <span class="operator">=</span> nums[i] - nums[i - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(sub != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(jokerCount &lt; sub)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        jokerCount -= Math.abs(sub);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="62、圆圈中最后剩下的数字"><a href="#62、圆圈中最后剩下的数字" class="headerlink" title="62、圆圈中最后剩下的数字"></a><font color="green">62、圆圈中最后剩下的数字</font></h2><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: n = 5, m = 3</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: n = 10, m = 17</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">- 1 &lt;= n &lt;= 10^5</span><br><span class="line">- 1 &lt;= m &lt;= 10^6</span><br></pre></td></tr></table></figure></div>

<div class="note success"><h3 id="备注1、约瑟夫环"><a href="#备注1、约瑟夫环" class="headerlink" title="备注1、约瑟夫环"></a>备注1、约瑟夫环</h3><p>约瑟夫环问题，有推导公式</p>
<p>f(N,M)&#x3D;(f(N−1,M)+M)%N</p>
</div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            k = (k + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="63、股票的最大利润"><a href="#63、股票的最大利润" class="headerlink" title="63、股票的最大利润"></a><font color="orange">63、股票的最大利润</font></h2><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">0 &lt;= 数组长度 &lt;= 10^5</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：</strong>本题与主站 121 题相同：<a class="link"   href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" >https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>可以用贪心算法，遍历数据</p>
<ul>
<li>出现价格低于买入价，替换买入价并将卖出价置0</li>
<li>出现价格高于卖出价，替换卖出价并更新当前盈亏和最大盈亏</li>
</ul>
<p>最终的最大盈亏就是所求值</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sell</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> prices[i];</span><br><span class="line">            <span class="comment">// 遍历到比买入价更低的价格，直接替换买入价</span></span><br><span class="line">            <span class="keyword">if</span> (price &lt; buy) &#123;</span><br><span class="line">                buy = price;</span><br><span class="line">                sell = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 出现更高的卖出价，更新最大盈亏</span></span><br><span class="line">            <span class="keyword">if</span> (price &gt; sell) &#123;</span><br><span class="line">                sell = price;</span><br><span class="line">                profit = Math.max(profit, sell - buy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="64、求1-2-…-n"><a href="#64、求1-2-…-n" class="headerlink" title="64、求1+2+…+n"></a><font color="orange">64、求1+2+…+n</font></h2><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: n = 3</span><br><span class="line">输出: 6</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: n = 9</span><br><span class="line">输出: 45</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 &lt;= n &lt;= 10000</span><br></pre></td></tr></table></figure></div>

<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>不能乘除也就是不能用公式计算，不能循环也就是不能正常从1加到n</p>
<p>因此只剩下递归，因为递归可以替换循环，但不能用if，也就是递归的终止条件受到限制，需要利用逻辑运算符的短路特性(&amp;&amp; ||)</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> n &gt; <span class="number">1</span> &amp;&amp; sumNums(n - <span class="number">1</span>) &gt; <span class="number">0</span>;</span><br><span class="line">        res += n;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="65、不用加减乘除做加法"><a href="#65、不用加减乘除做加法" class="headerlink" title="65、不用加减乘除做加法"></a><font color="green">65、不用加减乘除做加法</font></h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“&#x2F;” 四则运算符号。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: a = 1, b = 1</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">- `a`, `b` 均可能是负数或 0</span><br><span class="line">- 结果不会溢出 32 位整数</span><br></pre></td></tr></table></figure></div>

<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>基于位运算来实现</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> a ^ b;</span><br><span class="line">        <span class="keyword">return</span> add(a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="66、构建乘积数组"><a href="#66、构建乘积数组" class="headerlink" title="66、构建乘积数组"></a><font color="orange">66、构建乘积数组</font></h2><p>给定一个数组 <code>A[0,1,…,n-1]</code>，请构建一个数组 <code>B[0,1,…,n-1]</code>，其中 <code>B[i]</code> 的值是数组 <code>A</code> 中除了下标 <code>i</code> 以外的元素的积, 即 <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code>。不能使用除法。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">- 所有元素乘积之和不会溢出 32 位整数</span><br><span class="line">- `a.length &lt;= 100000`</span><br></pre></td></tr></table></figure></div>

<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>最简单的方法是把所有的元素乘起来，然后遍历依次除当前元素，但不能用除法</p>
<p>所以只能遍历两遍，分别乘元素左边和元素右边的元素</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] constructArr(<span class="type">int</span>[] a) &#123;</span><br><span class="line">        <span class="comment">//边界条件的判断</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span> || a.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当前元素左边的所有元素乘积（不包含当前元素）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] * a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//right表示当前元素右边所有元素的乘积（不包含当前元素）,</span></span><br><span class="line">        <span class="comment">//res[i]表示的是左边的乘积，他俩相乘就是</span></span><br><span class="line">        <span class="comment">//除了自己以外数组的乘积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] *= right;</span><br><span class="line">            right *= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="67、把字符串转换成整数"><a href="#67、把字符串转换成整数" class="headerlink" title="67、把字符串转换成整数"></a><font color="orange">67、把字符串转换成整数</font></h2><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明：</span><br><span class="line">假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。因此无法执行有效的转换。</span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 8 题相同：<a class="link"   href="https://leetcode-cn.com/problems/string-to-integer-atoi/" >https://leetcode-cn.com/problems/string-to-integer-atoi/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>跟据各类情况来分类讨论，实现起来很繁琐</p>
<p>主要的坑有+&#x2F;-号，空格的不同情况(如  42是42，1 123是1)，0的不同情况(+0是0，000123是123)，int范围</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strToInt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//1跳过空格</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; str.length() &amp;&amp; str.charAt(i) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(i == str.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//2判断正负</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            x = -<span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3第一个数字字符位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">//4 i继续遍历，找最后一个数字字符（也即第一个非数字字符）</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; str.length() &amp;&amp; str.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; str.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(i == j)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//跳过开头连续的多个0</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt; i &amp;&amp; str.charAt(j) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5边界判断</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> i-j;</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">10</span> &amp;&amp; x == -<span class="number">1</span> || len == <span class="number">10</span> &amp;&amp; x == -<span class="number">1</span> &amp;&amp; str.substring(j, i).compareTo(<span class="string">&quot;2147483648&quot;</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">10</span> &amp;&amp; x == <span class="number">1</span> || len == <span class="number">10</span> &amp;&amp; x == <span class="number">1</span> &amp;&amp; str.substring(j, i).compareTo(<span class="string">&quot;2147483647&quot;</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6计算并返回结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; i)&#123;</span><br><span class="line">            result = result * <span class="number">10</span> + (str.charAt(j) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x * result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="68-1、二叉搜索树的最近公共祖先"><a href="#68-1、二叉搜索树的最近公共祖先" class="headerlink" title="68-1、二叉搜索树的最近公共祖先"></a><font color="green">68-1、二叉搜索树的最近公共祖先</font></h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">- 所有节点的值都是唯一的。</span><br><span class="line">- p、q 为不同节点且均存在于给定的二叉搜索树中。</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 235 题相同：<a class="link"   href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" >https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>利用二叉搜索树左子树节点&lt;根节点&lt;右子树节点的特点，如果pq两个节点满足<code>p≤root≤q</code>或者<code>q≤root≤p</code>，则root就是最近的公共组件</p>
<p>而如果pq均小于root，那么root往左子树遍历，反之往右子树遍历，直到出现root符合上面的条件</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val &lt; root.val &amp;&amp; q.val &lt; root.val)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p.val &gt; root.val &amp;&amp; q.val &gt; root.val)&#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="68-2、二叉树的最近公共祖先"><a href="#68-2、二叉树的最近公共祖先" class="headerlink" title="68-2、二叉树的最近公共祖先"></a><font color="green">68-2、二叉树的最近公共祖先</font></h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">- 所有节点的值都是唯一的。</span><br><span class="line">- p、q 为不同节点且均存在于给定的二叉树中。</span><br></pre></td></tr></table></figure></div>

<p>注意：本题与主站 236 题相同：<a class="link"   href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" >https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>跟68-1相比，去掉了二叉搜索树条件，也就不能跟据节点值的大小关系判断节点的位置。</p>
<p>因此只能遍历二叉树，需要以下任一条件，即为最近公共祖先</p>
<ul>
<li>左子树和右子树中各有一个目标节点</li>
<li>当前节点就是目标节点，且左子树或右子树中有一个目标节点</li>
</ul>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode node;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        find(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取到当前节点以及左右子树中是否存在pq</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">curr</span> <span class="operator">=</span> root.val == p.val || root.val == q.val;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, p, q);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, p, q);</span><br><span class="line">        <span class="comment">// 已经找到公共祖先了，不做后续处理</span></span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右子树中均有目标节点pq，则当前节点为最近公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right)&#123;</span><br><span class="line">            node = root;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(curr &amp;&amp; (left || right))&#123;</span><br><span class="line">            <span class="comment">// 当前节点为pq中的一个，且左右子树中存在另一个目标节点，当前节点为最近公共祖先</span></span><br><span class="line">            node = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有找到祖先，将本节点和左右子树节点情况往上传递，本节点左右子树中有一个为true即传true</span></span><br><span class="line">        <span class="keyword">return</span> curr || left || right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="阶段总结"><a href="#阶段总结" class="headerlink" title="阶段总结"></a>阶段总结</h2><p>这一系列刷完了，目前来说：</p>
<ul>
<li>二叉树的题已经掌握，主要就是递归实现深度遍历，队列实现广度遍历以及二叉搜索树和前中后序遍历</li>
<li>动态规划类，主要的难点在于如果跟据n-1推出n，还需要多做题来练感觉，以及部分题可以用贪心来解</li>
<li>位运算这块目前看是最薄弱的，因为日常开发中也不会接触位操作，对于一些规律还没有理解</li>
<li>剩下一类算是笼统的积累题，就是一些公式或者规律的应用，就是见招拆招。这类没有太好的办法，目前只能多做题</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title>LCR_Part.3</title>
    <url>/2023/10/25/algorithm/LCR/LCR_Part3/</url>
    <content><![CDATA[<h2 id="41、数据流中的移动平均值"><a href="#41、数据流中的移动平均值" class="headerlink" title="41、数据流中的移动平均值"></a><font color="green">41、数据流中的移动平均值</font></h2><p>给定一个窗口大小和一个整数数据流，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。</p>
<p>实现 <code>MovingAverage</code> 类：</p>
<ul>
<li><code>MovingAverage(int size)</code> 用窗口大小 <code>size</code> 初始化对象。</li>
<li><code>double next(int val)</code> 成员函数 <code>next</code> 每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 <code>size</code> 个值的移动平均值，即滑动窗口里所有数字的平均值。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：</span><br><span class="line">inputs = [&quot;MovingAverage&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;]</span><br><span class="line">inputs = [[3], [1], [10], [3], [5]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1.0, 5.5, 4.66667, 6.0]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MovingAverage movingAverage = new MovingAverage(3);</span><br><span class="line">movingAverage.next(1); // 返回 1.0 = 1 / 1</span><br><span class="line">movingAverage.next(10); // 返回 5.5 = (1 + 10) / 2</span><br><span class="line">movingAverage.next(3); // 返回 4.66667 = (1 + 10 + 3) / 3</span><br><span class="line">movingAverage.next(5); // 返回 6.0 = (10 + 3 + 5) / 3</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= size &lt;= 1000</code></li>
<li><code>-10^5 &lt;= val &lt;= 10^5</code></li>
<li>最多调用 <code>next</code> 方法 <code>10^4</code> 次</li>
</ul>
<p>注意：本题与主站 346 题相同： <a class="link"   href="https://leetcode-cn.com/problems/moving-average-from-data-stream/" >https://leetcode-cn.com/problems/moving-average-from-data-stream/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>数据流的特征是先进先出，因此可以确定保存窗口内的元素需要使用队列。此外为了避免每次都要计算队列内元素的和，可以维护一个变量sum，减少重复求和</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MovingAverage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;Integer&gt; deque;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovingAverage</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deque.size() &gt;= size) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">remove</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">            sum -= remove;</span><br><span class="line">        &#125;</span><br><span class="line">        deque.add(val);</span><br><span class="line">        sum += val;</span><br><span class="line">        <span class="keyword">return</span> sum / deque.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="42、最近的请求次数"><a href="#42、最近的请求次数" class="headerlink" title="42、最近的请求次数"></a><font color="green">42、最近的请求次数</font></h2><p>写一个 <code>RecentCounter</code> 类来计算特定时间范围内最近的请求。</p>
<p>请实现 <code>RecentCounter</code> 类：</p>
<ul>
<li><code>RecentCounter()</code> 初始化计数器，请求数为 0 。</li>
<li><code>int ping(int t)</code> 在时间 <code>t</code> 添加一个新请求，其中 <code>t</code> 表示以毫秒为单位的某个时间，并返回过去 <code>3000</code> 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 <code>[t-3000, t]</code> 内发生的请求数。</li>
</ul>
<p><strong>保证</strong> 每次对 <code>ping</code> 的调用都使用比之前更大的 <code>t</code> 值。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：</span><br><span class="line">inputs = [&quot;RecentCounter&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;]</span><br><span class="line">inputs = [[], [1], [100], [3001], [3002]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, 2, 3, 3]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">RecentCounter recentCounter = new RecentCounter();</span><br><span class="line">recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1</span><br><span class="line">recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2</span><br><span class="line">recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3</span><br><span class="line">recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= t &lt;= 10^9</code></li>
<li>保证每次对 <code>ping</code> 调用所使用的 <code>t</code> 值都 <strong>严格递增</strong></li>
<li>至多调用 <code>ping</code> 方法 <code>10^4</code> 次</li>
</ul>
<p>注意：本题与主站 933 题相同： <a class="link"   href="https://leetcode-cn.com/problems/number-of-recent-calls/" >https://leetcode-cn.com/problems/number-of-recent-calls/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large green"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>因为每次给的t都是递增的，可以将t插入到队列尾部，并从队列首部开始移除小于t-3000的元素</p>
<p>那么请求次数就是队列中元素的个数</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecentCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;Integer&gt; deque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RecentCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ping</span><span class="params">(<span class="type">int</span> t)</span> &#123;</span><br><span class="line">        deque.offer(t);</span><br><span class="line">        <span class="keyword">while</span>(deque.peek() &lt; t - <span class="number">3000</span>)&#123;</span><br><span class="line">            deque.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deque.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="43、完全二叉树插入器"><a href="#43、完全二叉树插入器" class="headerlink" title="43、完全二叉树插入器"></a><font color="orange">43、完全二叉树插入器</font></h2><p>完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大，第 <code>n</code> 层有 <code>2n-1</code> 个节点）的，并且所有的节点都尽可能地集中在左侧。</p>
<p>设计一个用完全二叉树初始化的数据结构 <code>CBTInserter</code>，它支持以下几种操作：</p>
<ul>
<li><code>CBTInserter(TreeNode root)</code> 使用根节点为 <code>root</code> 的给定树初始化该数据结构；</li>
<li><code>CBTInserter.insert(int v)</code> 向树中插入一个新节点，节点类型为 <code>TreeNode</code>，值为 <code>v</code> 。使树保持完全二叉树的状态，<strong>并返回插入的新节点的父节点的值</strong>；</li>
<li><code>CBTInserter.get_root()</code> 将返回树的根节点。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1]],[2],[]]</span><br><span class="line">输出：[null,1,[1,2]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]</span><br><span class="line">输出：[null,3,4,[1,2,3,4,5,6,7,8]]</span><br></pre></td></tr></table></figure></div>

<p><strong>提示：</strong></p>
<ul>
<li>最初给定的树是完全二叉树，且包含 <code>1</code> 到 <code>1000</code> 个节点。</li>
<li>每个测试用例最多调用 <code>CBTInserter.insert</code> 操作 <code>10000</code> 次。</li>
<li>给定节点或插入节点的每个值都在 <code>0</code> 到 <code>5000</code> 之间。</li>
</ul>
<p>注意：本题与主站 919 题相同： <a class="link"   href="https://leetcode-cn.com/problems/complete-binary-tree-inserter/" >https://leetcode-cn.com/problems/complete-binary-tree-inserter/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="note-large orange"><div class="notel-title"><p>题解思路</p>
</div><div class="notel-content"><p>构建完全二叉树其实就是二叉树的广度遍历，那就要使用到队列：将子树不完全的结点放入队列，每次将新元素作为队首结点的左或右结点，并插入队列</p>
<p>但是这里有个点是，初始化给的root结点，可以也有子结点，所以还需要将队列先做处理才能使用</p>
</div></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CBTInserter</span> &#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    TreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CBTInserter</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">        deque.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.peek();</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 左右子树都有的结点，将左右结点入队列，并移除该结点</span></span><br><span class="line">                deque.pop();</span><br><span class="line">                deque.offer(node.left);</span><br><span class="line">                deque.offer(node.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 只有左子树，说明遍历到目标结点了，左结点入队列，并结束</span></span><br><span class="line">                deque.offer(node.left);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 都没有，也是一种目标结点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.peek();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">insert</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span>)&#123;</span><br><span class="line">            node.left = insert;</span><br><span class="line">            deque.offer(insert);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.right = insert;</span><br><span class="line">            deque.offer(insert);</span><br><span class="line">            deque.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">get_root</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offerⅡ</category>
      </categories>
  </entry>
  <entry>
    <title>mermaid语法大全</title>
    <url>/2023/10/25/util/mermaid/</url>
    <content><![CDATA[<p>官方文档：<a class="link"   href="https://mermaid.js.org/intro/" >About Mermaid | Mermaid <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>mermaid中提供了10+种图形，但一些图形用的比较少。另外奇怪的是，为什么没有提供柱状图和折线图</p>
<h2 id="一、流程图"><a href="#一、流程图" class="headerlink" title="一、流程图"></a>一、流程图</h2><p>流程图使用非常多，当一些逻辑比较复杂时，用一堆文字去描述的效果往往不如一张流程图</p>
<p>使用<code>flowchart</code>来定义流程图</p>
<h3 id="1-1-绘图方向"><a href="#1-1-绘图方向" class="headerlink" title="1.1 绘图方向"></a>1.1 绘图方向</h3><table>
<thead>
<tr>
<th>方向代码</th>
<th>方向</th>
</tr>
</thead>
<tbody><tr>
<td>TB</td>
<td>从上到下</td>
</tr>
<tr>
<td>TD</td>
<td>自上而下&#x2F;与上到下相同</td>
</tr>
<tr>
<td>BT</td>
<td>从下到上</td>
</tr>
<tr>
<td>RL</td>
<td>从右到左</td>
</tr>
<tr>
<td>LR</td>
<td>从左到右</td>
</tr>
</tbody></table>
<p>示例：LR即从左到右</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    Start --&gt; Stop</span><br></pre></td></tr></table></figure></div>
<pre class="mermaid">flowchart LR
    Start --> Stop</pre>

<h3 id="1-2-结点形状"><a href="#1-2-结点形状" class="headerlink" title="1.2 结点形状"></a>1.2 结点形状</h3><p>在方向示例中可以看到，结点的默认形状是一个矩形，而例如流程图中形状也有不同含义</p>
<table>
<thead>
<tr>
<th>形状代码</th>
<th>形状</th>
</tr>
</thead>
<tbody><tr>
<td><code>node</code></td>
<td>默认矩形，但图形内的文字就是node</td>
</tr>
<tr>
<td><code>node[text]</code></td>
<td>矩形，图形内文字为括号[]中的文字</td>
</tr>
<tr>
<td><code>node(text)</code></td>
<td>圆角矩形</td>
</tr>
<tr>
<td><code>node([text])</code></td>
<td>半圆矩阵，即常用的流程图中的开始&#x2F;结束结点</td>
</tr>
<tr>
<td><code>node[[text]]</code></td>
<td>子程序形状</td>
</tr>
<tr>
<td><code>node[(text)]</code></td>
<td>圆柱形状，通常是数据库会使用该形状</td>
</tr>
<tr>
<td><code>node((text))</code></td>
<td>圆形</td>
</tr>
<tr>
<td><code>node&gt;text]</code></td>
<td>不对称形状</td>
</tr>
<tr>
<td><code>node&#123;text&#125;</code></td>
<td>菱形，通常用作流程图中的判断</td>
</tr>
<tr>
<td><code>node&#123;&#123;text&#125;&#125;</code></td>
<td>菱边矩形</td>
</tr>
<tr>
<td><code>node[/text/]</code></td>
<td>平行四边形</td>
</tr>
<tr>
<td><code>node[\text\]</code></td>
<td>反平行四边形</td>
</tr>
<tr>
<td><code>node[/text\]</code></td>
<td>梯形</td>
</tr>
<tr>
<td><code>node[\text/]</code></td>
<td>倒梯形</td>
</tr>
<tr>
<td><code>node(((text)))</code></td>
<td>双圆</td>
</tr>
</tbody></table>
<p>示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">	A&gt;text] --&gt; B&#123;text&#125;--&gt;C[/text\]--&gt;D(((text)))</span><br></pre></td></tr></table></figure></div>

<pre class="mermaid">flowchart LR
    A>text] --> B{text}-->C[/text\]-->D(((text)))</pre>

<p>而当文字可能会破坏mermaid语法时，还需要使用兼容语法，即使用引号将文本圈起来：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    id1[&quot;This is the (text) in the box&quot;]--&gt;A[&quot;A double quote:#quot;&quot;] --&gt; B[&quot;A dec char:#9829;&quot;]</span><br></pre></td></tr></table></figure></div>

<pre class="mermaid">flowchart LR
    id1["This is the (text) in the box"]-->A["A double quote:#quot;"] --> B["A dec char:#9829;"]</pre>

<h3 id="1-3-连接样式"><a href="#1-3-连接样式" class="headerlink" title="1.3 连接样式"></a>1.3 连接样式</h3><h4 id="1-3-1-线条样式"><a href="#1-3-1-线条样式" class="headerlink" title="1.3.1 线条样式"></a>1.3.1 线条样式</h4><p>线条样式分为3种：实线、虚线和粗实线：</p>
<table>
<thead>
<tr>
<th>线条代码</th>
<th>样式</th>
</tr>
</thead>
<tbody><tr>
<td><code>A---B</code></td>
<td>实线</td>
</tr>
<tr>
<td><code>A-.-B</code></td>
<td>虚线</td>
</tr>
<tr>
<td><code>A===B</code></td>
<td>粗实线</td>
</tr>
</tbody></table>
<p>示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">	A---B-.-C===D</span><br></pre></td></tr></table></figure></div>

<pre class="mermaid">flowchart LR
    A---B-.-C===D</pre>

<h4 id="1-3-2-箭头样式"><a href="#1-3-2-箭头样式" class="headerlink" title="1.3.2 箭头样式"></a>1.3.2 箭头样式</h4><p>箭头样式有4种：箭头、无箭头、圆形和x形</p>
<table>
<thead>
<tr>
<th>箭头代码</th>
<th>样式</th>
</tr>
</thead>
<tbody><tr>
<td><code>A--&gt;B</code></td>
<td>箭头</td>
</tr>
<tr>
<td><code>A---B</code></td>
<td>无箭头</td>
</tr>
<tr>
<td><code>A--oB</code></td>
<td>圆形</td>
</tr>
<tr>
<td><code>A--xB</code></td>
<td>x形</td>
</tr>
<tr>
<td><code>A&lt;--&gt;B</code></td>
<td>双箭头</td>
</tr>
<tr>
<td><code>Ao--oB</code></td>
<td>双圆形</td>
</tr>
<tr>
<td><code>Ax--xB</code></td>
<td>双x形</td>
</tr>
</tbody></table>
<div class="note red"><p>使用中发现，如Dx–xE，并不会解析为双x形，而是会认为Dx是一个结点</p>
</div>

<p>示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">	A--&gt;B---C--oD(text)x--xE</span><br></pre></td></tr></table></figure></div>

<pre class="mermaid">flowchart LR
    A-->B---C--oD(text)x--xE</pre>

<h4 id="1-3-3-线条长度"><a href="#1-3-3-线条长度" class="headerlink" title="1.3.3 线条长度"></a>1.3.3 线条长度</h4><p>添加符号数量来增加连接线长度，实线增加<code>-</code>，虚线增加<code>.</code>，粗实线增加<code>=</code></p>
<table>
<thead>
<tr>
<th align="left">长度</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">实线</td>
<td align="center"><code>---</code></td>
<td align="center"><code>----</code></td>
<td align="center"><code>-----</code></td>
</tr>
<tr>
<td align="left">带箭头的实线</td>
<td align="center"><code>--&gt;</code></td>
<td align="center"><code>---&gt;</code></td>
<td align="center"><code>----&gt;</code></td>
</tr>
<tr>
<td align="left">粗实线</td>
<td align="center"><code>===</code></td>
<td align="center"><code>====</code></td>
<td align="center"><code>=====</code></td>
</tr>
<tr>
<td align="left">带箭头的粗实线</td>
<td align="center"><code>==&gt;</code></td>
<td align="center"><code>===&gt;</code></td>
<td align="center"><code>====&gt;</code></td>
</tr>
<tr>
<td align="left">虚线</td>
<td align="center"><code>-.-</code></td>
<td align="center"><code>-..-</code></td>
<td align="center"><code>-...-</code></td>
</tr>
<tr>
<td align="left">带箭头的虚线</td>
<td align="center"><code>-.-&gt;</code></td>
<td align="center"><code>-..-&gt;</code></td>
<td align="center"><code>-...-&gt;</code></td>
</tr>
</tbody></table>
<p>示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">	A---B===&gt;C&lt;-...-&gt;D</span><br></pre></td></tr></table></figure></div>

<pre class="mermaid">flowchart LR
    A---B===>C<-...->D</pre>

<h4 id="1-3-4-线条文字"><a href="#1-3-4-线条文字" class="headerlink" title="1.3.4 线条文字"></a>1.3.4 线条文字</h4><p>通常连接线上，还需要添加说明文字，按官方文档中有两种写法：</p>
<ul>
<li><code>A--&gt;|text|B</code></li>
<li><code>A--text--&gt;B</code></li>
</ul>
<p>这里我个人感觉使用第一种更清晰一些，因为使用<code>|</code>符号来表示文字，而线条的代码照旧。但第二种却需要变化线条的代码，增加了记忆上的难度。</p>
<p>如示例中，展示了带文字的虚线箭头，相比较下第一种写法更简单一些：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">	A-.text.-&gt;B-.-&gt;|text|C</span><br></pre></td></tr></table></figure></div>

<pre class="mermaid">flowchart LR
    A-.text.->B-.->|text|C</pre>

<h3 id="1-4-子图"><a href="#1-4-子图" class="headerlink" title="1.4 子图"></a>1.4 子图</h3><p>当流程图复杂到一定程度后，我们往往会用模块化的思想，将一些结点放在一个大结点中，使得流程图结构更清晰一些。这就是子图，使用<code>subgraph</code>来定义子图：</p>
<p>子图之间、各个结点之间乃至子图和结点之间都可以用连接线连接</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    subgraph A [one]</span><br><span class="line">    a1--&gt;a2</span><br><span class="line">    end</span><br><span class="line">    subgraph B [two]</span><br><span class="line">    b1--&gt;b2</span><br><span class="line">    end</span><br><span class="line">   	a2--&gt;b1</span><br></pre></td></tr></table></figure></div>

<pre class="mermaid">flowchart LR
    subgraph A [one]
    a1-->a2
    end
    subgraph B [two]
    b1-->b2
    end
       a2-->b1</pre>

<h3 id="1-5-较冷门用法"><a href="#1-5-较冷门用法" class="headerlink" title="1.5 较冷门用法"></a>1.5 较冷门用法</h3><p>除了上面这些最基本的绘图语法外，流程图还支持markdown中的粗体、斜体语法，js回调方法以及css样式</p>
<p>日常中应该很少会用到，就不一一记录了，如果以后真的使用到了再行补充</p>
<h2 id="二、饼图"><a href="#二、饼图" class="headerlink" title="二、饼图"></a>二、饼图</h2><p>使用<code>pie</code>定义</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pie title Pets adopted by volunteers</span><br><span class="line">    &quot;Dogs&quot; : 386</span><br><span class="line">    &quot;Cats&quot; : 85</span><br><span class="line">    &quot;Rats&quot; : 15</span><br></pre></td></tr></table></figure></div>

<pre class="mermaid">pie title Pets adopted by volunteers
    "Dogs" : 386
    "Cats" : 85
    "Rats" : 15</pre>]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>第一章、spring framework源码环境&amp;总体认知</title>
    <url>/2023/11/14/frame/springframework/P1.%E5%89%8D%E8%A8%80&amp;%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又要开新坑了，虽然前面很多坑都太监了。。其实也不是说想太监而是实在是深入不下去。比如设计模式，两种设计模式在我看来看不出区别但却是两种模式，完全无法理解其中的设计。刷题这块，目前刷了百题，hard级别的依旧很难解，唯一有进步的就是medium级别有了一些思路，但如果继续刷下去感觉也没啥提升了。</p>
<p>然后最近也是越来越焦虑、迷茫，毕业到现在工作了两年多，工作内容就是基于spring做业务堆砌，感觉一直没有接触到真正的编程，虽然我也想不清楚什么是真正的编程。。反正现在单纯的写业务对个人能力几乎没有提升了，然后尝试各个方向深入学习基本都是铩羽而归，收获甚微，导致越来越焦虑。</p>
<p>总之就是想提高自己的能力，所以这次决定从spring入手，希望借助spring打破现在的瓶颈，对自己的能力有所提升吧</p>
<p>为了这个目标也是尝试了很多方法：</p>
<ul>
<li>最开始尝试了官方文档，但是我英语不是很好，而且对spring很多概念都不了解，所以压根看不懂，失败告终</li>
<li>然后找到了一篇中文文档，翻译的很好，无奈还是看不懂</li>
<li>然后尝试从源码入手，搭建了源码环境，成功运行了，但是源码太多了，光是获得ApplicationContext就有很多种方式，完全不知道从哪里下手</li>
<li>最后找到了一个博客网站<a class="link"   href="https://bugstack.cn/" >小傅哥 bugstack 虫洞栈 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，里面有比较详细的spring源码解析，所以就先跟着博客走(当然不是就只看博客的内容，基于的内容还是源码，只是把博客当作一个顺序)</li>
</ul>
<p>挣扎了这么久说明我现在还不具备通过源码、官方文档自主学习的能力，只能在先去学习别人的学习成果。不过也情有可原，毕竟spring算是目前流行的最庞大的框架了吧。但是也要注意培养自己的这种能力。</p>
<h2 id="源码环境搭建"><a href="#源码环境搭建" class="headerlink" title="源码环境搭建"></a>源码环境搭建</h2><p>从github上拉取源码：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b 5.2.x https://github.com/spring-projects/spring-framework.git</span><br></pre></td></tr></table></figure></div>

<p>这里有第一个坑就是版本选择问题，spring版本更新很快且最新版本已经不支持Java8了，所以必须选择支持Java8的版本，这里选了<code>5.2.x</code></p>
<p>然后可以发现spring使用了gradle作为构建工具而不是maven，所以需要先安装gradle，这里gradle的版本也是一个坑。我最开始尝试使用最新版本，但是当包全部下载完成后，运行起来就出现各种奇奇怪怪的问题，import语句居然报错了。。第一次见</p>
<p>后来搜索了解到gradle版本不对也会有问题，然后选择了<code>5.6.3</code>版本</p>
<p>随后就是替换下载地址为国内镜像，这个和maven配置类似，具体可以参考：</p>
<p><a class="link"   href="https://blog.csdn.net/m0_37959155/article/details/126273608" >spring源码环境5.2.x搭建(截图详细，踩坑多)_座上客的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>到这一步后，创建了测试module，编写简单测试代码，启动成功了。这里有一个坑：就是module的gradle配置文件命名必须是{module_name}.gradle</p>
<p>至于上文中提到的AspectJ问题，还没有使用到，暂且先不管</p>
<p>至此环境已经搭建完成，开始漫长的spring学习~</p>
]]></content>
      <categories>
        <category>spring</category>
        <category>spring framework</category>
      </categories>
  </entry>
  <entry>
    <title>第三章、IoC之bean的注册</title>
    <url>/2023/11/20/frame/springframework/P3.IoC%E4%B9%8Bbean%E7%9A%84%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>spring</category>
        <category>spring framework</category>
      </categories>
  </entry>
  <entry>
    <title>第二章、IoC之bean容器以及bean的定义方式</title>
    <url>/2023/11/15/frame/springframework/P2.IoC%E4%B9%8Bbean%E5%AE%B9%E5%99%A8%E4%BB%A5%E5%8F%8Abean%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>关于IoC，这个概念是很熟悉了，即将对象的创建、依赖关系的管理和对象的生命周期的控制从应用程序代码中分离出来，交给Spring容器来完成。</p>
<p>最普遍的使用，比如我们创建了一个类，并在类A上加上<code>@Component</code>注解，然后就可以在B类中通过<code>@AutoWired</code>注入使用，也就是说A类就交给了Spring容器来管理了，即称为了一个bean</p>
<h2 id="一、bean容器"><a href="#一、bean容器" class="headerlink" title="一、bean容器"></a>一、bean容器</h2><div class="note success"><p>简单尝试：既然spring替我们管理bean，那么bean是保存在什么数据结构中的呢？</p>
</div>

<p>我们知道可以通过beanName来获取bean，那就有点类似是k-v键值对，所以可以先推测spring是使用map来存储bean的，至于是哪个map就需要从源码中找了</p>
<p>因为有了源码运行环境，找这个就很容易了！</p>
<p>首先，编写一个简单测试，通过ApplicationContext来获取bean。因为这里为了方便，注册bean不是用xml配置，而是用<code>@Bean</code>来做的，所以需要使用<code>AnnotationConfigApplicationContext</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(UserConfig.class);</span><br><span class="line">		<span class="comment">// 此处打断点，进行单步调试</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">		System.out.println(user);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在注释处打断点，进行单步调试</p>
<p>最终在<code>DefaultSingletonBeanRegistry</code>的<code>getSingleton(String, boolean)</code>方法中取到了bean，也见到了bean存放的地方：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure></div>

<p>在知道了bean容器是<code>ConcurrentHashMap</code>之外，还发现不管是类名、方法名还是变量名都有<code>singleton</code>，这很自然可以联想到<code>@Scope</code>作用域注解，可能不同作用域的bean存放在不同的地方，这一点后续再验证</p>
<h2 id="二、bean的定义"><a href="#二、bean的定义" class="headerlink" title="二、bean的定义"></a>二、bean的定义</h2><p>在spring最初的版本，只有通过xml来定义bean一种方法，而发展至今定义方式越来越多，但整体是从xml逐渐往注解过渡。</p>
<p>关于spring注解的发展可以看：<a class="link"   href="https://juejin.cn/post/7277799132110569533" >Spring注解编程的发展过程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>关于bean的定义方式，这里先贴一篇别人的文章占下位置，因为这一块不是很重要，常用的就那么几种，<a class="link"   href="https://juejin.cn/post/6981815953784995847" >面试官：spring中定义bean的方法有哪些? 我一口气说出了12种，把面试官彻底征服了。 - 掘金 (juejin.cn) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>spring</category>
        <category>spring framework</category>
      </categories>
  </entry>
</search>
