(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{429:function(s,a,t){"use strict";t.r(a);var e=t(2),n=Object(e.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("Boxx"),s._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#第10条、覆盖equals时请遵守通用约定"}},[s._v("第10条、覆盖equals时请遵守通用约定")])])])]),a("p"),s._v(" "),a("h2",{attrs:{id:"第10条、覆盖equals时请遵守通用约定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第10条、覆盖equals时请遵守通用约定"}},[s._v("#")]),s._v(" 第10条、覆盖equals时请遵守通用约定")]),s._v(" "),a("p",[s._v("覆盖 equals 方法看起来似乎很简单，但是有许多覆盖方式会导致错误，并且后果非常严重")]),s._v(" "),a("p",[s._v("最容易避免这类问题的办法就是不覆盖 equals 方法，在这种情况下，类的每个实例都只与自身相等")]),s._v(" "),a("p",[s._v("如果满足了以下任何一个条件，则无需覆盖equals方法：")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("类的每个实例都是唯一的")]),s._v(" "),a("p",[s._v("因为Object提供的equals方法就是比较二者是否为同一个对象，既然每个实例都是唯一的，那么如果不是同一个对象也必然是不相等的")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("boolean")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("equals")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),s._v(" obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])])]),s._v(" "),a("li",[a("p",[s._v("类没有必要提供equals方法")]),s._v(" "),a("p",[s._v("java.util.regex.Pattern可以覆盖 equals ，以检查两个 Pattern实例是否代表同一个正则表达式，但是设计者并不认为客户需或者期望这样的功能。在这类情况之下从Object继承得到的equals实现已经足够")])]),s._v(" "),a("li",[a("p",[s._v("父类已经覆盖了equals，子类也能使用父类的equals")]),s._v(" "),a("p",[s._v("如ArrayList直接使用了AbstractList中覆盖的equals方法")])]),s._v(" "),a("li",[a("p",[s._v("类是私有的，或者是包级私有的，可以确定它的 equals 方法永远不会被调用")]),s._v(" "),a("p",[s._v("但反射是可以实例化私有类的，因此想要彻底保护，可以重写equals方法并在方法中抛出异常")])])])],1)}),[],!1,null,null,null);a.default=n.exports}}]);