(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{432:function(s,a,e){"use strict";e.r(a);var t=e(2),l=Object(t.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("Boxx"),s._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#第10条、覆盖equals时请遵守通用约定"}},[s._v("第10条、覆盖equals时请遵守通用约定")])]),a("li",[a("a",{attrs:{href:"#第11条、覆盖equals时总要覆盖hashcode"}},[s._v("第11条、覆盖equals时总要覆盖hashCode")])])])]),a("p"),s._v(" "),a("h2",{attrs:{id:"第10条、覆盖equals时请遵守通用约定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第10条、覆盖equals时请遵守通用约定"}},[s._v("#")]),s._v(" 第10条、覆盖equals时请遵守通用约定")]),s._v(" "),a("p",[s._v("覆盖 equals 方法看起来似乎很简单，但是有许多覆盖方式会导致错误，并且后果非常严重")]),s._v(" "),a("p",[s._v("最容易避免这类问题的办法就是不覆盖 equals 方法，在这种情况下，类的每个实例都只与自身相等")]),s._v(" "),a("p",[s._v("如果满足了以下任何一个条件，则无需覆盖equals方法：")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("类的每个实例都是唯一的")]),s._v(" "),a("p",[s._v("因为Object提供的equals方法就是比较二者是否为同一个对象，既然每个实例都是唯一的，那么如果不是同一个对象也必然是不相等的")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("boolean")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("equals")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),s._v(" obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])])]),s._v(" "),a("li",[a("p",[s._v("类没有必要提供equals方法，从Object继承得到的equals足够使用")])]),s._v(" "),a("li",[a("p",[s._v("父类已经覆盖了equals，子类也能使用父类的equals")]),s._v(" "),a("p",[s._v("如ArrayList直接使用了AbstractList中覆盖的equals方法")])]),s._v(" "),a("li",[a("p",[s._v("类是私有的，或者是包级私有的，即 equals 方法永远不会被调用")]),s._v(" "),a("p",[s._v("但反射是可以实例化私有类的，因此想要彻底保护，可以重写equals方法并在方法中抛出异常")])])]),s._v(" "),a("p",[s._v("而当对象需要比较字段值，而父类又没有覆盖equals时，就需要覆盖equals。如String、Integer等")]),s._v(" "),a("p",[s._v("在覆盖 equals 方法的时候，必须要遵守它的通用约定：")]),s._v(" "),a("ul",[a("li",[s._v("自反性(reflexive)：对于任何非 null 的引用值 x，"),a("code",[s._v("x.equals(x)")]),s._v(" 必须返回true")]),s._v(" "),a("li",[s._v("对称性(symmetric)：对于任何非 null 的引用值 x 和 y，当且仅当 "),a("code",[s._v("y.equals(x)")]),s._v(" 返回 true 时，"),a("code",[s._v("x.equals(y)")]),s._v(" 也必须返回 true")]),s._v(" "),a("li",[s._v("传递性(transitive)：对于任何非 null 的引用值 x、y和z，如果"),a("code",[s._v("x.equals(y)")]),s._v(" 返回 true ，并且 "),a("code",[s._v("y.equals(z)")]),s._v(" 也返回 true ，那么 "),a("code",[s._v("x.equals(z)")]),s._v(" 也必须返回 true")]),s._v(" "),a("li",[s._v("一致性(consistent)：对于任何非 null 引用值 x 和 y，只要 equals 的比较操作在对象中所用的信息没有被修改，多次调用 "),a("code",[s._v("x.equals(y)")]),s._v(" 就会一致地返回true, 或者一致地返回 false")]),s._v(" "),a("li",[s._v("对于任何非 null 的引用值 x , "),a("code",[s._v("x.equals (null)")]),s._v(" 必须返回 false")])]),s._v(" "),a("p",[s._v("基于这些约定，有一些优秀的实践，在很多源码中都能找到这些实践：")]),s._v(" "),a("ol",[a("li",[a("p",[s._v("使用 == 操作符检查“参数是否为这个对象的引用”。如果是，则返回 true")]),s._v(" "),a("p",[s._v("因为同一个对象的两个引用，肯定是相等的。如果比较操作代价较大，可以作为一种性能优化")])]),s._v(" "),a("li",[a("p",[s._v("使用 instanceof 操作符检查“参数是否为正确的类型” 如果不是，则返回 false")])]),s._v(" "),a("li",[a("p",[s._v("把参数转换成正确的类型")])]),s._v(" "),a("li",[a("p",[s._v("对于该类中的每个“关键”（ significant ）域，检查参数中的域是否与该对象中对应的域相匹配")]),s._v(" "),a("p",[s._v("对于基本数据类型的关键域，使用 == 比较，对于引用数据类型，使用其 equals 比较")])])]),s._v(" "),a("p",[a("font",{attrs:{color:"#16b777"}},[s._v("使用IDEA，可以Ctrl+O，选择要比较的字段，快速实现equals方法，比较便利")])],1),s._v(" "),a("h2",{attrs:{id:"第11条、覆盖equals时总要覆盖hashcode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第11条、覆盖equals时总要覆盖hashcode"}},[s._v("#")]),s._v(" 第11条、覆盖equals时总要覆盖hashCode")]),s._v(" "),a("p",[s._v("在每个覆盖了 equals 方法的类中，都必须覆盖 hashCode 方法。如果不这样做的话，就会违反 hashCode 的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，如HashMap、HashSet等")]),s._v(" "),a("p",[s._v("下面是 hashCode 约定的内容，摘自 Object 规范：")])],1)}),[],!1,null,null,null);a.default=l.exports}}]);