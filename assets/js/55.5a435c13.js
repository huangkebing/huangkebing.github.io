(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{370:function(t,s,r){"use strict";r.r(s);var a=r(4),e=Object(a.a)({},(function(){var t=this._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h1",{attrs:{id:"第一章、并发的基本概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第一章、并发的基本概念"}},[this._v("#")]),this._v(" 第一章、并发的基本概念")]),this._v(" "),t("p",[this._v("目前对并发的理解全是基于表象的。new一个Thread，调用start方法，或者基于线程池。不管是哪种，都没有接触到线程的本质，因此对于线程阻塞、唤醒以及并发问题始终觉得很抽象，只能做到一知半解。因此想从底层入手，从CPU、内存的角度去了解线程，达到彻底理解并发的效果。")])])}),[],!1,null,null,null);s.default=e.exports}}]);