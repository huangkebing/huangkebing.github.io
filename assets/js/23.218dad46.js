(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{435:function(t,r,a){"use strict";a.r(r);var e=a(2),_=Object(e.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("Boxx"),t._v(" "),r("h2",{attrs:{id:"设计模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),r("ol",[r("li",[r("a",{attrs:{href:"https://www.huangkebing.com/blogs/design_pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E6%A6%82%E8%BF%B0.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("设计模式概述"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://www.huangkebing.com/blogs/design_pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E7%BB%93%E6%9E%84%E5%9E%8B.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("设计模式结构型"),r("OutboundLink")],1)])]),t._v(" "),r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#设计模式"}},[t._v("设计模式")])]),r("li",[r("a",{attrs:{href:"#适配器模式"}},[t._v("适配器模式")]),r("ul",[r("li",[r("a",{attrs:{href:"#类适配器"}},[t._v("类适配器")])])])])])]),r("p"),t._v(" "),r("p",[t._v("结构型设计模式是一组用于解决对象之间组合关系的设计模式，用于简化系统的设计，提高系统的可维护性和可扩展性。")]),t._v(" "),r("p",[t._v("结构型设计模式包括以下几种：")]),t._v(" "),r("ol",[r("li",[t._v("适配器模式（Adapter Pattern）：将一个类的接口转换成客户端所期望的另一种接口，解决不兼容问题")]),t._v(" "),r("li",[t._v("桥接模式（Bridge Pattern）：将抽象部分与它的实现部分分离，使它们可以独立地变化")]),t._v(" "),r("li",[t._v('组合模式（Composite Pattern）：将对象组合成树形结构，以表示"部分-整体"的层次结构，使得用户对单个对象和组合对象的使用具有一致性')]),t._v(" "),r("li",[t._v("装饰器模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责，就象给一个人穿上不同的衣服一样")]),t._v(" "),r("li",[t._v("外观模式（Facade Pattern）：为子系统中的一组接口提供一个一致的界面，使得子系统更加容易使用")]),t._v(" "),r("li",[t._v("享元模式（Flyweight Pattern）：运用共享技术有效地支持大量细粒度的对象，节省内存")]),t._v(" "),r("li",[t._v("代理模式（Proxy Pattern）：为其他对象提供一个代理以控制对这个对象访问的方式")])]),t._v(" "),r("p",[t._v("先争取将每个设计模式的定义、简单的代码示例写清楚。后续记录一些问题以及读源码时遇到的设计模式")]),t._v(" "),r("h2",{attrs:{id:"适配器模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式"}},[t._v("#")]),t._v(" 适配器模式")]),t._v(" "),r("p",[t._v("将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。\n在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。")]),t._v(" "),r("p",[r("font",{attrs:{color:"#16b777"}},[t._v("直白的说，如程序中已有一个类A，现在有一个新业务，其逻辑和A一致，但入参、返回值不一样")])],1),t._v(" "),r("p",[t._v("适配器模式可以分为类适配器、对象适配器和接口适配器")]),t._v(" "),r("h3",{attrs:{id:"类适配器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类适配器"}},[t._v("#")]),t._v(" 类适配器")])],1)}),[],!1,null,null,null);r.default=_.exports}}]);