(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{435:function(v,_,t){"use strict";t.r(_);var a=t(2),r=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("Boxx"),v._v(" "),_("h2",{attrs:{id:"设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[v._v("#")]),v._v(" 设计模式")]),v._v(" "),_("ol",[_("li",[_("a",{attrs:{href:"https://www.huangkebing.com/blogs/design_pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E6%A6%82%E8%BF%B0.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("设计模式概述"),_("OutboundLink")],1)])]),v._v(" "),_("p"),_("div",{staticClass:"table-of-contents"},[_("ul",[_("li",[_("a",{attrs:{href:"#设计模式"}},[v._v("设计模式")])]),_("li",[_("a",{attrs:{href:"#设计模式的目标"}},[v._v("设计模式的目标")])]),_("li",[_("a",{attrs:{href:"#单一职责原则"}},[v._v("单一职责原则")])]),_("li",[_("a",{attrs:{href:"#里氏替换原则"}},[v._v("里氏替换原则")])]),_("li",[_("a",{attrs:{href:"#依赖倒置原则"}},[v._v("依赖倒置原则")])]),_("li",[_("a",{attrs:{href:"#接口隔离原则"}},[v._v("接口隔离原则")])]),_("li",[_("a",{attrs:{href:"#迪米特法则"}},[v._v("迪米特法则")])]),_("li",[_("a",{attrs:{href:"#开闭原则"}},[v._v("开闭原则")])])])]),_("p"),v._v(" "),_("p",[v._v("梳理了一下设计模式的目标和原则，但是很多地方都理解不透，很难和实际开发联系起来，开发经验还是不足")]),v._v(" "),_("h2",{attrs:{id:"设计模式的目标"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的目标"}},[v._v("#")]),v._v(" 设计模式的目标")]),v._v(" "),_("p",[v._v("设计模式是为了提高代码重用性、可读性、可扩展性、可靠性，使得程序呈现出高内聚、低耦合的特性")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("代码重用性")]),v._v(" "),_("p",[v._v("代码重用性是指在开发过程中，将可重用的代码抽象出来，形成一个可以多次使用的独立程序模块或函数，以提高开发效率的能力。这可以节省时间和开发资源，并降低代码的维护成本。重复使用代码还可以提高程序的稳定性和可靠性，减少错误和缺陷。")]),v._v(" "),_("p",[_("font",{attrs:{color:"#dd0000"}},[v._v("这里并不是简单的提取方法，我在业务代码上就遇到过其他人抽的工具方法，但他的方法里还有一些特殊处理，但是我本次要实现的业务不需要这部分处理！但我又不敢动这个方法，因为影响的地方很多，只能另写。所以说在做方法封装，尤其是基本方法时，最好是一个方法只做一件事情！")])],1)]),v._v(" "),_("li",[_("p",[v._v("可读性")]),v._v(" "),_("p",[v._v("代码可读性指的是源代码易于被其他人阅读、理解和维护的程度。可读性良好的代码应该易于阅读，表达清晰，遵循一致的命名规则和代码风格，包含适当的注释和文档，结构清晰，没有过于复杂的逻辑，以及易于调试和修改。")]),v._v(" "),_("p",[_("font",{attrs:{color:"#16b777"}},[v._v("跟据我的经验，做到可读性，需要做到这些：")])],1),v._v(" "),_("ul",[_("li",[_("font",{attrs:{color:"#16b777"}},[v._v("命名：通过变量名、方法名可以知晓作用，而不用跟据代码去推断")])],1),v._v(" "),_("li",[_("font",{attrs:{color:"#16b777"}},[v._v("注释：注释详尽，尤其是特殊处理、核心逻辑的注释")])],1),v._v(" "),_("li",[_("font",{attrs:{color:"#16b777"}},[v._v("结构：一个类不要写很多方法，一个方法也不要写很多if，注意代码复杂度")])],1)]),v._v(" "),_("p",[v._v("一些老的业务代码，命名用的拼音缩写还没有注释，你熟悉这些业务时跟猜谜游戏一样。还有所有逻辑都放在一个类里，非常臃肿，找逻辑非常费劲，读起来经常读着读着就不知道到哪了")])]),v._v(" "),_("li",[_("p",[v._v("可扩展性")]),v._v(" "),_("p",[v._v("代码可扩展性是指代码的设计和实现方式，使得在现有的系统结构上能够简便地添加新的功能或扩展现有的功能，同时保持代码的可靠性、可读性、可维护性、可重用性和性能表现。代码可扩展性是在软件开发中非常重要的一种软件特性，因为随着业务发展和软件需求的不断变化，软件系统需要不断地进行功能扩展和改进。如果代码不具备可扩展性，就会面临极高的成本和复杂度，甚至需要彻底重构系统来适应新的需求")]),v._v(" "),_("p",[v._v("可扩展性是最难去做的，往往日常开发中，遇到问题都是加个if，或者加个方法处理。这样长久必然出现可读性的问题。而可扩展性，难在需要在前期就将需求整理清晰，并做好代码结构的规划，还需要对未来不可预知的内容留足空间。而这的基本要求就是要熟练掌握设计模式")]),v._v(" "),_("p",[_("font",{attrs:{color:"#16b777"}},[v._v("举个简单的例子：处理流程非常多的，可以用责任链模式改造，将每个步骤封装到链路节点中，将来要加新的处理逻辑时，只需要新建一个节点，可以有效避免代码堆砌")])],1)]),v._v(" "),_("li",[_("p",[v._v("可靠性")]),v._v(" "),_("p",[v._v("代码可靠性是指代码在运行过程中能够提供准确出错信息，并能够避免出现系统崩溃或不可预期的错误情况。代码可靠性的提高需要从多个方面入手，包括代码设计、编程实现、代码测试、缺陷修复等多个环节。代码可靠性的提高可以增加系统的稳定性和可用性，降低运维成本和故障数量")]),v._v(" "),_("p",[v._v("这部分主要是通过日志的设计来获得准确信息，以及测试的工作。"),_("font",{attrs:{color:"#dd0000"}},[v._v("但要注意，日志不要滥写，try-catch也不要到处都是最好是统一管理")])],1)]),v._v(" "),_("li",[_("p",[v._v("高内聚、低耦合")]),v._v(" "),_("p",[v._v("高内聚低耦合是一种软件设计原则，其中“高内聚”指模块内部紧密地相关，且单一模块的职责明确，而“低耦合”指不同模块之间尽可能地减少相互依赖，从而提高系统的可维护性、可重用性和可扩展性")])])]),v._v(" "),_("h2",{attrs:{id:"单一职责原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则"}},[v._v("#")]),v._v(" 单一职责原则")]),v._v(" "),_("p",[v._v("单一职责原则(Single Responsibility Principle)，英文缩写为SRP")]),v._v(" "),_("p",[v._v("是指一个类或者模块（函数、方法）只负责完成一个职责或功能，不应该去承担其他的职责或功能。换句话说，一个类或者模块应该只有一个引起它变化的原因")]),v._v(" "),_("p",[v._v("但事实上，单一是一个非常主观的概念：")]),v._v(" "),_("p",[v._v("比如说有一个类，专门负责计算某项数据，输入为原始数据，输出为计算后的数据。那么这个类从宏观上就是单一的，因为他只做了这件事情。")]),v._v(" "),_("p",[v._v("但如果这个类有3000行，包含60个方法呢？")]),v._v(" "),_("p",[v._v("因此我的理解，不光光说是认为单一就足够了，还需要结合实际情况和业务场景")]),v._v(" "),_("ul",[_("li",[v._v("类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性")]),v._v(" "),_("li",[v._v("类依赖的其他类过多,或者依赖类的其他类过多,不符合高内聚、低耦合的设计思想")]),v._v(" "),_("li",[v._v("私有方法过多,我们就要考虑能否将私有方法独立到新的类中,设置为public方法,供更多的类使用")]),v._v(" "),_("li",[v._v("比较难给类起一个合适名字,很难用一个业务名词概括,或者只能用一些笼统的Manager、 Context之类的词语来命名,这就说明类的职责定义得可能不够清晰")])]),v._v(" "),_("h2",{attrs:{id:"里氏替换原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换原则"}},[v._v("#")]),v._v(" 里氏替换原则")]),v._v(" "),_("p",[v._v("里氏替换原则（Liskov Substitution Principle，LSP）是面向对象程序设计中的一个原则，由Barbara Liskov和Jeannette Wing于1987年提出。该原则表明，子类应该能够替换他们的基类，而程序仍然不会出错。换句话说，子类应该完全继承其父类的行为，同时还能够扩展新的功能，而不会导致任何不符合预期的结果。")]),v._v(" "),_("p",[v._v("我的理解。当父类是可实例化的类(排除接口和抽象类)，父类与子类的约定。里氏替换原则要求子类在进行设计的时候要遵守父类的一些行为约定。")]),v._v(" "),_("ul",[_("li",[v._v("子类中可以增加自己特有的方法")]),v._v(" "),_("li",[v._v("当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松")]),v._v(" "),_("li",[v._v("当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等")]),v._v(" "),_("li",[v._v("子类重载方法，不能抛出父类中没有约定的异常")])]),v._v(" "),_("p",[v._v("如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。")]),v._v(" "),_("h2",{attrs:{id:"依赖倒置原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒置原则"}},[v._v("#")]),v._v(" 依赖倒置原则")]),v._v(" "),_("p",[v._v("依赖倒置原则(Dependence Inversion Principle)是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。")]),v._v(" "),_("p",[v._v("依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则：")]),v._v(" "),_("ul",[_("li",[v._v("每个类尽量提供接口或抽象类，或者两者都具备")]),v._v(" "),_("li",[v._v("变量的声明类型尽量是接口或者是抽象类")]),v._v(" "),_("li",[v._v("任何类都不应该从具体类派生")]),v._v(" "),_("li",[v._v("使用继承时尽量遵循里氏替换原则")])]),v._v(" "),_("h2",{attrs:{id:"接口隔离原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则"}},[v._v("#")]),v._v(" 接口隔离原则")]),v._v(" "),_("p",[v._v("客户端不应该依赖它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。")]),v._v(" "),_("ul",[_("li",[v._v("建立单一接口，不要建立庞大臃肿的接口")]),v._v(" "),_("li",[v._v("尽量细化接口，接口中的方法尽量少")])]),v._v(" "),_("p",[v._v("注意：注意适度原则，一定要适度，过大的话会增加耦合性，而过小的话会增加复杂性和开发成本")]),v._v(" "),_("p",[v._v("优点：符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性")]),v._v(" "),_("p",[v._v("这是针对接口设计的原则，即一个类实现接口，会不会有我用不到的方法需要我去实现，如果有那么这个接口是不符合接口隔离原则的")]),v._v(" "),_("h2",{attrs:{id:"迪米特法则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#迪米特法则"}},[v._v("#")]),v._v(" 迪米特法则")]),v._v(" "),_("p",[v._v("迪米特法则（Law of Demeter）又称最少知识原则（Principle of Least Knowledge），是一种软件设计原则，其主要目的是减少对象间的耦合度，使得模块化的程序更加灵活、可维护、易于扩展。")]),v._v(" "),_("p",[v._v("迪米特法则的基本原则是：一个对象应该对其他对象保持最少的了解，即一个对象不应该直接与其他对象交互，而应该通过中间对象进行交互，从而避免对象之间的耦合。这样可以减少对象之间的依赖关系，降低系统的复杂度，提高代码的可读性和可维护性。")]),v._v(" "),_("p",[v._v("迪米特法则的另一种表述：只与你的直接朋友通信，不与陌生人通信。直接朋友包括以下几种：当前对象本身、被当作方法参数传递进来的对象、当前对象的实例变量直接引用的对象以及当前对象的任何一个方法中创建的对象。")]),v._v(" "),_("p",[v._v("这个地方朋友、陌生人在代码中分别指代哪些东西，实在是没看懂")]),v._v(" "),_("h2",{attrs:{id:"开闭原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则"}},[v._v("#")]),v._v(" 开闭原则")]),v._v(" "),_("p",[v._v("开闭原则（Open Closed Principle）是编程中最基础、最重要设计原则")]),v._v(" "),_("p",[v._v("一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节。")]),v._v(" "),_("p",[v._v("当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。")]),v._v(" "),_("p",[v._v("编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则")])],1)}),[],!1,null,null,null);_.default=r.exports}}]);