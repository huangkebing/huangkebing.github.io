(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{430:function(t,a,v){"use strict";v.r(a);var _=v(2),r=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("Boxx"),t._v(" "),a("h2",{attrs:{id:"设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#设计模式"}},[t._v("设计模式")])]),a("li",[a("a",{attrs:{href:"#设计模式的目标"}},[t._v("设计模式的目标")])]),a("li",[a("a",{attrs:{href:"#单一职责原则"}},[t._v("单一职责原则")])]),a("li",[a("a",{attrs:{href:"#里氏替换原则"}},[t._v("里氏替换原则")])]),a("li",[a("a",{attrs:{href:"#依赖倒置原则"}},[t._v("依赖倒置原则")])]),a("li",[a("a",{attrs:{href:"#接口隔离原则"}},[t._v("接口隔离原则")])]),a("li",[a("a",{attrs:{href:"#开闭原则"}},[t._v("开闭原则")])]),a("li",[a("a",{attrs:{href:"#迪米特法则"}},[t._v("迪米特法则")])]),a("li",[a("a",{attrs:{href:"#合成复用原则"}},[t._v("合成复用原则")])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"设计模式的目标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的目标"}},[t._v("#")]),t._v(" 设计模式的目标")]),t._v(" "),a("p",[t._v("设计模式是为了提高代码重用性、可读性、可扩展性、可靠性，使得程序呈现出高内聚、低耦合的特性")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("代码重用性")]),t._v(" "),a("p",[t._v("代码重用性是指在开发过程中，将可重用的代码抽象出来，形成一个可以多次使用的独立程序模块或函数，以提高开发效率的能力。这可以节省时间和开发资源，并降低代码的维护成本。重复使用代码还可以提高程序的稳定性和可靠性，减少错误和缺陷。")]),t._v(" "),a("p",[a("font",{attrs:{color:"#dd0000"}},[t._v("这里并不是简单的提取方法，我在业务代码上就遇到过其他人抽的工具方法，但他的方法里还有一些特殊处理，但是我本次要实现的业务不需要这部分处理！但我又不敢动这个方法，因为影响的地方很多，只能另写。所以说在做方法封装，尤其是基本方法时，最好是一个方法只做一件事情！")])],1)]),t._v(" "),a("li",[a("p",[t._v("可读性")]),t._v(" "),a("p",[t._v("代码可读性指的是源代码易于被其他人阅读、理解和维护的程度。可读性良好的代码应该易于阅读，表达清晰，遵循一致的命名规则和代码风格，包含适当的注释和文档，结构清晰，没有过于复杂的逻辑，以及易于调试和修改。")]),t._v(" "),a("p",[a("font",{attrs:{color:"#16b777"}},[t._v("跟据我的经验，做到可读性，需要做到这些：")])],1),t._v(" "),a("ul",[a("li",[a("font",{attrs:{color:"#16b777"}},[t._v("命名：通过变量名、方法名可以知晓作用，而不用跟据代码去推断")])],1),t._v(" "),a("li",[a("font",{attrs:{color:"#16b777"}},[t._v("注释：注释详尽，尤其是特殊处理、核心逻辑的注释")])],1),t._v(" "),a("li",[a("font",{attrs:{color:"#16b777"}},[t._v("结构：一个类不要写很多方法，一个方法也不要写很多if，注意代码复杂度")])],1)]),t._v(" "),a("p",[t._v("一些老的业务代码，命名用的拼音缩写还没有注释，你熟悉这些业务时跟猜谜游戏一样。还有所有逻辑都放在一个类里，非常臃肿，找逻辑非常费劲，读起来经常读着读着就不知道到哪了")])]),t._v(" "),a("li",[a("p",[t._v("可扩展性")]),t._v(" "),a("p",[t._v("代码可扩展性是指代码的设计和实现方式，使得在现有的系统结构上能够简便地添加新的功能或扩展现有的功能，同时保持代码的可靠性、可读性、可维护性、可重用性和性能表现。代码可扩展性是在软件开发中非常重要的一种软件特性，因为随着业务发展和软件需求的不断变化，软件系统需要不断地进行功能扩展和改进。如果代码不具备可扩展性，就会面临极高的成本和复杂度，甚至需要彻底重构系统来适应新的需求")]),t._v(" "),a("p",[t._v("可扩展性是最难去做的，往往日常开发中，遇到问题都是加个if，或者加个方法处理。这样长久必然出现可读性的问题。而可扩展性，难在需要在前期就将需求整理清晰，并做好代码结构的规划，还需要对未来不可预知的内容留足空间。而这的基本要求就是要熟练掌握设计模式")]),t._v(" "),a("p",[a("font",{attrs:{color:"#16b777"}},[t._v("举个简单的例子：处理流程非常多的，可以用责任链模式改造，将每个步骤封装到链路节点中，将来要加新的处理逻辑时，只需要新建一个节点，可以有效避免代码堆砌")])],1)]),t._v(" "),a("li",[a("p",[t._v("可靠性")]),t._v(" "),a("p",[t._v("代码可靠性是指代码在运行过程中能够提供准确出错信息，并能够避免出现系统崩溃或不可预期的错误情况。代码可靠性的提高需要从多个方面入手，包括代码设计、编程实现、代码测试、缺陷修复等多个环节。代码可靠性的提高可以增加系统的稳定性和可用性，降低运维成本和故障数量")]),t._v(" "),a("p",[t._v("这部分主要是通过日志的设计来获得准确信息，以及测试的工作。"),a("font",{attrs:{color:"#dd0000"}},[t._v("但要注意，日志不要滥写，try-catch也不要到处都是最好是统一管理")])],1)]),t._v(" "),a("li",[a("p",[t._v("高内聚、低耦合")]),t._v(" "),a("p",[t._v("高内聚低耦合是一种软件设计原则，其中“高内聚”指模块内部紧密地相关，且单一模块的职责明确，而“低耦合”指不同模块之间尽可能地减少相互依赖，从而提高系统的可维护性、可重用性和可扩展性")])])]),t._v(" "),a("h2",{attrs:{id:"单一职责原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则"}},[t._v("#")]),t._v(" 单一职责原则")]),t._v(" "),a("p",[t._v("单一职责原则(Single Responsibility Principle)，英文缩写为SRP")]),t._v(" "),a("p",[t._v("是指一个类或者模块（函数、方法）只负责完成一个职责或功能，不应该去承担其他的职责或功能。换句话说，一个类或者模块应该只有一个引起它变化的原因")]),t._v(" "),a("p",[t._v("但事实上，单一是一个非常主观的概念：")]),t._v(" "),a("p",[t._v("比如说有一个类，专门负责计算某项数据，输入为原始数据，输出为计算后的数据。那么这个类从宏观上就是单一的，因为他只做了这件事情。")]),t._v(" "),a("p",[t._v("但如果这个类有3000行，包含60个方法呢？")]),t._v(" "),a("p",[t._v("因此我的理解，不光光说是认为单一就足够了，还需要结合实际情况和业务场景")]),t._v(" "),a("ul",[a("li",[t._v("类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性")]),t._v(" "),a("li",[t._v("类依赖的其他类过多,或者依赖类的其他类过多,不符合高内聚、低耦合的设计思想")]),t._v(" "),a("li",[t._v("私有方法过多,我们就要考虑能否将私有方法独立到新的类中,设置为public方法,供更多的类使用")]),t._v(" "),a("li",[t._v("比较难给类起一个合适名字,很难用一个业务名词概括,或者只能用一些笼统的Manager、 Context之类的词语来命名,这就说明类的职责定义得可能不够清晰")])]),t._v(" "),a("h2",{attrs:{id:"里氏替换原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换原则"}},[t._v("#")]),t._v(" 里氏替换原则")]),t._v(" "),a("p",[t._v("里氏替换原则（Liskov Substitution Principle，LSP）是面向对象程序设计中的一个原则，由Barbara Liskov和Jeannette Wing于1987年提出。该原则表明，子类应该能够替换他们的基类，而程序仍然不会出错。换句话说，子类应该完全继承其父类的行为，同时还能够扩展新的功能，而不会导致任何不符合预期的结果。")]),t._v(" "),a("h2",{attrs:{id:"依赖倒置原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒置原则"}},[t._v("#")]),t._v(" 依赖倒置原则")]),t._v(" "),a("h2",{attrs:{id:"接口隔离原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则"}},[t._v("#")]),t._v(" 接口隔离原则")]),t._v(" "),a("h2",{attrs:{id:"开闭原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则"}},[t._v("#")]),t._v(" 开闭原则")]),t._v(" "),a("h2",{attrs:{id:"迪米特法则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#迪米特法则"}},[t._v("#")]),t._v(" 迪米特法则")]),t._v(" "),a("h2",{attrs:{id:"合成复用原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合成复用原则"}},[t._v("#")]),t._v(" 合成复用原则")])],1)}),[],!1,null,null,null);a.default=r.exports}}]);