(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{432:function(t,e,r){"use strict";r.r(e);var a=r(2),n=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("Boxx"),t._v(" "),e("h2",{attrs:{id:"设计模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),e("ol",[e("li",[e("a",{attrs:{href:"https://www.huangkebing.com/blogs/design_pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E6%A6%82%E8%BF%B0.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("设计模式概述"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.huangkebing.com/blogs/design_pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E7%BB%93%E6%9E%84%E5%9E%8B.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("设计模式结构型"),e("OutboundLink")],1)])]),t._v(" "),e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#设计模式"}},[t._v("设计模式")])]),e("li",[e("a",{attrs:{href:"#适配器模式"}},[t._v("适配器模式")])])])]),e("p"),t._v(" "),e("p",[t._v("结构型设计模式是一组用于解决对象之间组合关系的设计模式，用于简化系统的设计，提高系统的可维护性和可扩展性。")]),t._v(" "),e("p",[t._v("结构型设计模式包括以下几种：")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("适配器模式（Adapter Pattern）：将一个类的接口转换成客户端所期望的另一种接口，解决不兼容问题")])]),t._v(" "),e("li",[e("p",[t._v("桥接模式（Bridge Pattern）：将抽象部分与它的实现部分分离，使它们可以独立地变化")])]),t._v(" "),e("li",[e("p",[t._v('组合模式（Composite Pattern）：将对象组合成树形结构，以表示"部分-整体"的层次结构，使得用户对单个对象和组合对象的使用具有一致性')])]),t._v(" "),e("li",[e("p",[t._v("装饰器模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责，就象给一个人穿上不同的衣服一样")])]),t._v(" "),e("li",[e("p",[t._v("外观模式（Facade Pattern）：为子系统中的一组接口提供一个一致的界面，使得子系统更加容易使用")])]),t._v(" "),e("li",[e("p",[t._v("享元模式（Flyweight Pattern）：运用共享技术有效地支持大量细粒度的对象，节省内存")])]),t._v(" "),e("li",[e("p",[t._v("代理模式（Proxy Pattern）：为其他对象提供一个代理以控制对这个对象访问的方式")])])]),t._v(" "),e("h2",{attrs:{id:"适配器模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式"}},[t._v("#")]),t._v(" 适配器模式")]),t._v(" "),e("p",[t._v("适配器模式可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定 他们就成。 ● 增加了类的透明性 想想看，我们访问的Target目标角色，但是具体的实现都委托给了源角色，而这些对高 层次模块是透明的，也是它不需要关心的。 ● 提高了类的复用度 当然了，源角色在原有的系统中还是可以正常使用，而在目标角色中也可以充当新的演 员。 ● 灵活性非常好 某一天，突然不想要适配器，没问题，删除掉这个适配器就可以了，其他的代码都不用 修改，基本上就类似一个灵活的构件，想用就用，不想就卸载。")])],1)}),[],!1,null,null,null);e.default=n.exports}}]);